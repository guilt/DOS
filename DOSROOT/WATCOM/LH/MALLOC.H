/*
 *  malloc.h    Memory allocation functions
 *
 * =========================================================================
 *
 *                          Open Watcom Project
 *
 * Copyright (c) 2004-2024 The Open Watcom Contributors. All Rights Reserved.
 * Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
 *
 *    This file is automatically generated. Do not edit directly.
 *
 * =========================================================================
 */
#ifndef _MALLOC_H_INCLUDED
#define _MALLOC_H_INCLUDED

#ifndef _ENABLE_AUTODEPEND
 #pragma read_only_file
#endif

#ifndef __COMDEF_H_INCLUDED
 #include <_comdef.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack( __push, 8 )

#ifdef __cplusplus
 #ifndef _STDSIZE_T_DEFINED
 #define _STDSIZE_T_DEFINED
  namespace std {
    typedef unsigned size_t;
  }
  typedef std::size_t __w_size_t;
 #endif
 #ifndef _SIZE_T_DEFINED
 #define _SIZE_T_DEFINED
  #define _SIZE_T_DEFINED_
  using std::size_t;
 #endif
#else  /* __cplusplus not defined */
 #ifndef _SIZE_T_DEFINED
 #define _SIZE_T_DEFINED
  #define _SIZE_T_DEFINED_
  typedef unsigned size_t;
  typedef size_t   __w_size_t;
 #endif
#endif /* __cplusplus not defined */

#ifndef NULL
#ifdef __cplusplus
  #define NULL 0
#else
 #ifdef __RDOSDEV__
  #define NULL 0
 #else
  #define NULL ((void *)0)
 #endif
#endif
#endif

#ifndef alloca
 _WCRTLINK extern unsigned stackavail( void );
 _WCRTLINK extern unsigned _stackavail( void );
 #ifdef _M_IX86
  #pragma aux stackavail __modify __nomemory
  #pragma aux _stackavail __modify __nomemory

  #if defined(__COMPACT__) || defined(__LARGE__) || defined(__HUGE__) || defined(__SW_ZU)
   extern void __based(__segname("_STACK")) *__doalloca(__w_size_t __size);
  #else
   extern void *__doalloca(__w_size_t __size);
  #endif
   #pragma aux __doalloca = \
           "sub esp,eax"   \
       __parm __nomemory [__eax] \
       __value [__esp] \
       __modify __exact __nomemory [__esp]

  #define __ALLOCA_ALIGN( s )   (((s)+(sizeof(int)-1))&~(sizeof(int)-1))
  #define __alloca( s )         __doalloca(__ALLOCA_ALIGN(s))

   #define alloca( s )  ((__ALLOCA_ALIGN(s)<stackavail())?__alloca(s): (void *)0)
   #define _alloca( s ) ((__ALLOCA_ALIGN(s)<stackavail())?__alloca(s): (void *)0)

 #else
  extern void *__builtin_alloca(__w_size_t __size);
  #pragma intrinsic(__builtin_alloca)

  #define __alloca( s ) (__builtin_alloca(s))

  #define alloca( s )   ((s<stackavail())?__alloca(s):(void *)0)
  #define _alloca( s )  ((s<stackavail())?__alloca(s):(void *)0)
 #endif
#endif

#define _HEAPOK         0
#define _HEAPEMPTY      1       /* heap isn't initialized */
#define _HEAPBADBEGIN   2       /* heap header is corrupted */
#define _HEAPBADNODE    3       /* heap entry is corrupted */
#define _HEAPEND        4       /* end of heap entries (_heapwalk) */
#define _HEAPBADPTR     5       /* invalid heap entry pointer (_heapwalk) */

#define _USEDENTRY      0
#define _FREEENTRY      1

#ifdef _M_IX86
 #define __FILLER_MALLOC(__a)   unsigned short __a;
#else
 #define __FILLER_MALLOC(__a)
#endif

typedef struct _heapinfo {
    void _WCFAR *_pentry; __FILLER_MALLOC(_1) /* heap pointer */
    size_t      _size;                  /* heap entry size */
    int         _useflag;               /* heap entry 'in-use' flag */
} _HEAPINFO;

_WCRTLINK extern int _heapenable( int __enabled );
_WCRTLINK extern int _heapchk( void );
_WCRTLINK extern int _nheapchk( void );
_WCRTLINK extern int _heapset( unsigned int __fill );
_WCRTLINK extern int _nheapset( unsigned int __fill );
_WCRTLINK extern int _heapwalk( struct _heapinfo *__entry );
_WCRTLINK extern int _nheapwalk( struct _heapinfo *__entry );

_WCRTLINK extern void _heapgrow( void );
_WCRTLINK extern void _nheapgrow( void );
_WCRTLINK extern int _heapmin( void );
_WCRTLINK extern int _nheapmin( void );
_WCRTLINK extern int _heapshrink( void );
_WCRTLINK extern int _nheapshrink( void );

_WCRTLINK extern int __nmemneed( size_t );
_WCRTLINK extern void *_expand( void *__ptr, size_t __size );
_WCRTLINK extern unsigned int _freect( size_t __size );
_WCRTLINK extern size_t _msize( void *__ptr );

_WCRTLINK extern void _WCNEAR *_ncalloc( __w_size_t __n, __w_size_t __size );
_WCRTLINK extern void _WCNEAR *_nexpand( void _WCNEAR *__ptr, __w_size_t __size );
_WCRTLINK extern void _nfree( void _WCNEAR *__ptr );
_WCRTLINK extern void _WCNEAR *_nmalloc( __w_size_t __size );
_WCRTLINK extern void _WCNEAR *_nrealloc( void _WCNEAR *__ptr, __w_size_t __size );
_WCRTLINK extern __w_size_t _nmsize( void _WCNEAR *__ptr );

_WCRTLINK extern size_t _memavl( void );
_WCRTLINK extern size_t _memmax( void );

#ifdef __cplusplus
namespace std {
#endif

_WCRTLINK extern void *calloc( size_t __n, size_t __size );
_WCRTLINK extern void free( void *__ptr );
_WCRTLINK extern void *malloc( size_t __size );
_WCRTLINK extern void *realloc( void *__ptr, size_t __size );

#ifdef __cplusplus
} // namespace std
using std::calloc;
using std::free;
using std::malloc;
using std::realloc;

#endif

#pragma pack( __pop )

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
