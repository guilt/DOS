Dies ist editor.inf, hergestellt von Makeinfo Version 4.0 aus editor.num.

START-INFO-DIR-ENTRY
* SET's Editor: (setedit). A friendly text editor.
END-INFO-DIR-ENTRY

This is the documentation for SET's Editor.

Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Salvador Eduardo Tropea

This documentation may be freely distributed, provided this copyright
notice is left intact on all copies.


File: editor.inf,  Node: Top,  Prev: (dir),  Up: (dir)

EDITOR
******

This is the documentation for SET's Editor.

Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Salvador Eduardo Tropea

This documentation may be freely distributed, provided this copyright
notice is left intact on all copies.

The following master menu lists the major topics in this documentation,
including all the indices.

Pressing F1 when selecting any item of the menu you'll get help about it.

* Menu:

* Introduction::
* Available commands and keys assignments::
* Keyboard configuration::
* Pull-down menues::
* Editing Modes::
* Syntax Highlight File::
* Pseudo Macros::
* sLisp macros::
* Calculator::
* How to contact me::
* Miscellaneous::
* Index::
* Index of key commands::


File: editor.inf,  Node: Introduction,  Next: Available commands and keys assignments,  Prev: Top,  Up: Top

1 Introduction
**************

   This document describes the use of the SET's editor; this editor was
designed for programmers and to be used alone or inside of the RHIDE.

   This documentation may be freely distributed with the editor or the
RHIDE package or any part thereof, provided this copyright notice is left
intact on all copies.

   Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

  People who helped me develop the editor:

   * ROBERT H”HNE <robert.hoehne@gmx.net>
     (with some base routines, a lot of patches and reports)

   * MOLNAR LASZLO <molnarl@cdata.tvnet.hu>
     (with the old calculator, tests and a lot of ideas)

   * MAREK HABERSACK <grendel@ananke.amu.edu.pl>
     (with tests and a lot of ideas)

   * FRANK DONAHOE <fdonahoe@wilkes1.wilkes.edu>
     (with a lot of corrections to this text)

   * BURTON RADONS <loth@pacificcoast.net>
     (with the new calculator, bug reports and ideas)

  The editor is distributed under the GPL license. Please read the files
included in the source distribution for more information.

  This editor is included in the Robert H”hne's RHIDE as a replacement for
the original Turbo Vision's editor class.

* Menu:

* Copying::
* What is SETs Editor?::
* About the Author::


File: editor.inf,  Node: Copying,  Next: What is SETs Editor?,  Prev: Introduction,  Up: Introduction

1.1 Copying
===========

  The editor is distributed under the GPL license:

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  A copy of the license should be in the package, if not please tell me.


File: editor.inf,  Node: What is SETs Editor?,  Next: About the Author,  Prev: Copying,  Up: Introduction

1.2 What is SETs Editor?
========================

  SET's editor is an editor designed to be used by programmers; the main
target of the editor is C and C++ code but Pascal and Clipper are supported
too. Currently I'm trying to make it more general and be useful not only
for programing.

  The editor was designed to be very similar to the DOS standard editors for
C, especially to Borland's IDE editor. The editor supports a lot of
WordStar style commands plus some CUA commands, so if you have used any
editor that uses these kinds of commands you'll find my editor very
familiar. On the other hand if you have never used a DOS editor,
especially if you use VI on UNIX machines you'll feel lost. You can
configure the keyboard.  *Note How to configure the keyboard::.


File: editor.inf,  Node: About the Author,  Prev: What is SETs Editor?,  Up: Introduction

1.3 About the Author
====================

0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
0FЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ

The editor was created by Salvador Eduardo Tropea with some code
contributed by Robert H”hne

     E-Mail: SALVADOR EDUARDO TROPEA
     <salvador@inti.gov.ar>
     
     Telephone: (+5411) 4759-0013
     Postal Address:
     Salvador E. Tropea
     CurapaligЃe 2124
     (1678) Caseros - 3 de Febrero
     Prov: Buenos Aires
     Argentina

0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
0FЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ


File: editor.inf,  Node: Available commands and keys assignments,  Next: Keyboard configuration,  Prev: Introduction,  Up: Top

2 Available commands and keys assignments
*****************************************

  In this section I will explain the features of the editor and the default
configuration for the keyboard. If you want to change some assignment of a
key consult "configure the keyboard".  *Note How to configure the
keyboard::.

  Read the conventions topic first to understand my way of indicating
keystrokes.

  In the description of each command I'll include the internal name used by
the editor because this name is needed to configure the keyboard.

* Menu:

* Conventions::
* Cursor movement::
* Insert and Delete::
* Blocks::
* Miscellaneous keyboard commands::


File: editor.inf,  Node: Conventions,  Next: Cursor movement,  Prev: Available commands and keys assignments,  Up: Available commands and keys assignments

2.1 Conventions
===============

  I'll use some conventions when talking about the keystrokes needed to
trigger some command. So here is what I use:

  The key named <Ctrl> or Control is represented as `^'; this key doesn't
have any effect used alone inside of the editor so the `^' symbol will be
used only in conjunction with the name of some key indicating that you
must press the two keys at the same time. For example, `^A' is <Ctrl> and
<A> at the same time.  When I say "at the same time" that means: press
`<Ctrl>', hold it, and press the other key; that's the reason to put <A>
after <Ctrl>.

  To indicate a sequence of keystrokes I'll use a dash to separate the keys.
For example, `^K-B' is <Ctrl> and <K> at the same time, and then press
<B>, of course release `^K' first.

  To indicate keys pressed at the same time other than `^x' I'll use a plus.
For example, `Shift+^Insert' is the three keys at the same time!

  I don't think that you are stupid; the editor is written for programmers,
but I wanted to make that clear to avoid problems ;-).


File: editor.inf,  Node: Cursor movement,  Next: Insert and Delete,  Prev: Conventions,  Up: Available commands and keys assignments

2.2 Cursor movement
===================

   * Character left
     - Command: cmcCharLeft
        - Key: Left arrow
        - Alternate: ^S

   * Character right
     - Command: cmcCharRight
        - Key: Right arrow
        - Alternate: ^D

   * Word left
     - Command: cmcWordLeft
        - Key: ^Left arrow
        - Alternate: ^A

   * Word right
     - Command: cmcWordRight
        - Key: ^Right arrow
        - Alternate: ^F

   * End of the word
     - Command: cmcGoEndOfWord
        - Key:
        - Alternate:

   * Line up
     - Command: cmcLineUp
        - Key: Up arrow
        - Alternate: ^E

   * Line down
     - Command: cmcLineDown
        - Key: Down arrow
        - Alternate: ^X

   * Scroll the screen one line up
     - Command: cmcScrollUp
        - Key: ^W
        - Alternate:

   * Scroll the screen one line down
     - Command: cmcScrollDown
        - Key: ^Z
        - Alternate:

   * Page up
     - Command: cmcPageUp
        - Key: PgUp
        - Alternate: ^R

   * Page down
     - Command: cmcPageDown
        - Key: PgDn
        - Alternate: ^C

   * Beginning of line
     - Command: cmcLineStart
        - Key: Home
        - Alternate: ^Q-S

   * End of line
     - Command: cmcLineEnd
        - Key: End
        - Alternate: ^Q-D

   * Top of window
     - Command: cmcFirstLineInScreen
        - Key: ^Q-E
        - Alternate: ^Home

   * Bottom of window
     - Command: cmcLastLineInScreen
        - Key: ^Q-X
        - Alternate: ^End

   * Top of file
     - Command: cmcTextStart
        - Key: ^Q-R
        - Alternate: ^PgUp

   * Bottom of file
     - Command: cmcTextEnd
        - Key: ^Q-C
        - Alternate: ^PgDn



File: editor.inf,  Node: Insert and Delete,  Next: Blocks,  Prev: Cursor movement,  Up: Available commands and keys assignments

2.3 Insert and Delete
=====================

   * Delete the character under cursor
     - Command: cmcDelChar
        - Key: Del
        - Alternate: ^G

   * Delete character to left
     - Command: cmcBackSpace
        - Key: Backspace
        - Alternate: ^H

   * Delete line
     - Command: cmcDelLine
        - Key: ^Y
        - Alternate:

   * Delete to end of line
     - Command: cmcDelEnd
        - Key: ^Q-Y
        - Alternate: Shift+^Y

   * Delete to start of line
     - Command: cmcDelStart
        - Key: ^Q-H
        - Alternate:

   * Delete word at left
     - Command: cmcDelWord
        - Key: ^T
        - Alternate:

   * Delete word at right
     - Command: cmcDelPrevWord
        - Key: ^Backspace
        - Alternate:

   * Insert line
     - Command: cmcNewLine
        - Key: Enter
        - Alternate: ^N

   * Insert mode on/off
     - Command: cmcInsMode
        - Key: Ins
        - Alternate: ^V


  When you are in insert mode all the typed characters are inserted in the
text, but when the insert mode is off the typed characters replace the old
text. The editor starts with insert mode on. You can quickly know the mode
by the cursor shape. When the insert mode is on, the cursor is only a
line, but when it is off, the cursor is block shaped.


File: editor.inf,  Node: Blocks,  Next: Miscellaneous keyboard commands,  Prev: Insert and Delete,  Up: Available commands and keys assignments

2.4 Blocks
==========

  A block is a selected portion of the text. You can copy, delete, `etc.'
blocks of text. The associated commands are:

   * Move to beginning of block
     - Command: cmcGoBeginBlock
        - Key: ^Q-B
        - Alternate:

   * Move to end of block
     - Command: cmcGoEndBlock
        - Key: ^Q-K
        - Alternate:

   * Set beginning of block
     - Command: cmcStartSelect
        - Key: ^K-B
        - Alternate:

   * Set end of block
     - Command: cmcEndSelect
        - Key: ^K-K
        - Alternate:

   * Hide/Show block
     - Command: cmcHideSelect
        - Key: ^K-H
        - Alternate:

   * Mark line
     - Command: cmcMarkLine
        - Key: ^K-L
        - Alternate:

   * Mark word
     - Command: cmcMarkWord
        - Key: ^K-T
        - Alternate:

   * Delete block and copy it to the Clipboard
     - Command: cmcCut
        - Key: ^K-Y
        - Alternate: Shift+Del

   * Copy the selected block
     - Command: cmcCopyBlock
        - Key: ^K-C
        - Alternate:

   * Move block
     - Command: cmcMoveBlock
        - Key: ^K+V
        - Alternate:

   * Copy to Clipboard
     - Command: cmcCopy
        - Key: ^Ins
        - Alternate:

   * Delete block
     - Command: cmcClear
        - Key: ^Del
        - Alternate:

   * Paste from Clipboard
     - Command: cmcPaste
        - Key: Shift+Ins
        - Alternate:

   * Read block from disk
     - Command: cmcReadBlock
        - Key: ^K-R
        - Alternate: Shift+^R

   * Write block to disk
     - Command: cmcWriteBlock
        - Key: ^K-W
        - Alternate: Shift+^W

   * Replace the block by the Clipboard block
     - Command: cmcReplaceSelect
        - Key: Shift+^Ins
        - Alternate:

   * Convert to Uppercase
     - Command: cmcToUpper
        - Key: ^K-M
        - Alternate:

   * Convert to Lowercase
     - Command: cmcToLower
        - Key: ^K-O
        - Alternate:

   * Invert case
     - Command: cmcInvertCase
        - Key: none
        - Alternate:

   * Alternate case
     - Command: cmcAltCase
        - Key: none
        - Alternate:

   * Report the length of the block
     - Command: cmcSelLength
        - Key: ^Q-L
        - Alternate:


* Menu:

* Block modes::
* Selecting with the mouse or Shift::
* Indentation::
* Rectangular Blocks::


File: editor.inf,  Node: Block modes,  Next: Selecting with the mouse or Shift,  Prev: Blocks,  Up: Blocks

2.4.1 Block modes
-----------------

  There are two block modes. One is the mode that the old editor of RHIDE
used. This mode is used in CUA programs. The other is called Persistent
Blocks.

  In the normal mode each time you select a block and then insert anything
in it (with `cmcPaste' or by typing anything) the selected block is deleted
and is replaced by the new text.

  In persistent blocks the selection is not replaced and is not lost when
you move the cursor. From this comes the name "Persistent." In this mode
you can use `cmcMoveBlock' and `cmcCopyBlock' without using the Clipboard.
In addition you can apply indentations to the block (*Note Indentation::),
search only inside it, `etc.' That's what makes this mode much more
powerful than the former. If you really like to replace the selected text
by the selection of the Clipboard, that's the default behaviour of the
first mode. You can use the `cmcReplaceSelect' command to achieve the same
in the Persistent Blocks mode.


File: editor.inf,  Node: Selecting with the mouse or Shift,  Next: Indentation,  Prev: Block modes,  Up: Blocks

2.4.2 Selecting with the mouse or Shift
---------------------------------------

  The described commands for selecting a block, `cmcStartSelect' and
`cmcEndSelect', are good but not so quick. There are other ways to do this.

* Menu:

* Using the mouse::
* Using the Shift key::


File: editor.inf,  Node: Using the mouse,  Next: Using the Shift key,  Prev: Selecting with the mouse or Shift,  Up: Selecting with the mouse or Shift

2.4.2.1 Using the mouse
.......................

  Using the mouse you need only point to the start place, hold the left
button pressed and move the mouse to the end point of your block.

  To select a word with the mouse just double click on it.


File: editor.inf,  Node: Using the Shift key,  Prev: Using the mouse,  Up: Selecting with the mouse or Shift

2.4.2.2 Using the Shift key
...........................

  Using the <Shift> key you only need to move the cursor to the start point,
hold `<Shift>' pressed and move the cursor to the end point with any of the
available cursor commands. *Note Cursor movement::.


File: editor.inf,  Node: Indentation,  Next: Rectangular Blocks,  Prev: Selecting with the mouse or Shift,  Up: Blocks

2.4.3 Indentation
-----------------

  You can indent or unindent a block of text using various commands, but you
must keep in mind that for now the editor is limited in the following:
*Note Real Tabs:: If you are using tabs to indent your text, don't mix the
tabs with spaces and, if you are using spaces to indent, don't mix them
with real tabs.

   * Indent block one position adding a space
     - Command: cmcIndentBlkOne
        - Key: ^K-I
        - Alternate: Shift+^I

   * Unindent block one character - not an x position
     - Command: cmcUnIndentBlkOne
        - Key: ^K-U
        - Alternate: Shift+^U

   * Indent block
     - Command: cmcIndentBlk
        - Key: ^K-Tab
        - Alternate:

   * Unindent block
     - Command: cmcUnIndentBlk
        - Key: ^K-Shift+Tab
        - Alternate:


`cmcUnIndentBlkOne' unindents deleting one char at the start of the line so
if the line is indented with tabs the line will retract one tab.

`cmcIndentBlk' acts according to the mode. If you are using tabs, the
editor will put one tab beginning each line. If you aren't using tabs the
editor will operate the Tab command on the first line and then will use
this amount of indentation on the entire block. *Note Real Tabs::.

`cmcUnIndentBlk' acts according to the mode too. *Note Real Tabs:: mode.
This is just like `cmcUnIndentBlkOne' deleting one tab but if you don't
use tabs the editor uses Backspace on the first used column of the first
line of the block and unindents by the resulting amount all the block.

The following commands aren't applied to the whole block, they apply only
to the line where the cursor is positioned.

   * Smart Indent block
     - Command: cmcSmartIndent
        - Key: ^Tab

   * Smart Unindent block
     - Command: cmcSmartUnIndent
        - Key: Shift+^Tab


`cmcSmartIndent' and `cmcSmartUnIndent' indents taking as reference the {
} pair where the cursor is, for example:

       {
     line1
          line2
        line3
       }

After indenting line1 with `cmcSmartIndent' and line2 with
`cmcSmartUnIndent' you get:

       {
        line1
        line2
        line3
       }

The indentation is made with spaces and you must put the cursor in the
first letter of the line, the l in this example.


File: editor.inf,  Node: Rectangular Blocks,  Prev: Indentation,  Up: Blocks

2.4.4 Rectangular Blocks
------------------------

  The editor includes a mode where you can select a rectangular portion of
the text and copy, cut, clear, paste, move, `etc.' this region.  This tool
is very useful for modifications on columns.

  Attention! The selected area is based on the X,Y coordinates. For this
reason if you insert lines before the bottom of the rectangle the area
won't be moved. I don't plan to move the area by now because that takes
some CPU and I think that this selection is made just before using it. So
don't report that like a bug. That is the way it works!

   * Set beginning of block
     - Command: cmcSelRectStart
        - Key: ^K-Shift+B

   * Set end of block
     - Command: cmcSelRectEnd
        - Key: ^K-Shift+K

   * Hide/Show block
     - Command: cmcSelRectHide
        - Key: ^K-Shift+H

   * Delete block and copy it to an special Clipboard
     - Command: cmcSelRectCut
        - Key: ^K-ShiftT

   * Move block
     - Command: cmcSelRectMove
        - Key: ^K+Shift+V

   * Copy to special Clipboard
     - Command: cmcSelRectCopy
        - Key: ^K-Shift+C

   * Delete block
     - Command: cmcSelRectDel
        - Key: ^K-Shift+L

   * Paste from special Clipboard
     - Command: cmcSelRectPaste
        - Key: ^K-Shift+P

   * Convert to uppercase
     - Command: cmcSelRectToUpper
        - Key:

   * Convert to lowercase
     - Command: cmcSelRectToLower
        - Key:



File: editor.inf,  Node: Miscellaneous keyboard commands,  Prev: Blocks,  Up: Available commands and keys assignments

2.5 Miscellaneous keyboard commands
===================================

   * Autoindent mode on/off
     - Command: cmcIndentMode
        - Key: ^O

   * Find place marker
     - Command: cmcGotoMarkn
        - Key: ^Q n*

   * Set marker
     - Command: cmcPutMarkn
        - Key: ^K n*

   * Search the open curly bracket where the cursor is
     - Command: cmcSearchStart
        - Key: ^[

   * Search the close curly bracket where the cursor is
     - Command: cmcSearchEnd
        - Key: ^]

   * Search the ( where the cursor is
     - Command: cmcSearchOpPar
        - Key: Shift+^9

   * Search the ) where the cursor is
     - Command: cmcSearchClPar
        - Key: Shift+^0

   * Search the [ where the cursor is
     - Command: cmcSearchOpCor
        - Key: Shift+^[

   * Search the ] where the cursor is
     - Command: cmcSearchClCor
        - Key: Shift+^]

   * Search the complementary pair
     - Command: cmcSearchComplement
        - Key: ^Q ESC

   * Undo
     - Command: cmcUndo
        - Key: Alt+Backspace

   * PMacro's Trigger
     - Command: cmcExpandCode
        - Key: ^Space

   * Goto Line
     - Command: cmcGotoEditorLine
        - Key: ^J

   * Set the options of the current window (Not in RHIDE)
     - Command: cmcSetLocalOptions
        - Key: Alt+L

   * Set the default options (Not in RHIDE)
     - Command: cmcSetGlobalOptions
        - Key: Alt+G

   * Convert all tabs in spaces
     - Command: cmcExpandAllTabs
        - Key: From menu

   * Compact the text using tabs
     - Command: cmcCompactBuffer
        - Key: From menu

   * Start recording a macro
     - Command: cmcRecordMacro
        - Key: Shift+F10

   * Stop recording a macro
     - Command: cmcStopMacro
        - Key: Alt+F10

   * Play a macro
     - Command: cmcPlayMacro
        - Key: ^F10



File: editor.inf,  Node: Keyboard configuration,  Next: Pull-down menues,  Prev: Available commands and keys assignments,  Up: Top

3 Keyboard configuration
************************

  The editor can be configured to trigger one or more commands pressing one
key or any arbitrary sequence of keys. Unlike old versions now the
sequence of keys isn't limited.  Additionally you no longer need to
configure the editor for non-US keyboards.

  If you used an old version of the editor you'll note that now the keyboard
configuration is much more easy and much more powerful.

* Menu:

* How to configure the keyboard::
* Alt key configuration::
* Restoring the default keyboard assignments::
* Consulting scan codes::


File: editor.inf,  Node: How to configure the keyboard,  Next: Alt key configuration,  Prev: Keyboard configuration,  Up: Keyboard configuration

3.1 How to configure the keyboard
=================================

  In the editor these options are located under the menu option called
Tool&Ops, submenu Options, submenu Keyboard, submenu Key assignment; yes
is a little deep in the menu.

  After selecting this option you'll get a window with the keyboard
assignments. This window shows entries of the type `Key sequence ->
Commands sequence'. You can delete an assignment just selecting it and
choosing the `Delete' button.

  The list is sorted by a internal criteria. The keys with <Shift> have an
`S' before, for <Ctrl> you'll see a `C' and for <Alt> an `A'. The editor
can distinguish the left and right <Alt> keys; if you enable it the right
<Alt> will be represented by an `a'. *Note Alt key configuration::.

  To add a new assignment press the `Add' button. A window called `Sequence
of keys' will appear. This window is used to choose the sequence of keys
that will trigger an action in the editor. The sequence can be as large as
you want, so if you want to assign a sequence like this:
`^A-Shift+^Insert-Alt+Z' you can, I doubt you really want to use such a
complex combination but the editor is flexible enough.

  To add a new key to the sequence use the `Add' button, to delete a key use
the `Delete' button. The `Add' button ever adds a key at the end of the
list; to insert a key in the sequence use the `Insert' button button, it
will insert the key before the selected key. Finally select if you want to
assign a sequence of commands or a sLisp macro to this key sequence. *Note
sLisp macros::.

* Menu:

* Assigning a sequence of commands::
* Assigning a sLisp macro::


File: editor.inf,  Node: Assigning a sequence of commands,  Next: Assigning a sLisp macro,  Prev: How to configure the keyboard,  Up: How to configure the keyboard

3.1.1 Assigning a sequence of commands
--------------------------------------

  A window called `Commands' will appear. The mechanism to add, insert and
delete commands is the same used in for a keyboard sequence. This time
when you add or insert a new command to the sequence a window offering all
the available commands will pop-up.  The meaning of each command can be
found in the indeces of this help.

  To make a selection with the commands, like when holding <Shift>, you must
use the `SelectOn' and `SelectOff' commands. As an example you can see the
assignments for the `Shift+Left' or `Shift+Right' keys.


File: editor.inf,  Node: Assigning a sLisp macro,  Prev: Assigning a sequence of commands,  Up: How to configure the keyboard

3.1.2 Assigning a sLisp macro
-----------------------------

  A window called `Macros' will appear. This window shows all the macros
defined in the `macros.slp' file. *Note sLisp macros::.

  The main advantage of using macros instead of command sequence is that
macros can insert text in your code.


File: editor.inf,  Node: Alt key configuration,  Next: Restoring the default keyboard assignments,  Prev: How to configure the keyboard,  Up: Keyboard configuration

3.2 Alt key configuration
=========================

  The editor can distinguish the left and right <Alt> keys. As old versions
didn't allowed that and as different users use different <Alt> keys the
editor doesn't make any difference as default.

  The `Setup Alt keys' menu option (under Tool&Ops | Options | Keyboard)
allows to enable it. Three options are offered:

   * Left Alt
     - Meaning: The menues are tiggered by the left Alt and you can use
     the right Alt for commands

   * Right Alt
     - Meaning: Right Alt is used for menues, in fact both are inverted

   * Both Alt
     - Meaning: Both keys can be used for menues



File: editor.inf,  Node: Restoring the default keyboard assignments,  Next: Consulting scan codes,  Prev: Alt key configuration,  Up: Keyboard configuration

3.3 Restoring the default keyboard assignments
==============================================

  If you need to restore the original keyboard assignment because you did
something very wrong you can use this option for that. The option is
located under Tool&Ops | Options | Keyboard.


File: editor.inf,  Node: Consulting scan codes,  Prev: Restoring the default keyboard assignments,  Up: Keyboard configuration

3.4 Consulting scan codes
=========================

  If you need to know the scan code of a key for your program you don't need
to use a table or another program. The editor have an option for it under
Tool&Ops | Options | Keyboard.


File: editor.inf,  Node: Pull-down menues,  Next: Editing Modes,  Prev: Keyboard configuration,  Up: Top

4 Pull-down menues
******************

The menues are configurable; for this reason the following structure is
just one of possible arrangements.

If you need or want to configure the keyboard look in the `menubind.smn'
file, the format is self explanatory and the editor supports syntax
highlight for these files.

* Menu:

* File::
* Edit::
* Search::
* Macro::
* Rectangle::
* Windows::
* Tool&Ops::
* Project::
* Help::


File: editor.inf,  Node: File,  Next: Edit,  Prev: Pull-down menues,  Up: Pull-down menues

4.1 File
========

This menu contains the files operations (save, load, print, `etc.') and
the program exit functions.

* Menu:

* Open::
* New::
* Open Read-only copy::
* Save::
* Save as::
* Save as UNIX::
* Save with same time::
* Print::
* Print Setup::
* Shell::
* Quit::
* Exit::


File: editor.inf,  Node: Open,  Next: New,  Prev: File,  Up: File

4.1.1 Open
----------

This option brings the file open dialog (*Note File Open::). From this
dialog you can select a file to load and edit.

Choose the Open button or select a file with `<Enter>' to open the file.
Use `<Esc>' to abort.

If the file is read-only a dialog will ask you if you want to make the file
writable, in this case the editor will try to change the file attributes.
Not always is possible to change these attributes, as an example, the CDs
are read-only and you can't change it.

Name of the command: cmeOpen.
Assigned key: `F3'


File: editor.inf,  Node: New,  Next: Open Read-only copy,  Prev: Open,  Up: File

4.1.2 New
---------

Use this option to create a new and empty editor window. The window have
`Untitled' as title.

An alternative way to do it is just using the `Open' option and give a new
name instead of selecting an existing file. *Note Open::. The advantage of
this methode is that the new window have a right title instead of
`Untitled'.

Name of the command: cmeNew.


File: editor.inf,  Node: Open Read-only copy,  Next: Save,  Prev: New,  Up: File

4.1.3 Open Read-only copy
-------------------------

Use this option to open a copy of the file you are editing in another
window.

Be careful, the new copy is taked from disk so could be unsychronized. The
copy will automatically become read only so you won't be able to modify it
and save over the first copy.

For more information: *Note Editor General::.

Name of the command: cmeOpenROCopy.


File: editor.inf,  Node: Save,  Next: Save as,  Prev: Open Read-only copy,  Up: File

4.1.4 Save
----------

This option saves the contents of the current window. Only the contents of
this window are saved; not the rest. Additionally it only saves if the
window was modified.

If the window have `Untitled' as title this command acts like *Note Save
as::.

Name of the command: cmcSave.
Assigned key: `F2'


File: editor.inf,  Node: Save as,  Next: Save as UNIX,  Prev: Save,  Up: File

4.1.5 Save as
-------------

This option allows to save the contents of the current window specifying a
new name for the file. For this purpose the file open dialog is used
(*Note File Open::).

If the file allready exists a dialog will pop-up asking for overwrite
confirmation.

The title of the window is changed to reflect the new file name.

Name of the command: cmcSaveAs.


File: editor.inf,  Node: Save as UNIX,  Next: Save with same time,  Prev: Save as,  Up: File

4.1.6 Save as UNIX
------------------

This option is very similar to the `Save as' option (*Note Save as::). The
only difference is that the editor will use the ASCII 10 as line end
instead of the 13,10 DOS sequence. That's very usefull when you need to
compile the file under UNIX or you just want to save some bytes on your
disk.

Additionally there are an option to save UNIX files as UNIX files without
converting it to DOS style. *Note Tool&Ops|Options|Editor General: Editor
General.

Name of the command: cmcSaveAsUNIX.


File: editor.inf,  Node: Save with same time,  Next: Print,  Prev: Save as UNIX,  Up: File

4.1.7 Save with same time
-------------------------

This option is very similar to the `Save' option (*Note Save::). The only
difference is that the editor will let the creation time unmodified. This
option is very usefull to modify header files avoiding the recompilation
of the whole project. A common case is when you only add constants to a
header that is included by various files but only one will use the new
constants.

Name of the command: cmcSaveSameTime.


File: editor.inf,  Node: Print,  Next: Print Setup,  Prev: Save with same time,  Up: File

4.1.8 Print
-----------

This option prints the current editor window. Don't use this option without
configuring the printer module. *Note Print Setup::.

This option was designed to print source files, to print plain text files
or avoid all the formating features just select the portion of text to
print and save the block (`^K-W') to a file with the name of the device
where your printer is connected. As an example to print in the DOS LPT 1
device just write the block to the `lpt1' file.

The editor will report the number of lines processed and printed in the
message window.

To learn more about the message window *Note Message Window::.

Name of the command: cmePrintEditor.


File: editor.inf,  Node: Print Setup,  Next: Shell,  Prev: Print,  Up: File

4.1.9 Print Setup
-----------------

This option brings a dialog to configure the printing module. After
configuring it you can print using the `Print' option. *Note Print::.  If
you want to print a plain text (without formating) consult the `Print'
option too.

The dialog asks for the following parameters:

   * Total lines per page: The total number of lines that fits in one page
     including the footer and header lines.

   * Columns w/o margin: The number of colums that fits in the page without
     counting the desired margin.

   * Left margin: The number of columns left blank at the left side of the
     page.

   * Print line numbers: Select this option to get the line numbers printed

   * Time format: The time format specified in the C style. (*Note Time
     and date modifiers formats::).

   * Date format: The date format specified in the C style. (*Note Time
     and date modifiers formats::).

   * Title: used in the header.

   * Author: used in the header.

   * Output file: Specify the printer device here. For example: the DOS
     LPT 1 is the lpt1 file.

   * Printer initialization: The sequence of character used to initialize
     the printer. Normally it includes a reset and a font selection.
     Specify the values separated by commas.

   * Before heading: Setting to send before the header.

   * After heading: Setting to send after the header.

   * Before footer: Setting to send before the footer.

   * After footer: Setting to send after the footer.

Use the `Ok' button to confirm or the `Cancel' button to reject.

The `Epson' button fills the values with the default settings for Epson
printers (ESCP2 language). The `HP' button fills the values with the
default settings for Hewlett Packard ink-jet printers.

The printer module was designed by me some years ago when I needed to
present a program in my University (Universidad Tecnologica Nacional) and
I wanted to format the source code adding a header, footer, lines number,
page number, date/time of the printing, project and author. So that's what
the routines does. I know they are limited but they generate a very good
listing, much better than just printing the text wothout any formating.

Name of the command: cmeSetUpPrinter.


File: editor.inf,  Node: Shell,  Next: Quit,  Prev: Print Setup,  Up: File

4.1.10 Shell
------------

Calls to the default commands interpreter indicated by the `COMSPEC'
enviroment variable. I guess you know that typing exit you'll go back to
the editor.

Name of the command: cmeDosShell.


File: editor.inf,  Node: Quit,  Next: Exit,  Prev: Shell,  Up: File

4.1.11 Quit
-----------

This option exits the editor deleting all the back-up, desktop and project
files located in the current directory. That's usefull if you want to let
the directory clean.

When you use this option a dialog will appear asking if for confirmation,
you can avoid this dialog in the future operations using the "don't show
again" option.

Name of the command: cmeQuitDelete.
Assigned key: `Alt+Q'


File: editor.inf,  Node: Exit,  Prev: Quit,  Up: File

4.1.12 Exit
-----------

This option just exits the program. The editor asks for saving if any of
the files under edition were modified but not saved. All the settings are
stored in the desktop file automatically.

Name of the command: cmeQuit.
Assigned key: `Alt+X'


File: editor.inf,  Node: Edit,  Next: Search,  Prev: File,  Up: Pull-down menues

4.2 Edit
========

This menu contains all the edition operations that have a menu shortcut.

* Menu:

* Undo::
* Redo::
* Cut::
* Copy::
* Paste::
* Show clipboard::
* Clear::
* Set Local::
* Set Global::
* Expand all tabs::
* Compact text::
* Copy to Windows Clipoard::
* Paste from Windows Clipboard::
* Push cursor position::
* Pop cursor position::
* Case (Menu)::


File: editor.inf,  Node: Undo,  Next: Redo,  Prev: Edit,  Up: Edit

4.2.1 Undo
----------

This option reverts the last edit operation. Upto 32 operations can be
reverted.

Name of the command: cmcUndo.
Assigned key: `Alt+BackSpace'


File: editor.inf,  Node: Redo,  Next: Cut,  Prev: Undo,  Up: Edit

4.2.2 Redo
----------

This option recreats the last operation that was reverted using the `Undo'
option. *Note Undo::.

Name of the command: cmcRedo.


File: editor.inf,  Node: Cut,  Next: Copy,  Prev: Redo,  Up: Edit

4.2.3 Cut
---------

The selected text is copied to the clipboard and deleted from the text.
*Note Clipboard::.

Name of the command: cmcCut.
Assigned key: `Shift+Del'


File: editor.inf,  Node: Copy,  Next: Paste,  Prev: Cut,  Up: Edit

4.2.4 Copy
----------

The selected text is copied to the clipboard. *Note Clipboard::.

Name of the command: cmcCopy.
Assigned key: `^Ins'


File: editor.inf,  Node: Paste,  Next: Show clipboard,  Prev: Copy,  Up: Edit

4.2.5 Paste
-----------

The text that's currently selected in the clipboard is inserted at the
cursor position. *Note Clipboard::.

Name of the command: cmcPaste.
Assigned key: `Shift+Ins'


File: editor.inf,  Node: Show clipboard,  Next: Clear,  Prev: Paste,  Up: Edit

4.2.6 Show clipboard
--------------------

This option shows the clipboard window. *Note Clipboard::.

Name of the command: cmeShowClip.


File: editor.inf,  Node: Clear,  Next: Set Local,  Prev: Show clipboard,  Up: Edit

4.2.7 Clear
-----------

Deletes the selected text. It isn't copied to the clipboard.

Name of the command: cmcClear.
Assigned key: `^Del'


File: editor.inf,  Node: Set Local,  Next: Set Global,  Prev: Clear,  Up: Edit

4.2.8 Set Local
---------------

This option pop-ups the local configuration dialog. All the values selected
in this dialog are valid only for the current editor window.

The first group of options are related to the editing modes.  *Note
Editing Modes::.

The syntax highlight group of options allows to choose the type of
highlight.  *Note Syntax Highlight::.

Additionally the window allows to indicate the tab size and the column
where the wrap cuts the lines.

Name of the command: cmcSetLocalOptions.
Assigned key: `Alt+L'


File: editor.inf,  Node: Set Global,  Next: Expand all tabs,  Prev: Set Local,  Up: Edit

4.2.9 Set Global
----------------

This option pop-ups the global configuration dialog. All the values
selected in this dialog are used as default values. If you exit the dialog
using the `Ok' button these values aren't applied to any of the editor
windows, they just act as default values that are copied to the new opened
and created files. If you exit the dialog using the `To all' button these
values are applied to all the editor windows. To set the options of just
one window *Note Set Local::.

The options are related to the editing modes. *Note Editing Modes::.

Additionally the window allows to indicate the tab size and the column
where the wrap cuts the lines.

Name of the command: cmcSetGlobalOptions.
Assigned key: `Alt+G'


File: editor.inf,  Node: Expand all tabs,  Next: Compact text,  Prev: Set Global,  Up: Edit

4.2.10 Expand all tabs
----------------------

This option converts all the tabs in spaces. *Note Real Tabs::.

The tabs are expanded to the current tab size, check it before using this
option.

Name of the command: cmcExpandAllTabs.


File: editor.inf,  Node: Compact text,  Next: Copy to Windows Clipoard,  Prev: Expand all tabs,  Up: Edit

4.2.11 Compact text
-------------------

This option converts all the possible spaces in tabs. *Note Real Tabs::.

Be careful, if the tabs size is too small the editor will generate tons of
tabs, even in places where you don't want a tab.

Name of the command: cmcCompactBuffer.


File: editor.inf,  Node: Copy to Windows Clipoard,  Next: Paste from Windows Clipboard,  Prev: Compact text,  Up: Edit

4.2.12 Copy to Windows Clipoard
-------------------------------

Copies the selected text to the Windows clipboard. Of course you must be
running under Windows ;-)). Don't trust too much in this feature, Windows
have bugs in the WinOldAp module (used to make it).

There is a command called `cmcCutClipWin' you can use to cut a portion of
text copying it to Windows clipboard.

Name of the command: cmcCopyClipWin.

Name of the command: cmcCutClipWin.


File: editor.inf,  Node: Paste from Windows Clipboard,  Next: Push cursor position,  Prev: Copy to Windows Clipoard,  Up: Edit

4.2.13 Paste from Windows Clipboard
-----------------------------------

Pastes the Windows clipboard content into the cursor position. Of course
you must be running under Windows and have some text in the clipboard.
Don't trust too much in this feature, Windows have bugs in the WinOldAp
module (used to make it).

Name of the command: cmcPasteClipWin.


File: editor.inf,  Node: Push cursor position,  Next: Pop cursor position,  Prev: Paste from Windows Clipboard,  Up: Edit

4.2.14 Push cursor position
---------------------------

It stores the cursor position (x,y) in a stack. You can restore it later
using *Note Pop cursor position::. The stack can hold upto eleven nested
positions; if you try to push a 12th value the oldest is discarded.

Name of the command: cmcPushCursorPos.


File: editor.inf,  Node: Pop cursor position,  Next: Case (Menu),  Prev: Push cursor position,  Up: Edit

4.2.15 Pop cursor position
--------------------------

It restores the cursor position (x,y) from a stack. You can store the
position using *Note Push cursor position::. The stack can hold upto eleven
nested positions; if you try to push a 12th value the oldest is discarded.

Name of the command: cmcPopCursorPos.


File: editor.inf,  Node: Case (Menu),  Prev: Pop cursor position,  Up: Edit

4.2.16 Case (Menu)
------------------

This submenu contains operations to convert blocks or single characters to
uppercase or lowercase and similar operations

* Menu:

* Block to upper::
* Block to lower::
* Character toggle::
* Block invert::
* Block alternate::


File: editor.inf,  Node: Block to upper,  Next: Block to lower,  Prev: Case (Menu),  Up: Case (Menu)

4.2.16.1 Block to upper
.......................

Converts all the selected characters to uppercase.

Name of the command: cmcToUpper.


File: editor.inf,  Node: Block to lower,  Next: Character toggle,  Prev: Block to upper,  Up: Case (Menu)

4.2.16.2 Block to lower
.......................

Converts all the selected characters to lowercase.

Name of the command: cmcToLower.


File: editor.inf,  Node: Character toggle,  Next: Block invert,  Prev: Block to lower,  Up: Case (Menu)

4.2.16.3 Character toggle
.........................

Converts the character under the cursor to lowercase is it was uppercase
and `vice versa'.

Name of the command: cmcToggleCharCase.


File: editor.inf,  Node: Block invert,  Next: Block alternate,  Prev: Character toggle,  Up: Case (Menu)

4.2.16.4 Block invert
.....................

Converts all the selected uppercase characters to lowercase and viceversa.

Name of the command: cmcInvertCase.


File: editor.inf,  Node: Block alternate,  Prev: Block invert,  Up: Case (Menu)

4.2.16.5 Block alternate
........................

It will convert the first character to uppercase, the second to lowercase
and so on. If you want the reverse you can use the command to invert the
block.  *Note Block invert::.

Name of the command: cmcAltCase.


File: editor.inf,  Node: Search,  Next: Macro,  Prev: Edit,  Up: Pull-down menues

4.3 Search
==========

This menu contains the search and replace commands of the editor.

* Menu:

* Find::
* Replace::
* Search again::
* Name current function::
* Jump to function::
* Jump to prototype::
* Go to line::


File: editor.inf,  Node: Find,  Next: Replace,  Prev: Search,  Up: Search

4.3.1 Find
----------

This command searchs a string in the current editor. The dialog contains
the following fields:

   * Text to find: The text you want to search.

   * Case sensitive: Use this option is the case of the text to search is
     important.

   * Whole words only: When this option is on the editor searchs for whole
     words. If not the text to search can be only part of a word.

   * Regular expressions: Use this option if the text to search is a
     regular expression. A description of the syntax used by regular
     expressions can be found in the libc. *Note Regular Expressions::.
     Three types of regular expression are supported. *Note Regular
     Expressions Options::.

   * Only inside comments: The matchs will be returned only if the first
     character is inside a comment. Any kind of comments supported by the
     syntax highlight are supported. It doesn't have any sense for plain
     text.

   * Only outside comments: The matchs will be returned only if the first
     character is outside a comment. If the previous option is also
     enabled this option takes precedence.

   * Scope - Global: The search will be done without taking in count the
     selected text.

   * Scope - Selected text: The search will be done only inside the
     selected text.

   * Origin - From cursor: The search will start from the position of the
     cursor.

   * Origin - Entire scope: The search will be start from the beginning of
     the text.

The regular expressions search is slow and this can be noticed in large
files. Don't use it if the search can be done without it. The editor will
automatically disable the regular expressions search if the `Text to find'
contains only alphanumeric characters. This can be disabled *Note Regular
Expressions Options::.

To repeat the search use the `Search again' command. *Note Search again::.

Name of the command: cmcFind.
Assigned key: `^Q-F'

* Menu:

* Regular Expressions Options::


File: editor.inf,  Node: Regular Expressions Options,  Prev: Find,  Up: Find

4.3.1.1 Regular Expressions Options
...................................

This dialog is accessed from the `RegEx Ops' button in the Find or Replace
dialogs. Here you can indicate some important options about the regular
expressions:

RegEx style:

   * Basic POSIX: old style POSIX regular expressions.

   * Extended POSIX: new style POSIX regular expressions.

   * Perl Compatible: Perl like regex, using the PCRE library.

Replace text:

   * Normal text: the match is replaced by the text in the replace text
     area.

   * Dollar tags: the text to replace is parsed searching for `$n' tags.
     These markers are replaced by the correspondent subexpression. If you
     know Perl that's just like using the $0, $1, `etc.' after a search,
     if you never used Perl and know what a subexpression means just play a
     little and you'll get the idea, just use $n where n is the desired
     subexpression.

Optimize:

   * Try to use normal search: if the editor detects that the search string
     contains plain text will use a simple search even when regular
     expressions are enabled. That's about ten times faster.

   * Ever use RegEx: the editor doesn't try to be smart and ever uses what
     you selected.

For more information about regular expressions *Note Regular Expressions::.


File: editor.inf,  Node: Replace,  Next: Search again,  Prev: Find,  Up: Search

4.3.2 Replace
-------------

This command searchs portions of text and replaces it with another text.
The options for the search are the same as in the `Find' command.  *Note
Find::. The replace options are:

   * New text: The text used to replace the matching text.

   * Prompt on replace: When this option is enabled the editor asks for
     confirmation before doing the replace.

   * Replace all: Use it to replace all the possible ocurrences.

To repeat the search use the `Search again' command. *Note Search again::.

Name of the command: cmcReplace.
Assigned key: `^Q-A'


File: editor.inf,  Node: Search again,  Next: Name current function,  Prev: Replace,  Up: Search

4.3.3 Search again
------------------

This option repeats the last search.

Name of the command: cmcSearchAgain.
Assigned key: `^L'


File: editor.inf,  Node: Name current function,  Next: Jump to function,  Prev: Search again,  Up: Search

4.3.4 Name current function
---------------------------

It shows the name of the function where the cursor is located in the status
line of the window. It have the same limitations of the `Jump to function'
option. *Note Jump to function::.

Name of the command: cmcWhichFunctionIs.
Assigned key: `'


File: editor.inf,  Node: Jump to function,  Next: Jump to prototype,  Prev: Name current function,  Up: Search

4.3.5 Jump to function
----------------------

This option pop-ups a dialog with the list of functions in your source
file. Then you can choose one to jump in there. The functions are searched
in the source file so you don't need to compile it. As the parser uses an
heuristic it can fail.

The `Browse' button sends the list of functions to the message window so
you can browse the list and visit each function. *Note Message Window::.

Currently only a few languages are supported, they are:

   * C/C++

   * Clipper 5.x

   * Syntax Highlight Files

   * Texinfo sources (chapters, sections, `etc.')

   * Assembler files (labels)

In C sources fails are common if your code have an unbalanced number of
curly brackets. Here is a piece of code that made the heuristic get lost:

     #ifndef MSI_USE_GETDELIM
        if (readPipe(textMsgPipe, id, buf, maxLen))
        {
           *buflen = strlen(buf);
     #else
        if ((bytes = readPipe(textMsgPipe, id, buf)) > 0)
        {
           *buflen = bytes - 2;
     #endif
         ....
        }

Here the editor saw two curly brackets opened and then just one closed.
To avoid it you could do it:

         ....
     #ifndef MSI_USE_GETDELIM
        }
     #else
        }
     #endif

Currently the parser tries to be smarter and takes only half of the
sequence, just like if all `#if' conditions were true. It means the parser
won't get lost with it, but very complex situations could make it fail.

Name of the command: cmcJumpToFunction.
Assigned key: `Alt+F2'


File: editor.inf,  Node: Jump to prototype,  Next: Go to line,  Prev: Jump to function,  Up: Search

4.3.6 Jump to prototype
-----------------------

This option pop-ups a dialog with the list of C function prototypes in your
source file. Then you can choose one to jump in there. The prototypes are
searched in the source file so you don't need to compile it. As the parser
uses an heuristic it can fail, specially if your code have an unbalanced
number of curly brackets.

Name of the command: cmcJumpToPrototype.


File: editor.inf,  Node: Go to line,  Prev: Jump to prototype,  Up: Search

4.3.7 Go to line
----------------

Allows you to indicate to what line you want to jump.

Name of the command: cmcGotoEditorLine.
Assigned key: `^J'


File: editor.inf,  Node: Macro,  Next: Rectangle,  Prev: Search,  Up: Pull-down menues

4.4 Macro
=========

This submenu have the options to record and replay macros.

* Menu:

* Record (Macro)::
* Stop (Macro)::
* Play (Macro)::
* Choose (Macro)::
* Repeat (Macro)::
* Generate Code::
* Run selected code::
* Enter code to run::
* Pseudo Macro (menu)::


File: editor.inf,  Node: Record (Macro),  Next: Stop (Macro),  Prev: Macro,  Up: Macro

4.4.1 Record (Macro)
--------------------

Starts recording all the operations that you make in the current editor
window.

Name of the command: cmcRecordMacro.
Assigned key: `Shift+F10'


File: editor.inf,  Node: Stop (Macro),  Next: Play (Macro),  Prev: Record (Macro),  Up: Macro

4.4.2 Stop (Macro)
------------------

Stops the macro recording.

Name of the command: cmcStopMacro.
Assigned key: `Alt+F10'


File: editor.inf,  Node: Play (Macro),  Next: Choose (Macro),  Prev: Stop (Macro),  Up: Macro

4.4.3 Play (Macro)
------------------

Replays the saved macro. A macro saved in one window can be used in
another.

Name of the command: cmcPlayMacro.
Assigned key: `^F10'


File: editor.inf,  Node: Choose (Macro),  Next: Repeat (Macro),  Prev: Play (Macro),  Up: Macro

4.4.4 Choose (Macro)
--------------------

This option lists all the available `sLisp macros' so you can choose one
to execute.

To learn more about these macros: *Note sLisp macros::.

Name of the command: cmcChooseMacro.


File: editor.inf,  Node: Repeat (Macro),  Next: Generate Code,  Prev: Choose (Macro),  Up: Macro

4.4.5 Repeat (Macro)
--------------------

It re-runs the last selected macro. *Note Choose (Macro)::. That's usefull
if the macro isn't assigned to a key and you need to use it various times.

To learn more about these macros: *Note sLisp macros::.

Name of the command: cmcRepeatMacro.
Assigned key: `Shift+F3'


File: editor.inf,  Node: Generate Code,  Next: Run selected code,  Prev: Repeat (Macro),  Up: Macro

4.4.6 Generate Code
-------------------

This option translates the recorded macro into an `sLisp macro'. The
generated code is inserted at the cursor position.

To learn how to record a macro: *Note Record (Macro)::.

To learn more about these macros: *Note sLisp macros::.

Name of the command: cmcGenCodeForMacro.


File: editor.inf,  Node: Run selected code,  Next: Enter code to run,  Prev: Generate Code,  Up: Macro

4.4.7 Run selected code
-----------------------

It takes the selected text and interprets it as an sLisp macro.

Name of the command: cmcRunSel_sLisp.


File: editor.inf,  Node: Enter code to run,  Next: Pseudo Macro (menu),  Prev: Run selected code,  Up: Macro

4.4.8 Enter code to run
-----------------------

It asks for a text and interprets it as an sLisp macro. The maximun length
is one kilobyte.

Name of the command: cmcRunEnter_sLisp.


File: editor.inf,  Node: Pseudo Macro (menu),  Prev: Enter code to run,  Up: Macro

4.4.9 Pseudo Macro (menu)
-------------------------

It shows a list of all the pseudo macros available for the current syntax
highlight mode. The purpose of this option is just show you what's
available, of course you can choose any from the list but that's much
slower than using them directly.

The letters enclosed in brackets are the trigger for the pseudo macro. To
learn more about pseudo macros: *Note Pseudo Macros::.

Name of the command: cmcChoosePMacrosList.


File: editor.inf,  Node: Rectangle,  Next: Windows,  Prev: Macro,  Up: Pull-down menues

4.5 Rectangle
=============

This menu contains the rectangular block operations. As they are a little
hard to type and normally this function is ignored by the users I put it in
a very visible menu.

* Menu:

* Start (Rectangle)::
* End (Rectangle)::
* Hide (Rectangle)::
* Copy (Rectangle)::
* Paste (Rectangle)::
* Cut (Rectangle)::
* Clear (Rectangle)::
* Move (Rectangle)::
* To upper (Rectangle)::
* To lower (Rectangle)::


File: editor.inf,  Node: Start (Rectangle),  Next: End (Rectangle),  Prev: Rectangle,  Up: Rectangle

4.5.1 Start (Rectangle)
-----------------------

Selects the top-left corner of the rectangular area.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectStart.
Assigned key: `^K-Shift+B'


File: editor.inf,  Node: End (Rectangle),  Next: Hide (Rectangle),  Prev: Start (Rectangle),  Up: Rectangle

4.5.2 End (Rectangle)
---------------------

Selects the bottom-right corner of the rectangular area.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectEnd.
Assigned key: `^K-Shift+K'


File: editor.inf,  Node: Hide (Rectangle),  Next: Copy (Rectangle),  Prev: End (Rectangle),  Up: Rectangle

4.5.3 Hide (Rectangle)
----------------------

Hides the rectangular selection.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectHide.
Assigned key: `^K-Shift+H'


File: editor.inf,  Node: Copy (Rectangle),  Next: Paste (Rectangle),  Prev: Hide (Rectangle),  Up: Rectangle

4.5.4 Copy (Rectangle)
----------------------

Copies the rectangular selection into the clipboard. This clipboard isn't
the same clipboard used by the normal selections and is overwritted each
time you copy to it.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectCopy.
Assigned key: `^K-Shift+C'


File: editor.inf,  Node: Paste (Rectangle),  Next: Cut (Rectangle),  Prev: Copy (Rectangle),  Up: Rectangle

4.5.5 Paste (Rectangle)
-----------------------

Inserts the contents of the rectangular clipboard at the cursor position.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectPaste.
Assigned key: `^K-Shift+P'


File: editor.inf,  Node: Cut (Rectangle),  Next: Clear (Rectangle),  Prev: Paste (Rectangle),  Up: Rectangle

4.5.6 Cut (Rectangle)
---------------------

Copies the rectangular selection into the clipboard and then deletes the
selected text.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectCut.
Assigned key: `^K-Shift+T'


File: editor.inf,  Node: Clear (Rectangle),  Next: Move (Rectangle),  Prev: Cut (Rectangle),  Up: Rectangle

4.5.7 Clear (Rectangle)
-----------------------

Deletes the selected text.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectDel.
Assigned key: `^K-Shift+L'


File: editor.inf,  Node: Move (Rectangle),  Next: To upper (Rectangle),  Prev: Clear (Rectangle),  Up: Rectangle

4.5.8 Move (Rectangle)
----------------------

Moves the selected text to the cursor's position.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectMove.
Assigned key: `^K-Shift+M'


File: editor.inf,  Node: To upper (Rectangle),  Next: To lower (Rectangle),  Prev: Move (Rectangle),  Up: Rectangle

4.5.9 To upper (Rectangle)
--------------------------

Converts all the characters inside the rectangle to uppercase. This
operation basically does a cut of the block, then process all the
characters and finally makes a paste of the modified block. As a side
effect of this operations tabs inside or crssing the rectangle boundaries
are converted to spaces.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectToUpper.


File: editor.inf,  Node: To lower (Rectangle),  Prev: To upper (Rectangle),  Up: Rectangle

4.5.10 To lower (Rectangle)
---------------------------

Converts all the characters inside the rectangle to lowercase. This
operation basically does a cut of the block, then process all the
characters and finally makes a paste of the modified block. As a side
effect of this operations tabs inside or crssing the rectangle boundaries
are converted to spaces.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectToLower.


File: editor.inf,  Node: Windows,  Next: Tool&Ops,  Prev: Rectangle,  Up: Pull-down menues

4.6 Windows
===========

This menu contains the options to handle the windows in the editor.

* Menu:

* Size/move::
* Zoom::
* Tile::
* Cascade::
* Next (Window)::
* Previous (Window)::
* Close::
* List::
* User Screen::


File: editor.inf,  Node: Size/move,  Next: Zoom,  Prev: Windows,  Up: Windows

4.6.1 Size/move
---------------

You can resize the windows dragging the bottom right corner of the window.
You can move the windows dragging the title line of the window.

Additionally this command allows these operations to be done without the
mouse. Once you entered in this mode the border of the window chages its
color and you can move the window using the arrow keys. To resize the
window use the arrow keys holding the <Shift>. Additionally <Home>, <End>,
<PgUp> and <PgDown> can be used to move the window to one end of the
desktop. Ones you finished you can end this mode pressing <ESC> or <ENTER>.

Name of the command: cmeResize.
Assigned key: `^F5'


File: editor.inf,  Node: Zoom,  Next: Tile,  Prev: Size/move,  Up: Windows

4.6.2 Zoom
----------

Changes the size of the window to be as large as the whole desktop. The
second time you use this command the window is resized to your original
size.  Is the equivalent of the maximize and restore options of other
editors.

Name of the command: cmeZoom.
Assigned key: `F5'


File: editor.inf,  Node: Tile,  Next: Cascade,  Prev: Zoom,  Up: Windows

4.6.3 Tile
----------

Arranges all the windows in a way that you can see all at the same time.

Name of the command: cmeTile.


File: editor.inf,  Node: Cascade,  Next: Next (Window),  Prev: Tile,  Up: Windows

4.6.4 Cascade
-------------

Arranges all the windows overlapping.

Name of the command: cmeCascade.


File: editor.inf,  Node: Next (Window),  Next: Previous (Window),  Prev: Cascade,  Up: Windows

4.6.5 Next (Window)
-------------------

Selects the next window. The windows are linked in circular list, this
command selects the next window in the list. To change the order you can
directly select a window with the mouse or <ALT> plus a number. Doing that
this window will become the current one, and the other will be the
`previous' window.

Use it to select the most recently selected windows.

Name of the command: cmeNext.
Assigned key: `F6'


File: editor.inf,  Node: Previous (Window),  Next: Close,  Prev: Next (Window),  Up: Windows

4.6.6 Previous (Window)
-----------------------

Selects the previous window. The windows are linked in circular list, this
command selects the previous window in the list. To change the order you
can directly select a window with the mouse or <ALT> plus a number. Doing
that this window will become the current one, and the other will be the
`previous' window.

Use it to select the most recently selected windows.

Name of the command: cmePrev.
Assigned key: `Shift+F6'


File: editor.inf,  Node: Close,  Next: List,  Prev: Previous (Window),  Up: Windows

4.6.7 Close
-----------

Closes the current window. If the content isn't saved the editor will ask
for saving.

Name of the command: cmeClose.
Assigned key: `Alt+F3'


File: editor.inf,  Node: List,  Next: User Screen,  Prev: Close,  Up: Windows

4.6.8 List
----------

Pop-ups the List of Windows dialog. This dialog contains the list of all
the editor windows, the special windows and the closed windows.

The editor windows are numbered starting from two and the list is sorted by
number. If a window isn't saved an asterisk is placed between the number
and the name.

The special windows are: the message window (the number of lines is
indicated), the project window, the clipboard window (the bytes used by it
is indicated) and the InfView windows.

The closed windows list is sorted alphabetically and holds the last closed
windows. The editor stores important information about these windows so if
you close and re-open one of them the size of the window and other values
are restored.

You can jump to any of the windows selecting it with the mouse or the
arrow keys and then pressing <ENTER> or double clicking or using the `Go'
button.

Pressing <Delete> or using the `Delete' button you can delete the closed
windows or close any editor window.

Name of the command: cmeListWin.
Assigned key: `Alt+0'


File: editor.inf,  Node: User Screen,  Prev: List,  Up: Windows

4.6.9 User Screen
-----------------

Shows the DOS screen. Press any key to go back to the editor.

Name of the command: cmeUserScreen.
Assigned key: `Alt+F5'


File: editor.inf,  Node: Tool&Ops,  Next: Project,  Prev: Windows,  Up: Pull-down menues

4.7 Tool&Ops
============

This menu contains all the configuration submenues and some usefull tools.

* Menu:

* Options::
* Calculator (command/menu)::
* SDG::
* Run program::
* Grep::
* HTML Accents::
* Export as HTML::
* Insert key name::
* Remap code page::
* Profile Editor::
* Redraw screen::
* Paste Emacs mode::
* Block quoted printable decode::
* Un/Indent block::
* Delete memorized backups::


File: editor.inf,  Node: Options,  Next: Calculator (command/menu),  Prev: Tool&Ops,  Up: Tool&Ops

4.7.1 Options
-------------

This submenu contains the configuration submenues.

* Menu:

* Colors::
* Color Palette::
* Editor General::
* Screen Saver::
* SDG Options::
* Run program (which one)::
* Keyboard::
* Key assignment::
* Setup Alt keys::
* Key pad behavior::
* Back to defaults::
* Consult scan codes::
* Screen Options::
* User Words::
* Default global edition::
* File open dialog::
* Do not create backups for::
* Search files under cursor in::


File: editor.inf,  Node: Colors,  Next: Color Palette,  Prev: Options,  Up: Options

4.7.1.1 Colors
..............

This command allows to customize the colors used by the editor. Almost all
the colors are configurable.

The first list, called `Group', is the list of things used by the editor.
Each entry in the group list have one or more colors in the `Item' list.
First select the group you want to customize and then press <Tab> to move
the cursor to the items list. To customize a color just select it in the
list of items; the dialog will show a text example in the bottom right
corner and the `Foreground' and `Background' colors will be indicated.
Using the mouse or moving with <Tab> and using the arrow keys you can
select any of the available colors; the sample text will show the
resulting combination.

Exiting the dialog with <ENTER> or with the `Ok' button the new colors
will be applied. The colors are stored in the desktop file. If you are
using one centralized desktop file these colors will be used each time you
run the editor, if not the colors will be used only when you run the
editor in this directory.

To learn more about the scope of the desktop files and how to indicate
default values: *Note Desktop Files::.

If you want to use other colors don't listed in this dialog you must
customize the palette. *Note Color Palette::.

Name of the command: cmeSetColors.


File: editor.inf,  Node: Color Palette,  Next: Editor General,  Prev: Colors,  Up: Options

4.7.1.2 Color Palette
.....................

This option allows to configure the palette of colors used by the editor. I
think you know about palettes but I included a little of explanation, just
in case. *Note Text mode attributes::.

The `Color' radio buttons are used to select the index you want to
customize. The `Red', `Green' and `Blue' scroll bars can be used to
customize the color. To modify one of the components use the mouse or use
the <R>, <G> and <B> to increase the values and <Shift>+<R>, <Shift>+<G>
and <Shift>+<B> to decrease the values.

Exiting the dialog with <ESC> restores the values you had before entering
to this option. Choosing the `Default' button the colors are configured
with the deafult values used by the VGA cards.

These settings are stored in the desktop file. *Note Desktop Files::.

Name of the command: cmeEditPalette.


File: editor.inf,  Node: Editor General,  Next: Screen Saver,  Prev: Color Palette,  Up: Options

4.7.1.3 Editor General
......................

This option po-ups the general configuration dialog containing several
options.

The `Save options' groups control various settings about what files creates
the editor and how they are created.

   * Make backups: When enabled the editor keeps a backup of your files
     using the `.bkp' extension. It saved me many times.

   * UNIX style backups: When enabled the backups are created appending a
     tilde symbol to the file extension. This is recommended only for
     systems that supports long file names, not pure DOS.

   * Hidden backups: The backups are created as hidden files, it can be
     used to keep backups, but at the same time make them less annoying.

   * Remmember bkps to delete: When you exit with `Quit' the editor
     deletes backup files. To do it the editor deletes files ending with
     `bkp', but if you use UNIX style backups or just edit files in a
     directory other than the current is hard to know where these files
     are located. For this reason the editor keeps a list of created
     backup files.  If you exit normally this list is lost, so the next
     time you use the editor and exit with `Quit' only the backups created
     during this session will be deleted. This behavior can be modified
     choosing this option, when enabled the editor will store the list in
     the desktop file and retreive it the next time you start the editor.
     By default this option is disabled because users that doesn't know
     about this mechanism and uses a centralized desktop file could end
     with a very long list of backup files wasting memory and disk space.

   * Don't create desktop files: When enabled the editor creates only one
     desktop file and not one per directory. *Note Desktop Files::.

   * Save desktop files hidden: Just what the name says, that's useful if
     you want to create desktop files in each directory but they hinder in
     directory listings.

   * Tile windows vertically first: It affects the `Windows|Tile' option.
     Normally this option starts splitting the screen by dividing the
     height of windows. When this option is selected the width is divided
     first.

   * Save UNIX files as UNIX: When enabled the editor saves to disk UNIX
     files in UNIX format. That means that the conversion is done only
     internally and the format of the file in disk isn't altered when you
     save.

   * Do not remmember cursor position: If you enable it the editor won't
     remmember the cursor position of editor windows.

   * Do not warn about read-only files: It disables the dialog that warns
     about opening read only files. Disabling it you won't be asked about
     reverting the read-only attribute until you try to save the file.

   * Open read-only files as R.O. buffers: When enabled the editor marks
     files that are marked as read-only in disk as read-only files in
     memory. Note this option doesn't disable the warning, use the above
     mentioned option for it.

In the open, save, `etc.' dialogs you can sort backup files in a special
way so they doesn't interfer with the rest of the files.  *Note File open
dialog::.
You can also configure the editor to avoid creating backup files for some
particular filenames or directories. *Note Do not create backups for::.

The `Clock' group allows to turn on/off the clock and to choose 0 to 24 hs
or AM/PM style. The clock is displayed in the top right corner of the
screen.

The `Max. editor copies' controls how many copies of the same file can be
opened at the same time. By default the value is one, so when you try to
open a file twice the editor will just show you the first copy. Specifying
a value different than one will allow you to open more copies of the same
file. Only the first copy can be modified and the rest are read-only
snap-shots of the file. For more information: *Note Open Read-only copy::.

The `Max. closed to remmember' value specifies how many closed files are
remmembered in the list of windows. This value can't be less than three and
can't be greater than two hundred. If you reduce this value and there are
already more files remmembered the editor won't reduce the number
instantaneously, you must choose what files to remove by hand.

The `+ Desktop' button opens a second dialog containing options about what
things are stored in the desktop files. Each section selects if the option
will be remmembered always (ever), only when no files are specified in the
command line or never.

   * Remmember editor windows: it affects the opened files.

   * Remmember other windows: it affects other windows, like the help
     windows.

   * Remmember closed windows: it affects the list of closed files.

The second dialog contains a button to return to the first dialog.

These settings are stored in the desktop file. *Note Desktop Files::.

Name of the command: cmeEdGralOptions.


File: editor.inf,  Node: Screen Saver,  Next: SDG Options,  Prev: Editor General,  Up: Options

4.7.1.4 Screen Saver
....................

This dialog customize the screen saver. Note the question mark at the end
of the words "screen saver" I did it because the plasma screen saver isn't
too good to be used as a real saver for your screen. You can enable and
disable it, choose the time the editor will wait before starting the
screen saver and the screen saver style. The Test button can be used to
see how the screen saver looks like.

If you left the mouse pointer in the upper right corner of the screen for
some seconds the screen saver is activated. This time is three seconds by
default and can be configured entering the amount of seconds in the second
box labeled `Time'.

Two types of screen savers are supported: internal and external. Internal
screen savers are hardcoded in the editor. External screen savers are
external programs started from the editor. If you select an external screen
saver from the list the Info and Help buttons are enabled. Pressing these
buttons you can get more information about the screen saver. You can pass
additional parameters to the external screen saver filling the `External
Saver' box.

If you want to write your own screen saver please download the sources of
the editor and read the explanations found in the `scrnsave' directory. An
external screen saver is basically a simple program that supports some
special command line options and returns with some specified return values.

Name of the command: cmeScreenSaverOpts.


File: editor.inf,  Node: SDG Options,  Next: Run program (which one),  Prev: Screen Saver,  Up: Options

4.7.1.5 SDG Options
...................

These options customize the SDG module (SET's Documentation Generator).
see *Note SDG Documentation: (SDG)Top.

   * Format file: Indicates the name of the format file used to generate
     the documentation.

   * Intermediate file: The name of the temporal file used in the process.

   * Base output: The base name of the output file. Don't include the
     extension.

   * Directory of formats: The place where the editor will search for the
     format file.

   * Keep intermediate: When enabled the temporal file isn't deleted so
     you can see possible errors on it.

The SDG module uses the files listed in the project to collect the
documentation from the comments. *Note Project::.

These settings are stored in the desktop file. *Note Desktop Files::.

Name of the command: cmeSDGDialog.


File: editor.inf,  Node: Run program (which one),  Next: Keyboard,  Prev: SDG Options,  Up: Options

4.7.1.6 Run program (which one)
...............................

The editor can run an external program and collect the errors reported by
it just pressing a key (`^F9'). A good example is the make program. Here
you can select the name of the program. If you need to run more than one
command separate it with `;'.

The editor will redirect the stderr (standard error output) and stdout
(standard output) of the program and then will analize it looking for
errors.  The dialog includes a list of parsing algorithms to analize the
errors from the external program. To learn how to configure the editor for
other formats or just fine tune any of them *Note Error messages from an
external application::.

The other options found in this dialog are a little bit complex. Here I'll
try to explain each of these options but I recommend just try them to see
how they work.

Option `Use OS screen to run the program': The editor will try to restore
the contents of the screen. So it will looks like it was before running the
editor. Then the program will be executed and finally the editor will
redraw all the contents of the desktop and windows. This mechanism is
useful when the program you want to run is interactive or doesn't use the
standard output. Is important to understand that on some platforms and
terminals the editor can't restore the contents of the screen and will
just clean it to the grey over black color. Is also important to
understand that when this option is enabled the program can't be executed
in multitasking mode; it means the option `Don't try to run in background'
will be implicitly selected.

Option `Don't try to run in background': In some platforms (currently only
Linux) the editor can execute the external program as a child process. It
means the program will execute in parallel with the editor (in background).
When the editor does it you'll see the message window will indicate the
program is running but won't say you are back in the editor. Instead the
output of the external program will start to fill the message window. You
can select any other window and continue working while the external
program runs.  When the external program ends the editor will also collect
the rest of the messages and errors in background. While the editor is
running the external program and/or parsing the remaining messages the
status bar will show an option `Ctrl+C Stop'; clicking on it or pressing
the indicated key the editor will stop the background process and will
also stop collecting messages. Now you know it I can explain the purpose
of this option. When this option is enabled the editor won't try to run
the external program in parallel even if the platform supports it. That's
faster, but if the external program is slow you'll be forced to wait until
it finish and you won't be able to stop the program from the editor.

Option `Always parse in background': If enabled the editor will collect the
messages and errors in background even if the platform doesn't support the
execution of the external program in background. In platforms that doesn't
support the execution of the external program in background the editor will
block until the external program ends and then will parse the messages and
errors in background. This is useful when the amount of messages and errors
is big and the parsing will take a long time. In this way you can continue
working while the editor does this job. You must understand that's even
slower but you can use this time for reading or editing text.

The `Message window scroll' group of options are mutually exclusive and
gives some control over the behavior of the message window. When you start
executing the external program the message window will automatically get
the focus. As messages and errors are added to this window the window
scrolls and shows the last message. When the external program finish and
the editor parses all the messages and errors the message window will get
the focus again. Finally if the editor found errors the message window
will scroll to the first line. This is the default behavior and you'll be
able to see each of this steps only if the editor is running the external
program in background and/or parsing the messages and errors in
background. This behavior corresponds to the `Ever' option. If you select
the `Never' option the editor won't scroll the message window. In this
case you can browse the messages even while the editor is collecting them.
Finally you can choose `Only if not focused'. In this case you'll be able
to browse the messages when the message window is selected, but if you
select other window the editor will start to scroll the message window.
The fastest option is `Never' but then you won't see if the external
program finished executing, unless you have the message window selected
all the time.

The `Lines per pass' option is associated with the speed of parsing. This
option takes effect only when the messages and errors are parsed in
background. What this option indicates is how many lines of messages and
errors will be parsed before releasing the CPU. A bigger value will make
the parsing faster but will make the editor slower and you'll start having
problems to select windows and write text. You must experiment with this
parameter. In my machine a value of 20 is acceptable.

All of these settings are stored in the desktop file. *Note Desktop
Files::.

For more information about the behavior of the message window *Note
Message Window::.

Name of the command: cmeConfRunCommand.


File: editor.inf,  Node: Keyboard,  Next: Key assignment,  Prev: Run program (which one),  Up: Options

4.7.1.7 Keyboard
................

This is a submenu but due to limitations in the documentation tools I was
forced to put it with the rest of the options listed in the `Options'
submenu.

It contains all the options to customize the keyboard.


File: editor.inf,  Node: Key assignment,  Next: Setup Alt keys,  Prev: Keyboard,  Up: Options

4.7.1.8 Key assignment
......................

With this command you can fully customize the keys used by the editor
windows.  It doesn't include the menues, for that you must edit the
`menubind.smn' file.

To learn how to use this command consult: *Note How to configure the
keyboard::.

Name of the command: cmeEditKeyBind.


File: editor.inf,  Node: Setup Alt keys,  Next: Key pad behavior,  Prev: Key assignment,  Up: Options

4.7.1.9 Setup Alt keys
......................

It allows you to select how the editor interpretes the left and right alt
keys. For more information: *Note Alt key configuration::.

Name of the command: cmeSetUpAltKeys.


File: editor.inf,  Node: Key pad behavior,  Next: Back to defaults,  Prev: Setup Alt keys,  Up: Options

4.7.1.10 Key pad behavior
.........................

[DOS]

Here you can choose how the keypad is interpreted by the editor. Two
options are provided. One is the BIOS default, in this mode the <NumLock>
changes between arrows and numbers. In the other mode the behavior is
similar, but holding shift and pressing a number will behave like an arrow
key shifted, that's very common in DOS applications so that's the default.

Name of the command: cmeKeyPadBehavior.


File: editor.inf,  Node: Back to defaults,  Next: Consult scan codes,  Prev: Key pad behavior,  Up: Options

4.7.1.11 Back to defaults
.........................

This option restore the default keys assignment of the editor. Use it if
you did a real dissaster in the keyboard configuration and you want to go
back to the original values.

Name of the command: cmeKbBackDefault.


File: editor.inf,  Node: Consult scan codes,  Next: Screen Options,  Prev: Back to defaults,  Up: Options

4.7.1.12 Consult scan codes
...........................

Used to consult the keyboard scan codes: *Note Consulting scan codes::.

Name of the command: cmeSeeScanCodes.


File: editor.inf,  Node: Screen Options,  Next: User Words,  Prev: Consult scan codes,  Up: Options

4.7.1.13 Screen Options
.......................

This command po-ups the screen options configuration dialog. Here you can
customize the video mode, the fonts and the characters encoding. If you are
looking for the screen saver: *Note Editor General::.

The `Screen Mode' group allows you to select the video mode. The radio
buttons shows the modes fully supported by the editor. If you want to try
an special mode of your video card just enter the number of mode in the
input line located under the modes list. Finally you can choose to set the
mode using an external program. To make that enable the `Use external
program' option and enter the name of the program. I use SVGA Text Mode to
setup 108x30 from time to time.

The `Primary font' and `Secondary font' groups are used to indicate the
fonts used by the editor. If you don't know what a secondary font is:
*Note Text mode attributes::. For the primary font you can choose between
using the ROM BIOS fonts or one of the provided fonts. If you choose the
ROM BIOS fonts then the encoding doesn't have any effect and you can't use
a secondary font. For the secondary font you can choose if you want to use
it or not.

The provided fonts works well with the list of supported video modes and
normally can be used with any video mode, but if you choose a very strange
video mode the editor won't be able to set the font and will use the ROM
BIOS fonts.

The `Primary encoding' and `Secondary encoding' options allows to select
the code page (encoding) used by the editor. Currently the editor supports
twelve encodings. That's usefull if you need to look files with a different
encoding and the encoding isn't supported by DOS or you just don't want to
reconfigure your machine for it. As an example in my country the DOS uses
the CP850 as default, as this code page destroys some graphic chars I
never use it, but there are people using it so if I want to look text
written by this people in the right way I must choose this encoding.
Something similar happends with Windows and Linux texts, they use ISO
Latin 1 and that's totally unsuported by DOS, so if I want to see the
accents in the text I must use this encoding.

Name of the command: cmeSetScreenOps.


File: editor.inf,  Node: User Words,  Next: Default global edition,  Prev: Screen Options,  Up: Options

4.7.1.14 User Words
...................

This option is used to define reserved words defined by the user. A very
common use is to define `typedef's you normally use in your programs.  The
user words are language dependant. They are highlighted with a special
color different than the color used for reserved words.

The first dialog is used to select the language, the names are the ones
defined in the syntax highlight file (*Note Syntax Highlight::). Selecting
one of the names and pressing <ENTER> the second dialog pop-ups.

The next dialog is used to add or remove words to the list. Pressing
<ENTER> you confirm the changes and they are saved to disk. If you exit
with <ESC> the old list is preserved.

The user words are stored in a file called `userword.txt' in the same
place where the rest of the configuration files are stored. The editor
doesn't include this file in the distribution because these values must be
defined by the user. You can edit the file by hand if you want, the format
is very simple. The start of a list is marked with `.' followed by the name
of the language. The items of the list are marked with `+'. Any line
starting with other character will be ignored during the parsing.

Note: The menu option is "Tool&Ops|Options|User Words".

Name of the command: cmeEditUserWords.


File: editor.inf,  Node: Default global edition,  Next: File open dialog,  Prev: User Words,  Up: Options

4.7.1.15 Default global edition
...............................

To understand how this menu option works you must know some details about
the global options of the editor. *Note Set Global::.

The global options are good, but sometimes you want to make some small
differences depending on the kind of file you are editing. For example: I
want the `Intelligent C indent' mode enabled for C, but not for most of the
files, I also want to wrap lines for Texinfo files and files without syntax
highlight. That's impossible to achieve just using the global options, here
is when this option is used.

The mechanism is like this: each time you open a new file the editor will
copy the default global options to it and select the syntax highlight
according to various things, mainly using the extension. Ones the editor
select the syntax highlight the next step is to transfer some options that
applies only to the selected syntax highlight. By default the list of
options to apply is empty but you can add options using this menu option.

The options are associated with a particular syntax highlight and the
values are stored in a file called `deflopts.txt'. The list of options
indicates which settings will be enabled, or disabled, in addition to the
global options. That's something very important you must to note, the list
acts in addition to the global options, not instead. So the list will say
things like "also enable the intelligent C indent", "disable the wrap
lines", `etc.'

The first dialog shows the list of syntax highlight defined in the
`syntaxhl.shl' and have three buttons. The `Edit' button is the default
button, so pressing <ENTER> you'll edit the settings for the selected
syntax highlight. The `No SHL' button is used to edit the options that
will be applied for files that doesn't have any syntax highlihgt applied.

Once you selected one syntax highlight a dialog with the list of the
settings associated to it will appear. The first time it will be empty
because these values are filled only by the user, no defaults are
provided. In this list the settings that will be enabled in addition to
the global options are marked with a `+' before the name of the option.
The options that will be disabled are marked with a `-'. The options are
the same described in the editing modes section. *Note Editing Modes::.

The dialog contains an `Add' and a `Delete' button as other dialogs. You
can also use the <Insert> and <Delete> keys. When adding a new setting to
the list a dialog containing the list of available settings is displayed.
Note this list contains all the settings that are available, once you add
one of them to the previous dialog it is removed from this list.

After selecting one setting to add a new dialog will be displayed. This
dialog will ask information related to this setting. Most settings are
flags that can be `added' or `substracted' from the global options, but
some of them are just values that will overwrite the global options.
Examples of the last type are the tabs size and the wrap column, in this
case the dialog will ask the value.

The values are stored in a very simple format in the `deflopts.txt' file.
You can edit this file by hand, but in this case you'll need to know the
names of the settings. The format is very simple, a line starting with `.'
starts a section, the stop is followed by the name of the highlight
affected. Flags that will be added (enabled or ored) are marked with a `+'
as in the dialog, flags that will be substracted (disabled or anded) are
marked with a `-' again like in the dialog, in fact the dialog shows the
same string that is then stored in the file. If the setting is numeric it
will ever start with `+' and after the name follows an `=' and the asigned
value. Just play a little bit and see the resulting file.

Name of the command: cmeEditDeflOpts.


File: editor.inf,  Node: File open dialog,  Next: Do not create backups for,  Prev: Default global edition,  Up: Options

4.7.1.16 File open dialog
.........................

This command is used to configure some details of the file open dialog.
*Note File Open::.

Name of the command: cmeFileOpenOptions.


File: editor.inf,  Node: Do not create backups for,  Next: Search files under cursor in,  Prev: File open dialog,  Up: Options

4.7.1.17 Do not create backups for
..................................

Some times you don't know to create backups for some particular files. In
my case I use a tool called `cvs', it generates some temporal files and
calls the editor so I can write some information. Those files are short and
temporal, creating backups for them doesn't have any sense.

This command shows a configuration dialog where you can enter a list of
regular expressions. If any of these regular expressions match with the
file name of the file you are about saving then the editor won't create a
backup file for it. The regular expressions are Perl style because I think
they are much more intuitive than POSIX regex.

The list shown in this dialog is stored in a file called `nobkp.txt'.  The
exact place of the file depends on your system like other files created by
the editor.

Note that files listed here aren't remmembered in the list of closed
editors.  That's because the editor assumes these files are temporal and
you won't need to use them again.

Name of the command: cmeEditNoBkp.


File: editor.inf,  Node: Search files under cursor in,  Prev: Do not create backups for,  Up: Options

4.7.1.18 Search files under cursor in
.....................................

When you press `Ctrl+Enter' the editor tries to load the file that's in
the text at the cursor position. If the cursor is in an include line the
editor will extract the name of the header. In any other case the editor
will try to find where the name starts and ends.

If the file isn't located in the current directory the editor will try to
find the file in the list of directories indicated by this option.

This list is stored in the desktop file.

Name of the command: cmeIncludeList.


File: editor.inf,  Node: Calculator (command/menu),  Next: SDG,  Prev: Options,  Up: Tool&Ops

4.7.2 Calculator (command/menu)
-------------------------------

This command shows the calculator: *Note Calculator::.

Name of the command: cmeCalculator.
Assigned key: `Alt+F4'


File: editor.inf,  Node: SDG,  Next: Run program,  Prev: Calculator (command/menu),  Up: Tool&Ops

4.7.3 SDG
---------

Runs the documentation module: see *Note SDG Documentation: (SDG)Top.

To configure the SDG module: *Note SDG Options::.

Name of the command: cmeSDG.
Assigned key: `F9'


File: editor.inf,  Node: Run program,  Next: Grep,  Prev: SDG,  Up: Tool&Ops

4.7.4 Run program
-----------------

Runs the desired program. To customize what program to run: *Note Run
program (which one)::.

Name of the command: cmeRunCommand.
Assigned key: `Ctrl+F9'


File: editor.inf,  Node: Grep,  Next: HTML Accents,  Prev: Run program,  Up: Tool&Ops

4.7.5 Grep
----------

This command pop-ups the `Powered Grep' dialog. Grep is a very powerfull
tool to search text in files. To be able to use it you must have the grep
tool installed in your system. It isn't shipped with the editor.

   * Pattern Box: The text you want to search for. You can use regular
     expressions here. *Note Regular Expressions::.

   * Files to search: The mask used to select the files where grep will
     make the search. Wildcards and some limited basic regular expressions
     are supported here.

   * Directories to search: The list of directories where the search will
     be performed.

The `Source of pattern' options are used to select what text will be
searched:

   * Pattern box is the pattern: grep will search the text indicated in the
     pattern box.

   * Pattern box is a file name: To search words contained in a text file.

   * Use clipboard selection: Use it to use the clipboard selection instead
     of the pattern box text. *Note Clipboard::.

The `Type of pattern' option selects how the pattern is interpreted the
options are directly related to the grep switchs `-G', `-E' and `-F'. You
can select basic regular expressions, extended regular expressions or just
a list of matching values separated by carriage returns.  *Note Regular
Expressions::.

The `Place to search' group is used to select what files are examined in
the search:

   * Use files to search: The files to search content is the mask.

   * Search in opened windows: The search is performed in all the opened
     text files.

   * Search in project: The search is performed in all the project files.
     *Note Project::.

   * Recurse in subdirs: When enabled the editor will run search not only
     in the indicated directories but in any subdirectory contained by
     these directories. That's the main reason because I call it Powered
     Grep.

The `Options' group contains various options that are self-explanatory.
They include: case sensitive search, whole word and whole line matching and
inverse matching. The last reports the lines that doesn't match, be
careful.

After the search the matched lines are displayed in the message window and
pressing `Alt+F7' and `Alt+F8' you can examine the matchings.

To learn more about the message window *Note Message Window::.

Name of the command: cmeGrepDialog.


File: editor.inf,  Node: HTML Accents,  Next: Export as HTML,  Prev: Grep,  Up: Tool&Ops

4.7.6 HTML Accents
------------------

The following options are useful for people using ISO Latin 1 accents in
your HTML code. Even when the current code page is different than ISO
Latin 1.

* Menu:

* Convert accents to tags::
* Convert tags to accents::


File: editor.inf,  Node: Convert accents to tags,  Next: Convert tags to accents,  Prev: HTML Accents,  Up: HTML Accents

4.7.6.1 Convert accents to tags
...............................

It converts all the accents in the text to ISO-Latin-1 HTML tags. That's
useful when editing html files because you can type accents naturally and
when finished you simply use this option to generate the right tags. It
works for any code page selected.

Name of the command: cmeHTMLAccents.


File: editor.inf,  Node: Convert tags to accents,  Prev: Convert accents to tags,  Up: HTML Accents

4.7.6.2 Convert tags to accents
...............................

It converts all the ISO-Latin-1 HTML tags into accents. That's useful when
reading html files because you can convert the tags in symbols. It works
for any code page selected.

Name of the command: cmeHTMLTag2Accent.


File: editor.inf,  Node: Export as HTML,  Next: Insert key name,  Prev: HTML Accents,  Up: Tool&Ops

4.7.7 Export as HTML
--------------------

This option is used to export the current text file as HTML. The default
options generates a very good WYSIWYG result. This option works for any
syntax highlight mode and for any color configuration you want.

Under DOS you can customize the editor's palette, this feature will export
the customized colors too.

Note that due to limitations in the HTML language the editor can change the
background color for a single word.

The available options are:

   * File name as title: uses the full path and name of the file as the
     title for the generated HTML.

   * Same background color as the editor: defines the background of the
     HTML file to be equal to the background of the editor's window.

   * Monospacied font: sets the font for the HTML to `Courier New'.

   * Bold attribute: sets the font for the HTML to `bold'.

You can also choose between colorized or simple output. Using colors the
size of the file is increased a lot but the result is very beauty.

Name of the command: cmeExportAsHTML.


File: editor.inf,  Node: Insert key name,  Next: Remap code page,  Prev: Export as HTML,  Up: Tool&Ops

4.7.8 Insert key name
---------------------

This command brings a dialog asking you to press a key. When you press a
key the dialog is closed and the name of the key is inserted at the cursor
position. You can use it to configure the menues (`menubind.smn').  *Note
How to configure the keyboard::.

Name of the command: cmcInsertKeyName.


File: editor.inf,  Node: Remap code page,  Next: Profile Editor,  Prev: Insert key name,  Up: Tool&Ops

4.7.9 Remap code page
---------------------

With this command you can change the code page encoding of the current
document. This operation will translate all the characters from the current
encoding to a new one. Characters that doesn't have an equivalent in the
new code page are converted to spaces.

The dialog asks for the original code page (from list) and the new code
page (to list). Additionally you can allow the editor to also translate
the lower 32 values. Translating the lower 32 values could be dangerous;
for this reason the editor won't translate carriage return, line feed and
tabs even if you choose to remap the low values.

This operation affects the buffer globally so doesn't have undo, just keep
a copy of the file and don't save it if the results aren't what you
expected.

This option is very useful to exchange texts between different operating
systems.

Name of the command: cmeRemapCodePage.


File: editor.inf,  Node: Profile Editor,  Next: Redraw screen,  Prev: Remap code page,  Up: Tool&Ops

4.7.10 Profile Editor
---------------------

This option is just used to meassure the speed of the editor. Use large
files and to compare results run it on the same file.

Name of the command: cmcProfileEditor.


File: editor.inf,  Node: Redraw screen,  Next: Paste Emacs mode,  Prev: Profile Editor,  Up: Tool&Ops

4.7.11 Redraw screen
--------------------

This command just forces a redraw of the screen. It could be needed if some
application running in background messed your console.

Name of the command: cmeReDraw.


File: editor.inf,  Node: Paste Emacs mode,  Next: Block quoted printable decode,  Prev: Redraw screen,  Up: Tool&Ops

4.7.12 Paste Emacs mode
-----------------------

Pastes a comment at the start of the file indicating the Emacs mode and the
tab size used for this file. That's very useful if the file doesn't have
extension or the extension is ambiguous. It is also good idea to do it if
you'll send the file to another person and want to indicate which tab size
you used.

The editor understands this comment and sets the syntax highlight and tab
size to the value indicated.

Name of the command: cmcPasteEmacsMode.


File: editor.inf,  Node: Block quoted printable decode,  Next: Un/Indent block,  Prev: Paste Emacs mode,  Up: Tool&Ops

4.7.13 Block quoted printable decode
------------------------------------

This option decodes de selected text assuming it is encoded with the quoted
printable MIME spec. That's useful if you have an e-mail with non-ASCII
characters and it was encoded with this methode. That's very useful for
spanish accents.

Name of the command: cmcQuotedPrintDecode.


File: editor.inf,  Node: Un/Indent block,  Next: Delete memorized backups,  Prev: Block quoted printable decode,  Up: Tool&Ops

4.7.14 Un/Indent block
----------------------

This submenu contains the block indentation operations.

* Menu:

* Indent one space::
* Unindent one character::
* Indent one tab or gap::
* Unindent one tab or gap::
* Comment indent::
* Comment unindent::
* Arbitrary indent::


File: editor.inf,  Node: Indent one space,  Next: Unindent one character,  Prev: Un/Indent block,  Up: Un/Indent block

4.7.14.1 Indent one space
.........................

Indents a block one space. For more information *Note Indentation::.

Name of the command: cmcIndentBlkOne.


File: editor.inf,  Node: Unindent one character,  Next: Indent one tab or gap,  Prev: Indent one space,  Up: Un/Indent block

4.7.14.2 Unindent one character
...............................

Unindents a block one character. For more information *Note Indentation::.

Name of the command: cmcUnIndentBlkOne.


File: editor.inf,  Node: Indent one tab or gap,  Next: Unindent one tab or gap,  Prev: Unindent one character,  Up: Un/Indent block

4.7.14.3 Indent one tab or gap
..............................

Indents a block like if you used the <Tab> key in the first line and
propagated it to the rest. For more information *Note Indentation::.

Name of the command: cmcIndentBlk.


File: editor.inf,  Node: Unindent one tab or gap,  Next: Comment indent,  Prev: Indent one tab or gap,  Up: Un/Indent block

4.7.14.4 Unindent one tab or gap
................................

Unindents a block like if you used the <Backspace> key in the first line
and propagated it to the rest. For more information *Note Indentation::.

Name of the command: cmcUnIndentBlk.


File: editor.inf,  Node: Comment indent,  Next: Comment unindent,  Prev: Unindent one tab or gap,  Up: Un/Indent block

4.7.14.5 Comment indent
.......................

This command inserts a comment at the start of each line of the selected
block. The comment used is the one defined in the syntax highlight file as
`EOLComment1'; if none is defined or the file doesn't have any syntax
highlight or no block is selected this command does nothing. *Note
EOLComment1::.

Name of the command: cmcCommentIndent.


File: editor.inf,  Node: Comment unindent,  Next: Arbitrary indent,  Prev: Comment indent,  Up: Un/Indent block

4.7.14.6 Comment unindent
.........................

This command removes as many chars from each selected line as the length of
a comment sequence. The comment used is the one defined in the syntax
highlight file as `EOLComment1'; if none is defined or the file doesn't
have any syntax highlight or no block is selected this command does
nothing.  *Note EOLComment1::.

This command doesn't check if each line you selected starts with the
defined comment, be careful.

Name of the command: cmcCommentUnIndent.


File: editor.inf,  Node: Arbitrary indent,  Prev: Comment unindent,  Up: Un/Indent block

4.7.14.7 Arbitrary indent
.........................

This command pop-ups a dialog asking for a text to be used as indentation.
The text will be inserted at the start of each line of the selected block.

Name of the command: cmcArbitraryIndent.


File: editor.inf,  Node: Delete memorized backups,  Prev: Un/Indent block,  Up: Tool&Ops

4.7.15 Delete memorized backups
-------------------------------

Deletes all the memorized backups. It includes all the backups created
while the current project/desktop file was opened. If you want to also
delete backup files created during previous sessions you must enable an
special option that makes the editor keep a list across senssions.  *Note
Editor General::.

Name of the command: cmeDeleteBkps.


File: editor.inf,  Node: Project,  Next: Help,  Prev: Tool&Ops,  Up: Pull-down menues

4.8 Project
===========

The project files are used to indicate groups of files. Each project have
your own desktop file so you can have different settings for different
groups of files. *Note Desktop Files::.

There are several reasons to use projects:

   * If you want to work on a group of files and you will be editing these
     files for a long time use a project. Then you will be able to select
     what file to edit from the project window, as this window is sorted
     alphabetically is easy to make incremental searchs (typing the first
     letters) to find the file. Additionally the editor saves the window
     position and other stuff for all the files listed in the project,
     even if they aren't listed in the closed windows list. I use it for
     my web site files, they are over than 44 and the list of windows
     (`Alt+0') doesn't help.

   * If you are using the SDG module it will collect the comments of the
     files listed in the project, so you need to use a project to specify
     the files.

   * You can use a project to list a set of files to search with grep, then
     each time you want to search in these files you open this project and
     performe the search.

* Menu:

* Open (Project)::
* Close (Project)::


File: editor.inf,  Node: Open (Project),  Next: Close (Project),  Prev: Project,  Up: Project

4.8.1 Open (Project)
--------------------

Opens a project file. To create a new file just enter a new name in the
dialog.

Name of the command: cmeOpenPrj.


File: editor.inf,  Node: Close (Project),  Prev: Open (Project),  Up: Project

4.8.2 Close (Project)
---------------------

Close the project file.

Name of the command: cmeClosePrj.


File: editor.inf,  Node: Help,  Prev: Project,  Up: Pull-down menues

4.9 Help
========

* Menu:

* InfView::
* Another InfView::
* Tip of the day::
* Syntax help::


File: editor.inf,  Node: InfView,  Next: Another InfView,  Prev: Help,  Up: Help

4.9.1 InfView
-------------

Well I think you figured it out, that's the help.

Name of the command: cmeInfView.
Assigned key: `F1'


File: editor.inf,  Node: Another InfView,  Next: Tip of the day,  Prev: InfView,  Up: Help

4.9.2 Another InfView
---------------------

It opens another InfView window. The editor ever opens one window that's
used by the help system. When you close this window the editor just hides
it and when you press <F1> the window is un-hided and the help is
displayed.  That allows the existence of the `Previous help' command. But
some times you could want to brise one or more help files without losing
the help window, in this case you need more than one InfView opened.

Name of the command: cmeAnotherInfView.


File: editor.inf,  Node: Tip of the day,  Next: Syntax help,  Prev: Another InfView,  Up: Help

4.9.3 Tip of the day
--------------------

Once a day the editor shows a tip when you start. Each tip talks about one
interesting feature that most of the people overlook. Reading one tip by
day you'll discover a lot of interesting things about the editor.

Each tip have one or more buttons at the right, each button is a link to a
help topic related to this tip. If you want to learn more about the tip's
topic you can browse the help using the buttons.

There are three options at the bottom of the window, they are self
explanatory. The first disables the annoying tips ;-), the second shows the
tips in a dialog box once a day and the third shows the same text in the
message window (once a day of course). The third option is less annoying
than the second but you lose the link buttons.

The text displayed by the tips comes from the `editor.tip' file. You can
edit it to show anything but be careful because the parser isn't very
tolerant to typos.

To learn more about the message window *Note Message Window::.

Name of the command: cmeTipOfTheDay.


File: editor.inf,  Node: Syntax help,  Prev: Tip of the day,  Up: Help

4.9.4 Syntax help
-----------------

When programming a language like C you can't remmember the exact name of
all the library functions. The djgpp libc help contains around 650 nodes
and the Allegro help around 400. Placing the cursor over the name of a
library function and pressing <^F1> you'll get help about this function.
If the name isn't exactly typed you'll get a list of the closest matches.
The following topics explain how to configure it.

* Menu:

* Options (Syntax help)::
* Files to search (Syntax help)::
* Search (Syntax help)::


File: editor.inf,  Node: Options (Syntax help),  Next: Files to search (Syntax help),  Prev: Syntax help,  Up: Syntax help

4.9.4.1 Options (Syntax help)
.............................

This dialog box allows the configuration of the syntax help.  *Note Syntax
help::.

The search methode used can be:

   * Exact: Only exact matches are reported.

   * Substring: Partial matches are reported.

   * Fuzzy: It uses a special algorithm that reports words similar to the
     one you are searching.

The available options are:

   * Case sensitive: The search interprets lower case characters as
     different than uppercase characters.

   * Sort by score: The matches are sorted by score when reported. When
     disabled the sorting criteria is alphabetical. A greater score means
     the match is more similar to the word you are searching. A score of
     1000 means exact match.

   * Fuzzy value: That's used only when the selected mode is the fuzzy
     mode.  It indicates what is minimal score a word must have to be
     displayed as a possible match. Experiment with different values and
     see the scores reported.

Name of the command: cmeSyntaxHelpOps.


File: editor.inf,  Node: Files to search (Syntax help),  Next: Search (Syntax help),  Prev: Options (Syntax help),  Up: Syntax help

4.9.4.2 Files to search (Syntax help)
.....................................

Here you can indicate in what info files the editor will search the name of
the function. the default is OS dependent. *Note Syntax help::.

You can specify an info node or just the name of the file. In the first
case the editor will read all the cross references found in this node, in
the second the editor will use all the nodes of the file. Normally the
node that contains all the relevant references is called Index, but there
are exceptions one interesting case is libc.

In the dialog the editor shows what nodes are used to search. If the name
have a question mark at the left it means the editor didn't read the file
yet, pressing <^F1> over any word the editor will search it and hence will
read the help files. If the name have an asterisk it means some error was
encoutered when trying to read this file. Finally if no mark is indicated
it means the editor succesfully read the file, additionally the number of
nodes found is indicated at the right. You can add or remove nodes from the
list.

Name of the command: cmeSyntaxHelpFiles.


File: editor.inf,  Node: Search (Syntax help),  Prev: Files to search (Syntax help),  Up: Syntax help

4.9.4.3 Search (Syntax help)
............................

It makes the syntax search and reports the matches found. If only one match
was found the editor jumps to this node. *Note Syntax help::.

Name of the command: cmeSyntaxHelp.
Assigned key: `^F1'


File: editor.inf,  Node: Editing Modes,  Next: Syntax Highlight File,  Prev: Pull-down menues,  Up: Top

5 Editing Modes
***************

  The editor has various settings that control the function and aspect of
the editor.

  The settings are:

* Menu:

* Overwrite::
* Autoindent::
* Real Tabs::
* Persistent Blocks::
* Intelligent C indent::
* Column cursor::
* Row cursor::
* Match pair highlight::
* Match pair on the fly::
* Do not wait to search the pair::
* Transparent Blocks::
* Optimal Fill::
* Wrap Words::
* Do not move the cursor on Paste::
* Scroll Lock centers::
* See Tabs::
* Do not move inside tabs::
* Tab indents::
* Use indent size::
* Do not purge spaces::
* Backspace unindents::
* Column Markers::
* Syntax Highlight::


File: editor.inf,  Node: Overwrite,  Next: Autoindent,  Prev: Editing Modes,  Up: Editing Modes

5.1 Overwrite
=============

  This setting controls if the typed characters are inserted in the buffer or
if the typed characters replace the original ones. *Note Insert and
Delete:: for a detailed explanation.


File: editor.inf,  Node: Autoindent,  Next: Real Tabs,  Prev: Overwrite,  Up: Editing Modes

5.2 Autoindent
==============

  This setting controls what happend when you press <ENTER>. If this setting
is off the cursor goes to the column 1 of a new line. If the mode is on
the editor will try to keep the indentation of the code inserting spaces
or tabs. *Note Optimal Fill::.


File: editor.inf,  Node: Real Tabs,  Next: Persistent Blocks,  Prev: Autoindent,  Up: Editing Modes

5.3 Real Tabs
=============

  This setting controls what happend when you press `<TAB>'. If this setting
is on the editor will insert an ASCII 9 in this place.

  An ASCII 9 is a TAB, that means that the width of this char is enough to
move the cursor to the next tabulator column. In the editor the tabulator
columns are equidistant and the positions are controled by the Tab Size
value.

  If this setting is off the editor won't put any ASCII 9 in your text.  The
behavior if configured by the `Tab indents' option. Read the section about
it for more information. *Note Tab indents::.

  You can also indent using spaces when this option is disabled. For more
information about consult the  `Use indent size' option.  *Note Use indent
size::.

  In the past (versions older than 0.4.44) another thing controlled by this
setting was the behaviour of the <Backspace> key, but now that's
controlled by the `Backspace unindents' option. *Note Backspace
unindents::.

  The editor is much more coherent when you choose to use TABs or not use
TABs. If you mix the two modes you'll get some unexpected things, specially
in the indentation of the blocks.

  Is better if you always work in a file without tabs and with this setting
off. Then you'll get much from the editor.

  Now you can say: `But I really need tabs because I'm editing a make file!'
or `because I will send the file using an ultra slow link' `and I want the
compression granted by the tabs.' In these cases you can first expand all
tabs, then work without real tabs and at the finish of your work compact
all possible spaces and generate a file with all the tabs that you need.
*Note Miscellaneous:: section.

  Most tabs users like to also enable the `Optimal Fill' option.  *Note
Optimal Fill::.


File: editor.inf,  Node: Persistent Blocks,  Next: Intelligent C indent,  Prev: Real Tabs,  Up: Editing Modes

5.4 Persistent Blocks
=====================

  This setting controls the behaviour of the selected area.

  *Note Block modes:: chapter for a detailed explanation.


File: editor.inf,  Node: Intelligent C indent,  Next: Column cursor,  Prev: Persistent Blocks,  Up: Editing Modes

5.5 Intelligent C indent
========================

  This mode was designed to be used in jointly with the Pseudo Macros (*Note
Pseudo Macros::) and the Real Tabs mode in off to achieve an easy way to
indent the code making a better work than the Autoindent mode.

  In this mode the spaces inserted after pressing <ENTER> depend on the
first word in the last line. For example, if you have:

     if (a==b)_

  With the cursor in the '_' position and press <ENTER> you'll get:

     if (a==b)
       _

  Now you can do either of two things, 1) press space and write the code
that will be executed by the if, or 2) if this a multiline code press {
and <ENTER>.  In the last case you'll get:

     if (a==b)
       {
        _

  Now type your first line of code. Press <ENTER>. Write your next line.
Press <ENTER> again and then <Backspace>:

     if (a==b)
       {
        1st line;
        2nd line;
       _

  Now type } and press <ENTER> one more time:

     if (a==b)
       {
        1st line;
        2nd line;
       }
     _

  As you can see the code is perfectly aligned without a significant work on
your part.

  I tried to make this mode as smart as possible, but needs more work. If
you have suggestions contact me.

  Another important thing is that this indentation has a personal style, my
style ;-), so maybe you don't like it. If that's your case you can do the
following things:

   * Use another way of indentation offered by the editor. For example,
     turn on the Real Tabs mode and indent with tabs.

   * Customize the `cpmacros.pmc' file (*Note Pseudo Macros::), actually
     this file is coherent with this mode.

   * The editor isn't configurable like Emacs or Brief using a language,
     but is written in C++ and chances that you know C++ are over the 90%
     so contact me and I'll help you to write the routines that you need
     to get an indentation in your own style :-).

* Menu:

* Can you explain to me more about the behavior of this mode?::
* Do you have more examples?::


File: editor.inf,  Node: Can you explain to me more about the behavior of this mode?,  Next: Do you have more examples?,  Prev: Intelligent C indent,  Up: Intelligent C indent

5.5.1 Can you explain to me more about the behavior of this mode?
-----------------------------------------------------------------

  I'll try to describe the behaviour of the mode:

  Each time you press <ENTER> the editor inserts a `\r\n' string in your
text, after that the editor searchs one line located above the new line
that has at least one character inside. This line is taken as reference.
The editor analyzes this line searching for:

   * The first non-blank character on this line.

   * The first word on this line.

   * The first parenthesis.

   * The balance of parentheses on the line.

   * The last non-blank and non-comment character in the line.

  Now, if the line contains { at the start the editor goes to the first
column after the {.

  If the line contains } at the start the editor will go to the same column
of the } and then will perform a <Backspace>. If the Real Tabs mode is
off, that's an unindent. *Note Real Tabs::.

  If the line starts with a C++ comment the effect is the same as in
Autoindent. *Note Autoindent::.

  If the line starts with a C comment the editor will try to skip the
comment and analyze the rest of the line, but if the comment doesn't end
on this line the editor will go to the column where the `/' is.

  If the line starts with `/' the editor goes to this column.

  If the line has more `(' than `)' the editor will go to the column of the
first non-blank after the first `('.

  If the line has more `)' than `(' the editor will search the line where the
number of parentheses is balanced, then will analyze this line. If the
whole line still generates an unbalanced situation the editor will go to
the first used column in the line that was found the first time. But if
this line lets all balanced the editor will take the first word on the
line and will use it as reference.

  At last, and according to the word found, the editor will use this word as
reference. The editor recognises the following keywords:

   * `do'
     - Action: +2 but not if ... ;

   * `if'
     - Action: +2 but not if ... ;

   * `for'
     - Action: +3 but not if ... ;

   * `else'
     - Action: +2

   * `case'
     - Action: +5

   * `while'
     - Action: +2 but not if ... ;

   * `switch'
     - Action: +2

   * `break'
     - Action: unindent

   * `return'
     - Action: unindent

   * `default'
     - Action: +5


  The numbers are how many spaces are added with reference to the first
letter of the word.  'not if ... ;' specified means that, if the line ends
with a semicolon, the editor will do the same as for Autoindent. *Note
Autoindent::. The unindent is performed with <Backspace>.

  Seasick? *Note Do you have more examples?::.

  Note: Some of these features were added in v0.2.14 of the editor based on a
suggestion of stud73@nortel.ca <Bradford L. Spencer> about the behaviour
of the mode on a line like this `printf("Num: %d",' with the rest of the
parameters on the next line.


File: editor.inf,  Node: Do you have more examples?,  Prev: Can you explain to me more about the behavior of this mode?,  Up: Intelligent C indent

5.5.2 Do you have more examples?
--------------------------------

  Well here are some examples. I used a strange convention, like this: if I
say type `a[ENTER]{', type the letter `a', then press `<ENTER>' and
finally press the `{' key.

Example 1: (Is similar to one explained before but is to show the
convention)

     Type:
     if (a==1)[ENTER]{[ENTER]a=2;[ENTER]b=3;[ENTER][BACKSPACE]}[ENTER]
     
     You'll get:
     
     if (a==1)
       {
        a=2;
        b=3;
       }
     [<--- cursor here]

Example 2: A switch/case example

     Type:
     switch(a)[ENTER]{[ENTER]case 1:[ENTER]a=2;[ENTER]b=3;[ENTER]break;
     [ENTER]case 2:[ENTER]b=5;[ENTER]break;[ENTER][BACKSPACE]}[ENTER]
     
     You'll get:
     
     switch(a)
       {
        case 1:
             a=2;
             b=3;
             break;
        case 2:
             b=5;
             break;
       }
     [<--- cursor here]

Example 3: A call to a function that takes a lot of parameters

     Type:
     printf([SPACE]"Num: %d",[ENTER]a[SPACE]);[ENTER]
     
     You'll get:
     
     printf( "Num: %d",
             a );
     [<--- cursor here]

Example 4: A lot of parentheses

     Type:
     if[SPACE]([SPACE](a==1)[SPACE]||[ENTER](b==2)[SPACE]||[ENTER]
     c[SPACE])[ENTER]
     
     You'll get:
     
     if ( (a==1) ||
          (b==2) ||
          c )
       [<--- cursor here]

Example 5: Comment trying to interfere part 1

     Type:
     /*-a-*/for[SPACE](x=1;x;--x)[ENTER]
     
     You'll get:
     
     /*-a-*/for (x=1;x;--x)
               [<--- cursor here]

Example 6: Comment trying to interfere part 2

     Type:
     for[SPACE](x=1;x;--x);[SPACE]//-b[ENTER]
     
     You'll get:
     
     for (x=1;x;--x); //-b
     [<--- cursor here]

 Note: Of course you can fool the editor but as you can see it is relatively
smart ;-).


File: editor.inf,  Node: Column cursor,  Next: Row cursor,  Prev: Intelligent C indent,  Up: Editing Modes

5.6 Column cursor
=================

  This setting enables an strange feature of the editor, when this mode is
on the column where the cursor is is highlighted. This feature is very good
to check if some part of your code is aligned.

  If you like this mode but is very uncomfortable to use all the time
contact me and if I get enough feedback I'll put this thing in a key to be
turned on/off quickly.


File: editor.inf,  Node: Row cursor,  Next: Match pair highlight,  Prev: Column cursor,  Up: Editing Modes

5.7 Row cursor
==============

  This setting is similar to the column cursor but acts on the row where the
cursor is. If you enable the two modes you'll get a cross on the screen
showing where the cursor is.


File: editor.inf,  Node: Match pair highlight,  Next: Match pair on the fly,  Prev: Row cursor,  Up: Editing Modes

5.8 Match pair highlight
========================

  This mode acts showing the pairs of (/), [/] and {/} on the fly. Each time
you type one of these symbols the editor will search the matching pair, if
the editor finds it and the match is on the screen both will be
highlighted, if the match is outside the screen the editor will inform the
position on the status line, and if there is no match the editor will
inform the situation in the status line too.

  That's very useful when you are typing complex parenthetical expressions or
a very nested code. You can use it jointly with the `cmcSearchStart',
`cmcSearchEnd', `cmcSearchOpPar', `cmcSearchClPar', `cmcSearchOpCor' and
`cmcSearchClCor' commands. (*Note Miscellaneous::).

  If you want to get highlight not only after typing but also when moving the
cursors you'll need to enable the `Match pair on the fly' option.  *Note
Match pair on the fly::.


File: editor.inf,  Node: Match pair on the fly,  Next: Do not wait to search the pair,  Prev: Match pair highlight,  Up: Editing Modes

5.9 Match pair on the fly
=========================

  This mode is very similar to the `Match pair highlight' mode. If you don't
know how it works please read the `Match pair highlight' section first.
*Note Match pair highlight::.

  The main difference is that this mode highlights the pair when the cursor
is over the character to search.

  The highlight is done half a second after you stop typing to avoid stoping
you. But if you have a fast machine, not just a 386, you can configure the
editor to do the search without waiting. *Note Do not wait to search the
pair::.


File: editor.inf,  Node: Do not wait to search the pair,  Next: Transparent Blocks,  Prev: Match pair on the fly,  Up: Editing Modes

5.10 Do not wait to search the pair
===================================

  This option works only when `Match pair on the fly' is enabled. When
enabled the editor doesn't wait to do the search of the complementary pair.
I think this could impact the performance of the scroll in very slow
machines and that's why is optional. *Note Match pair on the fly::.


File: editor.inf,  Node: Transparent Blocks,  Next: Optimal Fill,  Prev: Do not wait to search the pair,  Up: Editing Modes

5.11 Transparent Blocks
=======================

  When this mode is on you can see the syntax highlight of selected blocks.
Normally the selection affects the background and foreground colors, but
when using transparent blocks only the background is affected.


File: editor.inf,  Node: Optimal Fill,  Next: Wrap Words,  Prev: Transparent Blocks,  Up: Editing Modes

5.12 Optimal Fill
=================

  This mode was added for the people that uses ASCII 9 tabulators in your
code (*Note Real Tabs::). Normally the editor uses spaces to indent the
code or, in general, to fill any gap in the text. When you enable this
mode the editor will use as much tabs as possible to fill these gaps.
That's what the tabs users normally spects.


File: editor.inf,  Node: Wrap Words,  Next: Do not move the cursor on Paste,  Prev: Optimal Fill,  Up: Editing Modes

5.13 Wrap Words
===============

  Even when the editor is mainly intended for programmers I saw that some
users want it too.

  The word wrap added to the editor is a very simple one, it just inserts a
new line if you type a word beyond the wrap column, that's all. You won't
get automatic reformat functions like in text editors intended for love
letters (like the one from the Bill Gates company).

  The wrap column box is used to enter the column that triggers the wrap.


File: editor.inf,  Node: Do not move the cursor on Paste,  Next: Scroll Lock centers,  Prev: Wrap Words,  Up: Editing Modes

5.14 Do not move the cursor on Paste
====================================

  That's a global setting. When it's on the cursor isn't moved after
pasting. Normally the cursor is moved to the end of the pasted block, but
sometimes is better if the cursor isn't moved.


File: editor.inf,  Node: Scroll Lock centers,  Next: See Tabs,  Prev: Do not move the cursor on Paste,  Up: Editing Modes

5.15 Scroll Lock centers
========================

  When this mode is on the Scroll Lock key have an special meaning. If the
Scroll Lock led of your keyboard is on then the editor centers the current
line in the window. The effect is very strange but the advantage is that
you don't need to follow the movement of the line with your eyes because
it's ever in the same place.


File: editor.inf,  Node: See Tabs,  Next: Do not move inside tabs,  Prev: Scroll Lock centers,  Up: Editing Modes

5.16 See Tabs
=============

  In this mode the tabs are highlighted, two colors are used for this
purpose, one for even and the other for odd tabs. In this way you can
clearly see where a tab is located and the size of the tab. The colors can
be customized from the Colors menu option. *Note Colors::.

  This mode was introduced in v0.4.23 and is globally enabled by default.


File: editor.inf,  Node: Do not move inside tabs,  Next: Tab indents,  Prev: See Tabs,  Up: Editing Modes

5.17 Do not move inside tabs
============================

  In this mode the cursor can't be place inside a tab character. This
definition is fuzzy and confusing so here I'll try to explain it better.
One tab character can be expanded to one or more characters when displayed
in the screen. Normally you can place the cursor in any of the spaces that
belong to a tab character. I think this behavior is the best because you
are free to move the cursor to any place you want, but tab's users get
confused when they type and discover they had the cursor in the middle of
a tab. It produces a cursor jump. To avoid this kind of surprises a lot of
editors doesn't allow to position the cursor in these spaces, only in the
first space.

  This mode was introduced in v0.4.23 and is globally enabled by default.


File: editor.inf,  Node: Tab indents,  Next: Use indent size,  Prev: Do not move inside tabs,  Up: Editing Modes

5.18 Tab indents
================

  When `Use real tabs' option is disabled the editor will insert enough
spaces to move the cursor to the next tab-stop or indent position. But if
this option is enabled the editor will insert enough spaces to move the
cursor to the next hole in the line over the line where is currently
positioned. Confused? Sorry for my English, an example will clarify that:

This is a line over the line where you are

That's the line where the cursor is, at column one.

  After pressing TAB you'll get:

This is a line over the line where you are

     That's the line where the cursor is, at column one.

  Now can ask, Why this? Is that useful? The answer is that's very useful to
keep your code indented, experiment using that under a line with if, for,
`etc.'

  Another option is to indent like the Tab key but using a size different
than the tab size. This can be done disabling this option and enabling
`Use indent size'. *Note Use indent size::.


File: editor.inf,  Node: Use indent size,  Next: Do not purge spaces,  Prev: Tab indents,  Up: Editing Modes

5.19 Use indent size
====================

  When the `Real Tabs' and `Tab indents' options are disabled you can indent
with the tab key but using spaces. Some times people wants to use tabs of
eight spaces because this is the most common value for consoles and
printers but, at the same time, they want to indent by a different ammount
of spaces pressing tab. In this situation you must enable this option and
configure the indentation ammount in the `Indent size' box.


File: editor.inf,  Node: Do not purge spaces,  Next: Backspace unindents,  Prev: Use indent size,  Up: Editing Modes

5.20 Do not purge spaces
========================

  Normally the editor purges any space after the last visible character in a
line. That's very useful to save disk space and to avoid problems with end
of line continuation sequences, like in C language. But sometimes you
could want to avoid it for some special reason. Enabling this option the
editor won't try to remove extra spaces at the end of lines.


File: editor.inf,  Node: Backspace unindents,  Next: Column Markers,  Prev: Do not purge spaces,  Up: Editing Modes

5.21 Backspace unindents
========================

  When this option is enabled the <Backspace> deletes as many spaces as
necesary to move the cursor to the first used column of the previous line.
Basically it keeps the indentation. This is true only when all the
characters located at the left of the cursor are spaces or tabs.

  In versions older than 0.4.44 this option was implicitly enabled when the
`Real Tabs' option was disabled. When loading old desktop files the editor
enables/disables this option based in the `Real Tabs' option.


File: editor.inf,  Node: Column Markers,  Next: Syntax Highlight,  Prev: Backspace unindents,  Up: Editing Modes

5.22 Column Markers
===================

  Column markers highlight a column of text. This option is useful for
programming languages where the column is important or when you just need
to have some column positions as references.

  You can set various column markers at the same time, just enable this
option and enter a list of columns in the associated text box. The columns
should be separated by spaces and sorted incrementally. The editor will
format the list in this way.


File: editor.inf,  Node: Syntax Highlight,  Prev: Column Markers,  Up: Editing Modes

5.23 Syntax Highlight
=====================

  The editor can highlight the syntax of your code. The available modes are:

   * No highlight, all the code is with the same color.

   * C/C++ Highlight.

   * Pascal Highlight.

   * Clipper Highlight.

   * User defined. Including already defined for:
        * 4DOS batch files

        * 80x86 assembler (AT&T syntax)

        * 80x86 assembler (Intel syntax)

        * 8x51 assembler

        * Ada

        * BASIC

        * C/C++

        * Cascading Style Sheets version 2

        * Clipper 5.x

        * Command Line Errors File

        * Environment files

        * Fortran

        * HTML

        * Internationalization files (.po)

        * Java

        * Java Script

        * Makefiles

        * Menu files

        * Modula 2

        * Netwide Assembler (NASM)

        * Objetive C

        * Pascal

        * PDP11 assembler

        * Perl

        * PIC assembler (Microchip)

        * PLM/51

        * PMacros files

        * PostScript

        * Python

        * SDG format files

        * sLisp macros

        * SQL

        * The syntax highlight file itself

        * TCL/Tk

        * TeX

        * Texinfo

        * UNIX shell scripts


  The kind of highlight is chosen automatically using the extension of the
file. Additionally the editor supports Emacs like mode selection. Emacs
searchs the name of the editing mode in the first kilobyte and last three
kilobytes of text. The editing mode is delimited by `-*-' and the editor
will use it instead of the file extension to select the highlight.  That's
very usefull for files without extensions like the new C++ headers.  To
add even more flexibility I'm supporting another technique used by some
C++ headers from Silicon Graphics and Hewlett Packard, in these headers the
mode is located in the last lines unsing some special keywords.

  The editor also supports the convention used for UNIX script files. If a
file starts with `#!' this line indicates the program that must be
executed to interpret the script. The editor reads this line and extracts
the name of this program and searchs it in the `ShellScript' definition.

  The C/C++ highlight was designed for the GNU C compiler.

  The Pascal highlight was designed for the GNU Pascal compiler.

  The Clipper highlight was designed for the CA-Clipper 5 compiler.

  The highlight can be customized, *Note Syntax Highlight File::.


File: editor.inf,  Node: Syntax Highlight File,  Next: Pseudo Macros,  Prev: Editing Modes,  Up: Top

6 Syntax Highlight File
***********************

  The highlight can be customized editing the `syntaxhl.shl' file. You can
add syntax highlight to almost any kind of files, a good example is the
fact that the files used to configure the editor have your own syntax
highlight.

  The file declares the settings for each kind of files. Each declaration
ends with an `End' marker. The `#' acts as a start of command if it
appears in the first column.

  Important things you have to know to add a new syntax highlight:

   * In previous versions when adding a new highlight it should be added
     at the end of the file now it isn't mandatory.

   * The editor remmembers various settings of loaded files even after
     closing the file. It includes the syntax highlight, so if you add a
     new one or just add a new extension to the list and you open a file
     that you already opened the editor could remmember the last settings
     and don't use the new setting. In this case you must force it by hand.

   * If you feel that this new highlight can be used by other users send
     it to me and I'll include it in the next release. Many of the
     currently included syntax highlights were contributed by users.

  If you want to add some keywords to a language for personal use don't do it
in the `Keywords' section because you will need to edit this file each
time you install a new release of the editor. The editor provides another
file for it and also a nice user interface to add and delete words defined
by the user. *Note User Words::.

  The next sections covers the supported settings.

* Menu:

* AllowedInsideNames::
* CanStartAName::
* Case::
* CloseComment1::
* EmacsModes::
* EOLCInFirstCol::
* EOLCInFirstCol1::
* EOLCInFirstCol2::
* EOLCInFirstUse1::
* EOLCInFirstUse2::
* EOLComment1::
* Escape::
* EscapeAnywhere::
* Files::
* FullNameMatch::
* HexMarker::
* Keywords::
* Name::
* NameMatch::
* NoCheckNumbers::
* OpenComment1::
* PartialKeywords::
* PMacros::
* Preprocessor::
* RelaxNumberCheck::
* ShellScript::
* ShortString::
* SpecialSymbol::
* String1::
* Symbols1::
* Symbols2::
* UseInternal::


File: editor.inf,  Node: AllowedInsideNames,  Next: CanStartAName,  Prev: Syntax Highlight File,  Up: Syntax Highlight File

6.1 AllowedInsideNames
======================

  Some languages includes symbols inside names, you can list these symbols
here.  Normally the editor allows letters, digits and underscore. These
characters are allowed inside the names and not at the start of the name.
*Note CanStartAName::.


File: editor.inf,  Node: CanStartAName,  Next: Case,  Prev: AllowedInsideNames,  Up: Syntax Highlight File

6.2 CanStartAName
=================

  Some languages includes symbols at the start of names, you can list these
symbols here. Normally the editor allows letters and underscore. These
characters are allowed at the start of the name and not inside. *Note
AllowedInsideNames::.


File: editor.inf,  Node: Case,  Next: CloseComment1,  Prev: CanStartAName,  Up: Syntax Highlight File

6.3 Case
========

  When this setting is 1 all the keywords becomes case sensitive. If the
keywords aren't case sensitive don't use it.

  This should be declared as one of the first settings because it affects how
other definitions are loaded in memory. I suggest using it before `Name'
and `Files' and after the rest.


File: editor.inf,  Node: CloseComment1,  Next: EmacsModes,  Prev: Case,  Up: Syntax Highlight File

6.4 CloseComment1
=================

  Used to indicate the end of a multiline comment. The lenght is limited to
four characters. If the file format have two different ends use
`CloseComment2' for the second.

  For more information *Note Format of short syntax highlight definitions::.


File: editor.inf,  Node: EmacsModes,  Next: EOLCInFirstCol,  Prev: CloseComment1,  Up: Syntax Highlight File

6.5 EmacsModes
==============

  It indicates what Emacs modes will use this highlight. The modes must be
separated by commas. The modes are't case sensitive.

  As in Emacs the editor looks in the first kilobyte of text and in the last
three kilobytes for the mode delimited by `-*-'.

  The priority is as follows: `EmacsModes', `ShellScript' and finally the
extension (`Files'). *Note ShellScript::. *Note Files::.


File: editor.inf,  Node: EOLCInFirstCol,  Next: EOLCInFirstCol1,  Prev: EmacsModes,  Up: Syntax Highlight File

6.6 EOLCInFirstCol
==================

  When this setting is on the one line comments starts only if the sequence
of characters is present in the first column.


File: editor.inf,  Node: EOLCInFirstCol1,  Next: EOLCInFirstCol2,  Prev: EOLCInFirstCol,  Up: Syntax Highlight File

6.7 EOLCInFirstCol1
===================

  That's like EOLCInFirstCol but affects only the EOLComment1 and no both.
*Note EOLCInFirstCol::.


File: editor.inf,  Node: EOLCInFirstCol2,  Next: EOLCInFirstUse1,  Prev: EOLCInFirstCol1,  Up: Syntax Highlight File

6.8 EOLCInFirstCol2
===================

  That's like EOLCInFirstCol but affects only the EOLComment2 and no both.
*Note EOLCInFirstCol::.


File: editor.inf,  Node: EOLCInFirstUse1,  Next: EOLCInFirstUse2,  Prev: EOLCInFirstCol2,  Up: Syntax Highlight File

6.9 EOLCInFirstUse1
===================

  That's like EOLCInFirstCol1 but the starting sequence could be the first
non-blank character and not just located in the first column.  *Note
EOLCInFirstCol1::.


File: editor.inf,  Node: EOLCInFirstUse2,  Next: EOLComment1,  Prev: EOLCInFirstUse1,  Up: Syntax Highlight File

6.10 EOLCInFirstUse2
====================

  That's like EOLCInFirstCol2 but the starting sequence could be the first
non-blank character and not just located in the first column.  *Note
EOLCInFirstCol2::.


File: editor.inf,  Node: EOLComment1,  Next: Escape,  Prev: EOLCInFirstUse2,  Up: Syntax Highlight File

6.11 EOLComment1
================

  Used to indicate the start of a comment that ends at the end of the line.
The lenght is limited to four characters. If the file format have two
different ends use `EOLComment2' for the second.

  For more information *Note Format of short syntax highlight definitions::.


File: editor.inf,  Node: Escape,  Next: EscapeAnywhere,  Prev: EOLComment1,  Up: Syntax Highlight File

6.12 Escape
===========

  Indicates what character acts as escape character inside strings or to
concatenate lines.


File: editor.inf,  Node: EscapeAnywhere,  Next: Files,  Prev: Escape,  Up: Syntax Highlight File

6.13 EscapeAnywhere
===================

  Indicates that escape characters can be found anywhere, not just inside
strings or at the end of lines like in C.


File: editor.inf,  Node: Files,  Next: FullNameMatch,  Prev: EscapeAnywhere,  Up: Syntax Highlight File

6.14 Files
==========

  It indicates what extensions will use this highlight. The extensions must
be separated by commas. The extensions are case sensitive, be careful.

  The editor can also choose the highlight using the Emacs mode or the
program used to execute the file if that's an UNIX script.

  The priority is as follows: `EmacsModes', `ShellScript', `FullNameMatch',
`NameMatch' and finally the extension (`Files'). *Note ShellScript::.
*Note EmacsModes::. *Note FullNameMatch::.  *Note NameMatch::.


File: editor.inf,  Node: FullNameMatch,  Next: HexMarker,  Prev: Files,  Up: Syntax Highlight File

6.15 FullNameMatch
==================

  It can be used to indicate a regular expression to match the full path and
name of the file. If the expression matchs the editor will use this syntax
highlight.

  The regular expression must be in Perl format. You can learn about it from
any book about Perl.


File: editor.inf,  Node: HexMarker,  Next: Keywords,  Prev: FullNameMatch,  Up: Syntax Highlight File

6.16 HexMarker
==============

  This setting indicates what prefix is used for hexadecimal numbers. No
postfix supported yet. The lenght is limited to four characters.

  For more information *Note Format of short syntax highlight definitions::.


File: editor.inf,  Node: Keywords,  Next: Name,  Prev: HexMarker,  Up: Syntax Highlight File

6.17 Keywords
=============

  It can be used as many times as needed and is used to indicate the
reserved keywords of the language. The separator is the comma.


File: editor.inf,  Node: Name,  Next: NameMatch,  Prev: Keywords,  Up: Syntax Highlight File

6.18 Name
=========

  It sets the name of the syntax highlight. This name is used in the local
settings dialog (cmcSetLocalOptions).


File: editor.inf,  Node: NameMatch,  Next: NoCheckNumbers,  Prev: Name,  Up: Syntax Highlight File

6.19 NameMatch
==============

  It can be used to indicate a regular expression to match the name of the
file. If the expression matchs the editor will use this syntax highlight.

  The regular expression must be in Perl format. You can learn about it from
any book about Perl.


File: editor.inf,  Node: NoCheckNumbers,  Next: OpenComment1,  Prev: NameMatch,  Up: Syntax Highlight File

6.20 NoCheckNumbers
===================

  When this setting is on the numbers aren't highlighted.


File: editor.inf,  Node: OpenComment1,  Next: PartialKeywords,  Prev: NoCheckNumbers,  Up: Syntax Highlight File

6.21 OpenComment1
=================

  Used to indicate the start of a multiline comment. The lenght is limited
to four characters. If the file format have two different starts use
`OpenComment2' for the second.

  The maximun length is four characters, for more information about the
format: *Note Format of short syntax highlight definitions::.

* Menu:

* Format of short syntax highlight definitions::


File: editor.inf,  Node: Format of short syntax highlight definitions,  Prev: OpenComment1,  Up: OpenComment1

6.21.1 Format of short syntax highlight definitions
---------------------------------------------------

  All the characters after the equal sign are taked as part of the field.
Blank spaces after the equal sign are ignored, so `Field= //' is
equivalent to `Field=//'.

  As the field could start with spaces and spaces at the end of line are
invisible you can quote the test using the double quote sign. If you do it
the first character after the equal sign must be the double quote, if you
left an space like this: `Field= "' the double quote will be interpreted
as part of the field.

  When quoting text the back slash is the escape character, so it:
`Filed="\""' will be interpreted as asigning `"' to `Field'.


File: editor.inf,  Node: PartialKeywords,  Next: PMacros,  Prev: OpenComment1,  Up: Syntax Highlight File

6.22 PartialKeywords
====================

  When this setting is enabled the list of the editor will highlight partial
matchs of the keywords. For example, suppose a keyword is defined as `key'
and you type `keytable', in this case the editor will highlight the `key'
part of the word. This feature is experimental and makes the highlight
much more slow.


File: editor.inf,  Node: PMacros,  Next: Preprocessor,  Prev: PartialKeywords,  Up: Syntax Highlight File

6.23 PMacros
============

  Indicates the name of the pseudo macros file used for this kind of files.
Using different files for different formats you can assign common triggers
to different actions. For example, you can use i( to trigger an if() {}
else {} in C and an if then else in BASIC. *Note Pseudo Macros::.


File: editor.inf,  Node: Preprocessor,  Next: RelaxNumberCheck,  Prev: PMacros,  Up: Syntax Highlight File

6.24 Preprocessor
=================

  Indicates what symbol starts a preprocessor line.


File: editor.inf,  Node: RelaxNumberCheck,  Next: ShellScript,  Prev: Preprocessor,  Up: Syntax Highlight File

6.25 RelaxNumberCheck
=====================

  This is used when a number can start a name and that isn't a wrong
situation. Normally the editor takes it as a wrong number but when this
option is enabled the numbers check is relaxed and they aren't highlighted
as wrong values.


File: editor.inf,  Node: ShellScript,  Next: ShortString,  Prev: RelaxNumberCheck,  Up: Syntax Highlight File

6.26 ShellScript
================

  It indicates what scripts will be highlighted. You must indicate the names
of the programs associated with this script. The names are case sensitive.

  The editor looks for the `#!' characters at the start of the file, if
found the name of the program is extracted and searched in this list.

  The priority is as follows: `EmacsModes', `ShellScript' and finally the
extension (`Files'). *Note EmacsModes::. *Note Files::.


File: editor.inf,  Node: ShortString,  Next: SpecialSymbol,  Prev: ShellScript,  Up: Syntax Highlight File

6.27 ShortString
================

  Used to indicate the start and end of strings, used for small strings or
characters.  The string ends at the end of line if not explicitly closed.


File: editor.inf,  Node: SpecialSymbol,  Next: String1,  Prev: ShortString,  Up: Syntax Highlight File

6.28 SpecialSymbol
==================

  That's used to mark pairs of characters that forms a particular symbol
that will generate problems if the editor sees them as separated symbols.
It was created to avoid problems with `$#' in Perl and bash scripts and
with `@@' in Texinfo files. You can define more than one character here.

  The characters that can be combined with it are specified using the
`SpecialSymbolCont' definition.


File: editor.inf,  Node: String1,  Next: Symbols1,  Prev: SpecialSymbol,  Up: Syntax Highlight File

6.29 String1
============

  Used to indicate the start and end of strings, used for long strings. You
can specify more than one character in this case any of them can open or
close the string.

  The editor supports upto three diferent strings declared as `String1',
`String2' and `String3'.


File: editor.inf,  Node: Symbols1,  Next: Symbols2,  Prev: String1,  Up: Syntax Highlight File

6.30 Symbols1
=============

  Used to indicate what characters are allowed symbols, normally used for
boolean and arithmetic symbols.


File: editor.inf,  Node: Symbols2,  Next: UseInternal,  Prev: Symbols1,  Up: Syntax Highlight File

6.31 Symbols2
=============

  Used to indicate what characters are allowed symbols, normally used for
flow control and subindex symbols.


File: editor.inf,  Node: UseInternal,  Prev: Symbols2,  Up: Syntax Highlight File

6.32 UseInternal
================

  That's optional. When a highlight have this setting the editor will use
the internal routines and will ignore almost all the settings. Only the
extensions (*Note Files::) and pseudo macros (*Note PMacros::) settings
are used.

  The value assigned can be: 1 for GNU C highlight, 2 for standard Pascal
and 3 for Clipper.


File: editor.inf,  Node: Pseudo Macros,  Next: sLisp macros,  Prev: Syntax Highlight File,  Up: Top

7 Pseudo Macros
***************

  This feature is very useful to save some keystrokes. With this feature you
can create a lot of shortcuts to make your life easier.

* Menu:

* Please enlighten me - what is that?::
* How can I customize that?::


File: editor.inf,  Node: Please enlighten me - what is that?,  Next: How can I customize that?,  Prev: Pseudo Macros,  Up: Pseudo Macros

7.1 Please enlighten me - what is that?
=======================================

  So now, What's a Pseudo Macro? It's like a macro but is triggered by two
things: one the text behind the cursor, and two the `^Space' combination.

  And what's the result? The result is customizable, but by default there are
some predefined behaviours. For example, type in a C source window the
following two characters: `#i' and the press `^Space' ... (to create an
empty file with .c extension go to File|Open and type a new name, foo.c
for example).

  Surprised? I bet! You got: #include <.h> and the cursor just in the right
place to write the name of the header.

Now write the famous stdio word, press `<End>', then `<Enter>' twice and
now write the following two letters: `ma' and then `^Space' ...

  I bet this time you predicted better what will happen so you aren't so
surprised ;-). Anyways, Surprise! Now type `pr' and the magic keys and ...
`printf("");' appears. To end the happy history now type "Hello world!"
That's all. You wrote the hello world program at a very good speed.

  Now you know what I mean when I say pseudo-macros.


File: editor.inf,  Node: How can I customize that?,  Prev: Please enlighten me - what is that?,  Up: Pseudo Macros

7.2 How can I customize that?
=============================

  Is very easy. Each syntax highlight have your own pseudo macros file. Which
file belongs to each syntax highlight is indicated in the `syntaxhl.shl'
file. *Note Syntax Highlight File::. In the case of C/C++ the file is
called `cpmacros.pmc' and is located in the same directory where the rest
of the configuration files are installed. This file contains the
definitions for each pseudo macro that can be triggered in C/C++ files.
You can define as many pseudo macros as you want.

  Important: If you are using RHIDE consult the RHIDE documentation to know
where is stored the `cpmacros.pmc' file.

  The `cpmacros.pmc' file is a very good example and is self-explained but
I'll include here one example.

Trigger: "i("
Mode: 0,1,0,1,0
 "if (@0)\n"
 "  {@1\n"
   "}\n"
 "\belse\n"
 "  {@2\n"
   "}"

  The Trigger keyword defines the two letter behind the cursor that will
trigger the pseudo macro.

  The Mode keyword indicates the mode that the editor will use when inserting
the text. The modes are:

   * Overwrite               *Note Overwrite::

   * Autoindent              *Note Autoindent::

   * Use Tabs                *Note Real Tabs::

   * Persistent blocks       *Note Block modes::

   * Intelligent C indent    *Note Intelligent C indent::

  Each mode can be 0 or 1. The editor will return to the original mode after
expanding the pseudo macro. In this case the macro is expanded in the No
overwrite, autoindent, don't use tabs, the blocks are persistent and don't
be smart when indenting.

  The rest is the code to insert surrounded by ". You can use \b to indicate
backspace, \n for newline and \\ to indicate a simple \. If you want to
insert a @ you have to type it twice @@, because this character has a
special meaning (see below).

  After the insertion the cursor is positioned in the place marked with @0.
Don't forget to signal this point or the cursor will positioned at the
beginning of the file. The places marked with @1, @2 and @3 are saved in
the markers 7, 8 and 9.

  Currently I defined pseudo macros only for C/C++ and Perl. I did it in a
way that you can use the same pseudo macro for both languages. For example:
`#i' is expanded to `#include <.h>' for C/C++ files and to `request "";'
for Perl files. If you write similar pseudo macros for other languages
please send me the file and I'll add it to the next release.


File: editor.inf,  Node: sLisp macros,  Next: Calculator,  Prev: Pseudo Macros,  Up: Top

8 sLisp macros
**************

  The editor uses a lisp like language to store macros. The macros are
stored in a file called `macros.slp'.

  The macros can be assigned to keys (*Note How to configure the
keyboard::), selected from the `Macro' menu or from the menu. From the
`Macro' menu you can choose a macro from the list and then if you want to
repeat it make it with one keystroke.

  To add a new macro to the list you must edit the `macros.slp' file. You can
write the new macro by hand or you can use the `Macro' menu to record a
macro and then generate the sLisp code for this macro.

  To assign a macro to a menu entry you must edit the `menubind.smn'. The
macros are called using `cm(name)' where `name' is the name of the macro
you want to trigger.

* Menu:

* How to write a sLisp macro::
* How strings are parsed::
* Running programs with a macro::
* Editor specific commands::
* General sLisp commands::
* Writing macros that uses text filters::


File: editor.inf,  Node: How to write a sLisp macro,  Next: How strings are parsed,  Prev: sLisp macros,  Up: sLisp macros

8.1 How to write a sLisp macro
==============================

  I'll show an example and then I'll explain each part of the example:

     (defmacro 'Testing 1 2 3 ;-)'
      (eval
       (SendCommands cmcLineEnd)
       (InsertText (+ 'Hi!' CR 'How are you?'))
       (SendCommands cmcLineUp cmcLineEnd)
      )
     )

  That defines a macro called "Testing 1 2 3 ;-)" that will be expanded to
all the code inside of the `eval' sentence. The `SendCommands' command
sends one or more commands to the editor. The `InsertText' command inserts
one string in the code.  To concatenate strings use the `+' operator.
Currently you can use the `\n' escape sequence inside a string to indicate
a carriage return but in the example I'm showing how to concatenate
strings. The `CR' is a defined constant.


File: editor.inf,  Node: How strings are parsed,  Next: Running programs with a macro,  Prev: How to write a sLisp macro,  Up: sLisp macros

8.2 How strings are parsed
==========================

  sLisp strings can be delimited by single or double quotes (`"' or `'').
Currently both produce the same result but in the future it could change
to be similar to Perl.

  A few C escape sequences are supported inside strings. It means the `\ '
character have an special meaning. Here are the values supported:

   * n
     - Interpreted as: an OS dependant carriage return (rn for DOS and n
     for UNIX)

   * l
     - Interpreted as: simple line feed (ASCII 10 for DOS and UNIX)

   * r
     - Interpreted as: simple carriage return (ASCII 13 for DOS and UNIX)

   * t
     - Interpreted as: tab (ASCII 9 for DOS and UNIX)


  In strings that will be inserted in the text you should use the `\\n'
escape sequence to maintain compatibility across different OSs. You can
also use the build in constant called `CR'.


File: editor.inf,  Node: Running programs with a macro,  Next: Editor specific commands,  Prev: How strings are parsed,  Up: sLisp macros

8.3 Running programs with a macro
=================================

  There are a sLisp command called `RunProgram'. It takes an string as
parameter it can contain one or more programs separated by `;' or the
commands separator used by your command shell.

  The standard output and error are redirected and the results are sent to
the Message Window. If the program is a GNU tool and reported errors the
editor will parse these errors and allow you to directly jump to the file
and line where the error was reported.

To learn more about the message window *Note Message Window::.


File: editor.inf,  Node: Editor specific commands,  Next: General sLisp commands,  Prev: Running programs with a macro,  Up: sLisp macros

8.4 Editor specific commands
============================

  This section describes commands specifically related to files under
edition.

* Menu:

* AskString::
* ComplChoose::
* defmacro::
* EvalString::
* ForceUpdate::
* getenv::
* GetSelection::
* GetSyntaxAtCursor::
* InsertText::
* MessageBox::
* OpenFile::
* RunProgram::
* RunProgramRedir::
* SelectionExists::
* SendCommands::
* ShowInMessageWindow::
* ShowInStatusLine::
* WhichEditor::
* WordUnderCursor::


File: editor.inf,  Node: AskString,  Next: ComplChoose,  Prev: Editor specific commands,  Up: Editor specific commands

8.4.1 AskString
---------------

  (AskString TITLE MESSAGE)

  Pop-ups a dialog asking for user input, the text is returned as an sLisp
string variable. If the user cancels the string have zero length.


File: editor.inf,  Node: ComplChoose,  Next: defmacro,  Prev: AskString,  Up: Editor specific commands

8.4.2 ComplChoose
-----------------

  (ComplChoose OPTIONS DELIMITER [FLAGS])

  Brings a floating drop-down list with the options. The OPTIONS parameter
is a delimited string, the delimiter is specified by the DELIMITER
parameter.

  The function returns the option selected by the user or an empty string if
the user aborted.

  The list is sorted alphabetically, the user can choose the item using the
cursors or doing an incremental search. Only characters allowed for
reserved words are accepted, any symbol will choose the currently selected
item other characters will abort.

  The FLAGS parameter fine tunes the behavior of the routine. Currently only
one thing can be changed. By default the string returned contains the
character that produced the selection appended at the end of the string.
Passing 1 for FLAGS the character isn't concatenated.


File: editor.inf,  Node: defmacro,  Next: EvalString,  Prev: ComplChoose,  Up: Editor specific commands

8.4.3 defmacro
--------------

  (defmacro NAME EXPRESSION)

  Defines a new editor macro called NAME. When this macro is called the
EXPRESSION is evaluated. *Note How to write a sLisp macro::.


File: editor.inf,  Node: EvalString,  Next: ForceUpdate,  Prev: defmacro,  Up: Editor specific commands

8.4.4 EvalString
----------------

  (EvalString STRING)

  Executes the sLisp code contained in the STRING variable.


File: editor.inf,  Node: ForceUpdate,  Next: getenv,  Prev: EvalString,  Up: Editor specific commands

8.4.5 ForceUpdate
-----------------

  (ForceUpdate)

  It forces an update at this point of the macro. That's useful if you'll
stop for asking something or will spend some time and don't want to give
the impression you hanged the editor.


File: editor.inf,  Node: getenv,  Next: GetSelection,  Prev: ForceUpdate,  Up: Editor specific commands

8.4.6 getenv
------------

  (getenv NAME)

  This command returns the content of the environment variable called NAME.
Internal variables of the editor are also accessable. I the variable
doesn't exist an empty string is returned.


File: editor.inf,  Node: GetSelection,  Next: GetSyntaxAtCursor,  Prev: getenv,  Up: Editor specific commands

8.4.7 GetSelection
------------------

  (GetSelection)

  This command returns the selected text in the editor as a sLisp string.
*Note How to write a sLisp macro::.


File: editor.inf,  Node: GetSyntaxAtCursor,  Next: InsertText,  Prev: GetSelection,  Up: Editor specific commands

8.4.8 GetSyntaxAtCursor
-----------------------

  (GetSyntaxAtCursor)

  This command returns the syntax highlight flags for the cursor position.
That's very specific and can be used to know if the cursor is inside a
comment, string or preprocessor code.

  To understand how it works use the following macro and trigger it in many
places to see what you get:

     (defmacro 'Test edfWE'
       (eval
        (ShowInStatusLine (+ "" (GetSyntaxAtCursor)))
       )
     )

  The following table explains the flags returned:

   * edfComInside
     - Meaning: Inside an end of line comment

   * edfEndCom
     - Meaning: This line ends a multiline comment

   * edfEndCom2
     - Meaning: This line ends a multiline comment type 2

   * edfExtCom
     - Meaning: This line extends a multiline comment

   * edfExtCom2
     - Meaning: This line extends a multiline comment type 2

   * edfExtOneLineCom
     - Meaning: The end of line comment is extended to the next line

   * edfExtPrepro
     - Meaning: The preprocessor line follows in the next

   * edfExtString
     - Meaning: Inside a string

   * edfExtString2
     - Meaning: Inside a string type 2

   * edfExtString3
     - Meaning: Inside a string type 3

   * edfInsideCom
     - Meaning: Inside a multiline comment

   * edfInsideCom2
     - Meaning: Inside a multiline comment type 2

   * edfPrepro
     - Meaning: Inside preprocessor code

   * edfStartCom
     - Meaning: This line starts a multiline comment

   * edfStartCom2
     - Meaning: This line starts a multiline comment type 2

   * edfStartInCom
     - Meaning: This line started commented by the previous

   * edfStartInCom2
     - Meaning: This line started commented by the previous (type 2)

   * edfStartString
     - Meaning: This line startes inside a string

   * edfStartString2
     - Meaning: This line startes inside a string type 2

   * edfStartString3
     - Meaning: This line startes inside a string type 3


  Something very important is that the editor will analyze upto the cursor
position. So if the cursor is inside a string the editor will think this
line extends a string.


File: editor.inf,  Node: InsertText,  Next: MessageBox,  Prev: GetSyntaxAtCursor,  Up: Editor specific commands

8.4.9 InsertText
----------------

  (InsertText STRING [SELECTED [MOVE]])

  Inserts the STRING at the cursor's position. By default the cursor is moved
after the insertion and the inserted text isn't selected. If SELECTED is 1
the text is selected. If the MOVE parameter is 0 the cursor isn't moved
and if the parameter is 1 the action depends on the current editor's
setings.


File: editor.inf,  Node: MessageBox,  Next: OpenFile,  Prev: InsertText,  Up: Editor specific commands

8.4.10 MessageBox
-----------------

  (MessageBox MESSAGE [OPTIONS])

  Pop-ups a small dialog showing the MESSAGE to the user. The OPTIONS can
take the following values (use or to combine them):

   * edfMBCancelButton: put a `Cancel' button.

   * edfMBNoButton: put a `No' button.

   * edfMBOKButton: put an `Ok' button.

   * edfMBOKCancel: put an `Ok' and a `Cancel' button.

   * edfMBYesButton: put an `Yes' button.

   * edfMBYesNoCancel: put a `Yes', a `No' and a `Cancel' button.

   * edfMBConfirmation: use Confirmation as caption.

   * edfMBError: use Error as caption.

   * edfMBInformation: use Information as caption.

   * edfMBWarning: use Warning as caption.


File: editor.inf,  Node: OpenFile,  Next: RunProgram,  Prev: MessageBox,  Up: Editor specific commands

8.4.11 OpenFile
---------------

  (OpenFile STRING)

  Opens the file STRING in a window and gives the focus to it. If the file
doesn't exist it does nothing. Ever returns 1.


File: editor.inf,  Node: RunProgram,  Next: RunProgramRedir,  Prev: OpenFile,  Up: Editor specific commands

8.4.12 RunProgram
-----------------

  (RunProgram PROGRAM_NAME [[FLAGS] PARSER])

  Calls the desired program. You can pass more than one using the `;'
separator or any separator supported by your shell. Under DOS `;' is ok
even when command.com doesn't support it. The stderr and stdout are
redirected and captured by the message window of the editor.

  Use the operator `+' to concatenate strings and pass arguments.

  Using 1 for the FLAGS argument the editor will redraw the screen after
running the external program.

  The PARSER parameter tells the editor which error parser will be used to
parse the output of the external program. By default the GNU one is used.

  To learn more about the message window *Note Message Window::.


File: editor.inf,  Node: RunProgramRedir,  Next: SelectionExists,  Prev: RunProgram,  Up: Editor specific commands

8.4.13 RunProgramRedir
----------------------

  (RunProgramRedir PROGRAM_NAME [INPUT_TEXT])

  This function is similar to RunProgram, but the result isn't dumped to the
message window, instead the output of the program is returned as a string.

  Additionally you can specify a text to send to the standard input of the
program you are calling. With it is easy to call external filters. I
provide an example of how to replace a selected text with the output of an
external filter in the `macros.slp' file.

  Be careful, that's a very powerful command, but very dangerous too.


File: editor.inf,  Node: SelectionExists,  Next: SendCommands,  Prev: RunProgramRedir,  Up: Editor specific commands

8.4.14 SelectionExists
----------------------

  (SelectionExists)

  Returns 1 if some text is selected and the selection is visible.


File: editor.inf,  Node: SendCommands,  Next: ShowInMessageWindow,  Prev: SelectionExists,  Up: Editor specific commands

8.4.15 SendCommands
-------------------

  (SendCommands COMMAND ...)

  Sends all the listed commands to the editor. The editor commands are sLisp
constants that starts with `cmc'. These commands are the same explained in
the keyboard section as `cmcXXXXX'.


File: editor.inf,  Node: ShowInMessageWindow,  Next: ShowInStatusLine,  Prev: SendCommands,  Up: Editor specific commands

8.4.16 ShowInMessageWindow
--------------------------

  (ShowInMessageWindow STRING [CLEAR])

  Shows the desired string in the message window. That's a very good way to
show a result to the user.

  If the message window isn't selected or visible it gets the focus and
becomes visible. The optional parameter allows you to clean the contents of
the window. *Note Message Window::.


File: editor.inf,  Node: ShowInStatusLine,  Next: WhichEditor,  Prev: ShowInMessageWindow,  Up: Editor specific commands

8.4.17 ShowInStatusLine
-----------------------

  (ShowInStatusLine STRING)

  Shows the desired string in the status line of the current editor. Tabs
are converted to one space and the message stops in the first carriage
return or line feed. That's a very good way to show a result to the user.


File: editor.inf,  Node: WhichEditor,  Next: WordUnderCursor,  Prev: ShowInStatusLine,  Up: Editor specific commands

8.4.18 WhichEditor
------------------

  (WhichEditor [OPTION])

  This command takes one optional parameter and returns the file name of the
current file under edition.

  The optional parameter can be:

   * edfWEFull (0)
     - Meaning: Full name and path
        - Example: `c:/temp/test.txt'

   * edfWEFullNoExt (1)
     - Meaning: Same as 0 but without extension
        - Example: `c:/temp/test'

   * edfWEPath (2)
     - Meaning: Path for the file
        - Example: `c:/temp/'

   * edfWEDisk (3)
     - Meaning: Disk drive
        - Example: `c:'

   * edfWEExtension (4)
     - Meaning: File extension
        - Example: `.txt'

   * edfWENameNoExt (5)
     - Meaning: Name without extension
        - Example: `test'



File: editor.inf,  Node: WordUnderCursor,  Prev: WhichEditor,  Up: Editor specific commands

8.4.19 WordUnderCursor
----------------------

  (WordUnderCursor [MAX_LENGTH [OPTIONS]])

  This command takes one optional parameter and returns the word that's
located under the cursor. That's very useful for things like searching
help about the function the user is typing or things like that.

  The maximun length is optional and if you don't specify it 256 is used.
Values under 4 or over 32768 are adjusted to fit this range for security
issues.

  The OPTIONS parameter is 0 by default. Passing 1 the editor will return
the word located at the left of the cursor if the cursor is located in the
first character after this word.


File: editor.inf,  Node: General sLisp commands,  Next: Writing macros that uses text filters,  Prev: Editor specific commands,  Up: sLisp macros

8.5 General sLisp commands
==========================

  This section describes general sLisp commands that can be used from the
editor and the SDG configuration files.

* Menu:

* and::
* Operator &::
* cond::
* eval::
* gstr::
* if::
* left::
* length::
* not::
* Operator ~::
* or::
* Operator |::
* Operator +::
* right::
* setv::
* ShortFileName::
* sstr::
* strcasecmp::
* strcmp::
* strstr::
* strxlt::
* substr::
* Operator -::
* tostr::


File: editor.inf,  Node: and,  Next: Operator &,  Prev: General sLisp commands,  Up: General sLisp commands

8.5.1 and
---------

  (and EXP1 EXP2 ...)

  Returns the logical and of the provided expressions. The values are
evaluated from left to right. If at any point the result is zero then zero
is returned and the rest aren't evaluated.

  Each value is evaluated as one or zero.

  (and 20 "hello" 4)
  Returns 1.

  (and 20 4 2)
  Returns 1.


File: editor.inf,  Node: Operator &,  Next: cond,  Prev: and,  Up: General sLisp commands

8.5.2 Operator &
----------------

  (& EXP1 EXP2 ...)

  Returns the bitwise and of the provided expressions. The values are
evaluated from left to right. If at any point the result is zero then zero
is returned and the rest aren't evaluated.

  (and 20 4 2)
  Returns 0.

  (and 20 4)
  Returns 4.


File: editor.inf,  Node: cond,  Next: eval,  Prev: Operator &,  Up: General sLisp commands

8.5.3 cond
----------

  (cond CONDITION EXP [CONDITION2 EXP2 ...])

  Evaluates the conditions until one is true and returns the associated
expression. If all conditions are false returns 0.

  (cond 0 1 2 3)
  Returns 3.

  (cond 1 "Hi!" 0 "Bye")
  Returns "Hi!".


File: editor.inf,  Node: eval,  Next: gstr,  Prev: cond,  Up: General sLisp commands

8.5.4 eval
----------

  (eval EXPRESSION ...)

  This command is used to specify more than one action where just one is
spected.  Additionally you could construct sLisp code in a string and then
evaluate it. The expressions are evaluated from left to right, the last
evaluated result is returned.


File: editor.inf,  Node: gstr,  Next: if,  Prev: eval,  Up: General sLisp commands

8.5.5 gstr
----------

  (gstr STRING POSITION)

  Returns the POSITIONth character of the STRING. The first character is in
the 0 position.

  (gstr "hello" 4)
  Returns "o".


File: editor.inf,  Node: if,  Next: left,  Prev: gstr,  Up: General sLisp commands

8.5.6 if
--------

  (if CONDITION STATEMENT_1 [STATEMENT_2])

  It evaluates CONDITION if the boolean value of it is true then STATEMENT_1
is evaluates. If the value is false and if you provided a second statement
then STATEMENT_2 is evaluated. If the value is false and the second
statement is missing nothing is evaluated and the resulting value is 0.

  (if "hello" 4)
  Returns 4.

  (if "" 4 3)
  Returns 3.

  (if 0 4)
  Returns 0.


File: editor.inf,  Node: left,  Next: length,  Prev: if,  Up: General sLisp commands

8.5.7 left
----------

  (left STRING NUMBER)

  Returns the first NUMBER characters of the STRING.

  (left "hello" 4)
  Returns "hell".


File: editor.inf,  Node: length,  Next: not,  Prev: left,  Up: General sLisp commands

8.5.8 length
------------

  (length STRING)

  This function returns the number of characters in STRING.

  (length "hello")
  Returns 5.


File: editor.inf,  Node: not,  Next: Operator ~,  Prev: length,  Up: General sLisp commands

8.5.9 not
---------

  (not VALUE)

  Returns the VALUE negated.

  (not "hello")
  Returns 0.

  (not "")
  Returns 1.

  (not 1)
  Returns 0.


File: editor.inf,  Node: Operator ~,  Next: or,  Prev: not,  Up: General sLisp commands

8.5.10 Operator ~
-----------------

  (~ VALUE)

  Returns the VALUE negated (at bit level).

  (~ "hello")
  Returns 0.

  (~ "")
  Returns 0xFFFFFFFF.

  (~ 1)
  Returns -2.


File: editor.inf,  Node: or,  Next: Operator |,  Prev: Operator ~,  Up: General sLisp commands

8.5.11 or
---------

  (or EXP1 EXP2 ...)

  Returns the logical or of the provided expressions. The values are
evaluated from left to right. If any of them is non-zero the result is
non-zero and the rest aren't evaluated.

  (or 20 4 2)
  Returns 20.


File: editor.inf,  Node: Operator |,  Next: Operator +,  Prev: or,  Up: General sLisp commands

8.5.12 Operator |
-----------------

  (| EXP1 EXP2 ...)

  Returns the bitwise or of the provided expressions. The values are
evaluated from left to right. If at any point all bits are one the rest of
the values aren't evaluated.

  (or 20 4 2)
  Returns 22.


File: editor.inf,  Node: Operator +,  Next: right,  Prev: Operator |,  Up: General sLisp commands

8.5.13 Operator +
-----------------

  (+ VALUE1 VALUE2 ...)

  Returns the result of adding all the parameters. The type of the result is
determined by the first parameter. Currently you can't mix strings and
integers but if you bug me enough I'll add it. Adding strings means
concatenation.

  (+ "hel" "lo")
  Returns "hello".

  (+ 3 5)
  Returns 8.

  (+ "hello" 1)
  Gives syntax error.


File: editor.inf,  Node: right,  Next: setv,  Prev: Operator +,  Up: General sLisp commands

8.5.14 right
------------

  (right STRING NUMBER)

  Returns the last NUMBER characters of the STRING.

  (right "hello" 3)
  Returns "llo".


File: editor.inf,  Node: setv,  Next: ShortFileName,  Prev: right,  Up: General sLisp commands

8.5.15 setv
-----------

  (setv VARIABLE VALUE)

  Assigns VALUE to the VARIABLE. If the VARIABLE wasn't yet defined the
variable is created. The VARIABLE parameter must be a string representing
the name of the variable, it could be an expression.

  (setv "counter" 1)
  Assigns 1 to the COUNTER variable, if COUNTER doesn't exist counter is
created.

  (setv (+ "counter" "1") 1)
  Assigns 1 to the COUNTER1 variable, if COUNTER1 doesn't exist counter is
created.


File: editor.inf,  Node: ShortFileName,  Next: sstr,  Prev: setv,  Up: General sLisp commands

8.5.16 ShortFileName
--------------------

  (ShortFileName FILE_NAME)

  Returns the short name for FILE_NAME. That's useful only for Windows and
if long file names are supported. It can be used to pass a file name to an
external program that doesn't support long file names.


File: editor.inf,  Node: sstr,  Next: strcasecmp,  Prev: ShortFileName,  Up: General sLisp commands

8.5.17 sstr
-----------

  (sstr STRING POSITION VALUE)

  Changes the POSITIONth character of STRING by the first character of
VALUE. The first character is in the 0 position.

  (sstr "hello" 1 "a")
  Returns "hallo".


File: editor.inf,  Node: strcasecmp,  Next: strcmp,  Prev: sstr,  Up: General sLisp commands

8.5.18 strcasecmp
-----------------

  (strcasecmp S1 S2)

  This function is the same as `strcmp' but this version isn't case
sensitive. *Note strcmp::.


File: editor.inf,  Node: strcmp,  Next: strstr,  Prev: strcasecmp,  Up: General sLisp commands

8.5.19 strcmp
-------------

  (strcmp S1 S2)

  This function compares S1 and S2. The returned value is zero if the
strings are equal, a positive number if S1 comes after S2 in the ASCII
collating sequense, else a negative number.


File: editor.inf,  Node: strstr,  Next: strxlt,  Prev: strcmp,  Up: General sLisp commands

8.5.20 strstr
-------------

  (strstr STRING SEARCH [START_POS])

  Searchs the string SEARCH in the string STRING starting at START_POS
position. If START_POS is not provided the search is done from the
begining of STRING. The returned value is the offset of SEARCH in STRING
or -1 if the value wasn't found.

  (strstr "hello" "el")
  Returns 1.


File: editor.inf,  Node: strxlt,  Next: substr,  Prev: strstr,  Up: General sLisp commands

8.5.21 strxlt
-------------

  (strxlt STRING SEARCH REPLACE)

  Searchs for the character listed in SEARCH in the passed STRING replacing
each ocurrence by the correponding value found in REPLACE.

  (sstr "hello" "eo" "12")
  Returns "h1ll2".


File: editor.inf,  Node: substr,  Next: Operator -,  Prev: strxlt,  Up: General sLisp commands

8.5.22 substr
-------------

  (substr STRING POSITION [LEN])

  Returns LEN characters of STRING starting at the indicated POSITION.  If
LEN is omitted all the characters in the string starting at POSITION are
returned. The first character is in the 0 position.

  (substr "hello" 1 3)
  Returns "ell".

  (substr "hello" 2)
  Returns "llo".


File: editor.inf,  Node: Operator -,  Next: tostr,  Prev: substr,  Up: General sLisp commands

8.5.23 Operator -
-----------------

  (- VALUE1 VALUE2)

  Returns the result of substracting VALUE2 from VALUE1. Both variables must
be integer.

  (+ 20 3)
  Returns 17.


File: editor.inf,  Node: tostr,  Prev: Operator -,  Up: General sLisp commands

8.5.24 tostr
------------

  (tostr VALUE)

  Returns VALUE converted into a string.

  (tostr 2)
  Returns "2".


File: editor.inf,  Node: Writing macros that uses text filters,  Prev: General sLisp commands,  Up: sLisp macros

8.6 Writing macros that uses text filters
=========================================

  The sLisp language provides the commands needed to take a selected text
pass it to an external program and collect their output. You can finally
replace the original text by the new text. This kind of programs are
usually called filters. Some applications of this are complex recoding
using GNU recode, text formating, code indentation using GNU indent, `etc.'

  Here is an example contributed by Grzegorz Adam Hankiewicz. This macro can
be used to reformat e-mails without breaking the quoted text. It uses a
Python script that uses the fmt program to format text.

  This is the e-mail from Grzegorz:

     > SET
     > I added a second (optional) parameter to RunProgramRedir. It should
     > be a string containing the text to send to the external program.
     > I tested it with "recode ISO8859-1..html" and worked really nice. I
     > added an example to macros.slp.  I also created a MessageBox command,
     > in the example is used to indicate to the user that some text must be
     > selected first (the text that we'll send to the external filter).
     
     Grzegorz Adam Hankiewicz <gradha@terra.es>:
     
     Wow, that's cool!
     
     Enough for reformatting things. BTW, here's the first script I've
     used with the RunProgramRedir to reformat email messages so they keep
     identation levels and don't get out of the screen. The nice thing is
     that it's very small since it sits on top of the fmt command. In fact,
     this email is reformatted with it...

  The sLisp code to call it can be defined like it:

     (defmacro 'Format e-mail'
      (eval
       (setv "input" (GetSelection))
       (if (length input)
        ; Call the filter
        (eval
         (setv "output"
          (RunProgramRedir "email-fmt.py" input)
         )
         (SendCommands cmcCut)
         (InsertText output 1)
        )
        ; Ask the user to select something firt
        (MessageBox "Please select a text first")
       )
      )
     )

  And here is the Python script from Grzegorz:

     #!/usr/bin/env python
     
     import sys, string, popen2
     
     class LINE:
        pass
     
     identation = " \t><:"
     
     
     
     def detect_identation_characters(line):
        """Returns number of identation chars minus trailing whitespace."""
        count = 0
        for f in line:
           if f in identation: count = count + 1
           else: break
     
        return len(string.rstrip(line[:count])), count
     
     
     
     def initial_scan(line):
        """Add attributes to the lines."""
        l = LINE()
        l.line = line
        l.total_length = len(line)
        l.ident, l.soft_ident = detect_identation_characters(line)
        l.length = l.total_length - l.soft_ident
        return l
     
     
     
     def same_identation_lines(lines):
        """Returns number of lines with same identation level."""
        f = 1
        while f < len(lines):
           if lines[f].ident != lines[0].ident:
              break
           else:
              f = f + 1
     
        return f
     
     
     
     def reformat_lines(lines):
        """Dumps lines in list to fmt command."""
        assert lines
        length = max (75 - lines[0].ident, 20)
     
        stdout, stdin = popen2.popen2 ("fmt -w %d" % length)
        for f in lines:
           stdin.write ("%s\n" % string.strip (f.line[lines[0].ident:]))
        stdin.close()
     
        padding = ""
        if lines[0].ident: padding = "%s " % lines[0].line[:lines[0].ident]
        for f in stdout.readlines():
           sys.stdout.write ("%s%s" % (padding, f))
        stdout.close()
     
     
     
     if __name__ == "__main__":
        lines = map(initial_scan, map(string.rstrip, map(string.expandtabs,
                sys.stdin.readlines())))
     
        f = 0
        while f < len(lines):
           look = same_identation_lines(lines[f:])
           reformat_lines(lines[f:f+look])
           f = f + look


File: editor.inf,  Node: Calculator,  Next: How to contact me,  Prev: sLisp macros,  Up: Top

9 Calculator
************

  The calculator inside the editor was originally made by Laszlo Molnar.
Laszlo is a friend of mine from Hungary and is the author of the great DJP
progam (a djgpp exe's compressor and now UPX, the best EXE compressor in
all the categories). Currently the editor is compiled with a new
calculator with some advanced features. This new calculator have the same
features plus some interesting additions and was developed by Burton
Radons.

  The sources of the calculator are in the `parser.c' file. They are free
and you can use it for any purpose. There are three sources.

  Here is the documentation of the calculator written by Laszlo:

  The purpose of this program, to provide a simple but powerful 'calculator'
for programmers, to help with coding and debugging, where GDB's expression
evaluator is not enough.

  You may say "Hey, I can write a better one with `flex' and `bison'", and
you may be right. I can make a better one too. But it'll be 4-5 times
longer!  This calculator is only 10 kbytes of C code. What I think? It's
not that bad.

  The parser algorithm I use is called 'Operator Precedence Parsing' (I
translated this from Hungarian, so I may be wrong ;-). It works with
'operator precedence grammars' (a subset of LR(1) grammars), which means
that there can't be two non-terminating tokens next to each other on the
right side of your grammar rules. It's ideal for expression evaluation.

  With this parser you can use numbers, operators, parentheses and functions
like in C.

Here are the operators in decreasing precedence:

  1. `~' unary not `-' unary minus

  2. `**' power

  3. `*' multiplication `/' division `%' modulo

  4. `+' plus `-' binary minus

  5. `<<' shift left `>>' shift right

  6. `<' less than * `<=' less or equal than * `>' greater than * `>='
     greater or equal than *

  7. `==' equal to * `!=' different than *

  8. `&' bits and

  9. `^' bits xor

 10. `|' bits or

 11. `&&' logical and *

 12. `||' logical or *

 13. `?:' conditional *

  The operators marked with asterisk are available only in Burton's version.

  The calculator includes the following functions: `sin, cos, tan, sinh,
cosh, tanh, asin, acos, atan, log, log10, exp, abs, sqrt, ceil' and
`floor'.  They work as you expected.  Additionally the calculator provides
some radix conversion routines: `bin, oct, dec' and `hex'.

  The calculator uses doubles, but you can use numbers in the usual integer
formats also: 0x... for base 16, 0b... for base 2 and 0... for base 8.
The result of the calculation is displayed as a double for base 10, and
converted to long long format for the other radixes.

  In addition the new calculator have the following features:

  You can define variables just assigning a value to them. So if you enter
`x=5' you can use `x' in other calculation like this `x**2'. You can also
use the C/C++ assign plus operation. Post and pre increment and decrement
are also available.

  You can define functions like this `f(x)=x**2+2' so then entering `f(5)'
will give as result `27'.

  The C/C++ conditionals are available, so the following: `f(5)>=27 ? 6 : 2'
will give `6' assuming you defined `f(x)' as in the above example.

  You can separate operations with commas as in C. The result of the last
operation is the result of the compound.


File: editor.inf,  Node: How to contact me,  Next: Miscellaneous,  Prev: Calculator,  Up: Top

10 How to contact me
********************

  If you have any suggestions or bug report contact me at the address shown
in the author section. *Note About the Author::.

* Menu:

* Bugs::


File: editor.inf,  Node: Bugs,  Prev: How to contact me,  Up: How to contact me

10.1 Bugs
=========

  If you find a bug please contact me, the Undo thing is the most complex
one and I know that needs some work on it.

  When reporting a bug please don't tell me: Some times some strange thing
happend ... Try to find a pattern to the problem. What situation triggers
the problem? ... with which file(s)? Then send me the file and the
description.

  When sending to me a file UUEncode it to avoid problems related with the
e-mail.


File: editor.inf,  Node: Miscellaneous,  Next: Index,  Prev: How to contact me,  Up: Top

11 Miscellaneous
****************

* Menu:

* Clipboard::
* Time and date modifiers formats::
* Regular Expressions::
* Desktop Files::
* Text mode attributes::
* File Open::
* Message Window::
* Error messages from an external application::
* Mouse under Linux::
* Passing extra command line options::


File: editor.inf,  Node: Clipboard,  Next: Time and date modifiers formats,  Prev: Miscellaneous,  Up: Miscellaneous

11.1 Clipboard
==============

The clipboard is just another editor window where you put text using the
`Cut' and `Copy' commands to then retreive it with the `Paste' command.

Unlike the windows clipboard the one provided with the editor doesn't lose
the old contents when you copy to it. This approach have the important
advantage that you can copy text from various parts to the clipboard and
then paste all the text in one place and with just one operation. To do it
select the clipboard window and then select the text to paste, the editor
pastes the text selected in the clipboard window.

The disadvantage is that all the texts copied to the clipboard remains
there and if you are running in a machine with low memory and handling
huge files you can fill all the memory. To avoid it check the clipboard
size (with `Alt+0') and exit the program if it gets huge. That normally
isn't needed in machines with enough free disk that can be used as swap.


File: editor.inf,  Node: Time and date modifiers formats,  Next: Regular Expressions,  Prev: Clipboard,  Up: Miscellaneous

11.2 Time and date modifiers formats
====================================

This values are the same used by the `strftime' function of the standard
`libc'. The editor uses it in the printing module. *Note Print Setup::.

   * `%A'
     - Meaning: The full weekday name (`Friday')

   * `%a'
     - Meaning: The abbreviated weekday name (`Fri')

   * `%B'
     - Meaning: The full month name (`October')

   * `%b, %h'
     - Meaning: The abbreviated month name (`Oct')

   * `%C'
     - Meaning: Short for `%a %b %e %H:%M:%S %Y' (`Fri Oct  1 15:30:34
     1993')

   * `%c'
     - Meaning: Short for `%m/%d/%y %H:%M:%S' (`10/01/93 15:30:34')

   * `%e'
     - Meaning: The day of the month

   * `%D'
     - Meaning: Short for `%m/%d/%y' (`10/01/93')

   * `%d'
     - Meaning: The day of the month

   * `%H'
     - Meaning: The hour (0-24)

   * `%I'
     - Meaning: The hour (1-12)

   * `%j'
     - Meaning: The Julian day

   * `%k'
     - Meaning: The hour (0-24)

   * `%l'
     - Meaning: The hour (1-12)

   * `%M'
     - Meaning: The minutes

   * `%m'
     - Meaning: The month (1-12)

   * `%n'
     - Meaning: A newline (`n')

   * `%p'
     - Meaning: AM or PM (`PM')

   * `%R'
     - Meaning: Short for `%H:%M' (`15:30')

   * `%r'
     - Meaning: Short for `%I:%M:%S %p' (`03:30:35 PM')

   * `%S'
     - Meaning: The seconds

   * `%T, %X'
     - Meaning: Short for `%H:%M:%S' (`15:30:35')

   * `%t'
     - Meaning: A tab (`t')

   * `%U'
     - Meaning: The week of the year

   * `%W'
     - Meaning: The week of the year

   * `%w'
     - Meaning: The day of the week (0-6) (`5')

   * `%x'
     - Meaning: Short for `%m/%d/%y' (`10/01/93')

   * `%y'
     - Meaning: The year (00-99) of the century (`93')

   * `%Y'
     - Meaning: The year

   * `%Z'
     - Meaning: The timezone abbreviation (`EDT')

   * `%%'
     - Meaning: A percent symbol (`%')



File: editor.inf,  Node: Regular Expressions,  Next: Desktop Files,  Prev: Time and date modifiers formats,  Up: Miscellaneous

11.3 Regular Expressions
========================

The editor supports regular expressions in the search and replace commands,
here is a description of the syntax.

Regular expressions ("RE"s), as defined in POSIX 1003.2, come in two
forms: modern REs (roughly those of `egrep'; 1003.2 calls these _extended_
REs) and obsolete REs (roughly those of `ed'; 1003.2 _basic_ REs).
Obsolete REs mostly exist for backward compatibility in some old programs;
they will be discussed at the end.  1003.2 leaves some aspects of RE
syntax and semantics open; `(*)' marks decisions on these aspects that may
not be fully portable to other 1003.2 implementations.

A (modern) RE is one(*) or more non-empty(*) _branches_, separated by `|'.
It matches anything that matches one of the branches.

A branch is one(*) or more _pieces_, concatenated.  It matches a match for
the first, followed by a match for the second, etc.

A piece is an _atom_ possibly followed by a single(*) `*', `+', `?', or
_bound_.  An atom followed by `*' matches a sequence of 0 or more matches
of the atom.  An atom followed by `+' matches a sequence of 1 or more
matches of the atom.  An atom followed by `?' matches a sequence of 0 or 1
matches of the atom.

A _bound_ is `{' followed by an unsigned decimal integer, possibly
followed by `,' possibly followed by another unsigned decimal integer,
always followed by `}'.  The integers must lie between 0 and `RE_DUP_MAX'
(255(*)) inclusive, and if there are two of them, the first may not exceed
the second.  An atom followed by a bound containing one integer `i' and no
comma matches a sequence of exactly `i' matches of the atom.  An atom
followed by a bound containing one integer `i' and a comma matches a
sequence of `i' or more matches of the atom.  An atom followed by a bound
containing two integers `i' and `j' matches a sequence of `i' through `j'
(inclusive) matches of the atom.

An atom is a regular expression enclosed in `()' (matching a match for the
regular expression), an empty set of `()' (matching the null string(*)), a
_bracket expression_ (see below), `.' (matching any single character), `^'
(matching the null string at the beginning of a line), `$' (matching the
null string at the end of a line), a `\\' followed by one of the
characters `^.[$()|*+?{\\' (matching that character taken as an ordinary
character), a `\\' followed by any other character(*) (matching that
character taken as an ordinary character, as if the `\\' had not been
present(*)), or a single character with no other significance (matching
that character).  A `{' followed by a character other than a digit is an
ordinary character, not the beginning of a bound(*).  It is illegal to end
an RE with `\\'.

A _bracket expression_ is a list of characters enclosed in `[]'.  It
normally matches any single character from the list (but see below).  If
the list begins with `^', it matches any single character (but see below)
_not_ from the rest of the list.  If two characters in the list are
separated by `-', this is shorthand for the full _range_ of characters
between those two (inclusive) in the collating sequence, e.g. `[0-9]' in
ASCII matches any decimal digit.  It is illegal(*) for two ranges to share
an endpoint, e.g. `a-c-e'.  Ranges are very collating-sequence-dependent,
and portable programs should avoid relying on them.

To include a literal `]' in the list, make it the first character
(following a possible `^').  To include a literal `-', make it the first
or last character, or the second endpoint of a range.  To use a literal
`-' as the first endpoint of a range, enclose it in `[.' and `.]' to make
it a collating element (see below).  With the exception of these and some
combinations using `[' (see next paragraphs), all other special
characters, including `\\', lose their special significance within a
bracket expression.

Within a bracket expression, a collating element (a character, a
multi-character sequence that collates as if it were a single character,
or a collating-sequence name for either) enclosed in `[.' and `.]'  stands
for the sequence of characters of that collating element.  The sequence is
a single element of the bracket expression's list.  A bracket expression
containing a multi-character collating element can thus match more than
one character, e.g. if the collating sequence includes a `ch' collating
element, then the RE `[[.ch.]]*c' matches the first five characters of
"chchcc".

Within a bracket expression, a collating element enclosed in `[=' and `=]'
is an equivalence class, standing for the sequences of characters of all
collating elements equivalent to that one, including itself.  (If there
are no other equivalent collating elements, the treatment is as if the
enclosing delimiters were `[.' and `.]'.)  For example, if o and \o'o^'
are the members of an equivalence class, then `[[=o=]]', `[[=\o'o^'=]]',
and `[o\o'o^']' are all synonymous.  An equivalence class may not\(dg be
an endpoint of a range.

Within a bracket expression, the name of a _character class_ enclosed in
`[:' and `:]' stands for the list of all characters belonging to that
class.  Standard character class names are:

     alnum	digit	punct
     alpha	graph	space
     blank	lower	upper
     cntrl	print	xdigit

These stand for the character classes defined by `isalnum', `isdigit',
`ispunct', `isalpha', `isgraph' , `isspace' (`blank' is the same as
`space'), `islower', `isupper', `iscntrl', `isprint', and `isxdigit',
respectively.  A locale may provide others.  A character class may not be
used as an endpoint of a range.

There are two special cases(*) of bracket expressions: the bracket
expressions `[[:<:]]' and `[[:>:]]' match the null string at the beginning
and end of a word respectively.  A word is defined as a sequence of word
characters which is neither preceded nor followed by word characters.  A
word character is an `alnum' character (as defined by `isalnum' library
function) or an underscore.  This is an extension, compatible with but not
specified by POSIX 1003.2, and should be used with caution in software
intended to be portable to other systems.

In the event that an RE could match more than one substring of a given
string, the RE matches the one starting earliest in the string.  If the RE
could match more than one substring starting at that point, it matches the
longest.  Subexpressions also match the longest possible substrings,
subject to the constraint that the whole match be as long as possible,
with subexpressions starting earlier in the RE taking priority over ones
starting later.  Note that higher-level subexpressions thus take priority
over their lower-level component subexpressions.

Match lengths are measured in characters, not collating elements.  A null
string is considered longer than no match at all.  For example, `bb*'
matches the three middle characters of `abbbc',
`(wee|week)(knights|nights)' matches all ten characters of `weeknights',
when `(.*).*' is matched against `abc' the parenthesized subexpression
matches all three characters, and when `(a*)*' is matched against `bc'
both the whole RE and the parenthesized subexpression match the null
string.

If case-independent matching is specified, the effect is much as if all
case distinctions had vanished from the alphabet.  When an alphabetic that
exists in multiple cases appears as an ordinary character outside a
bracket expression, it is effectively transformed into a bracket
expression containing both cases, e.g. `x' becomes `[xX]'.  When it
appears inside a bracket expression, all case counterparts of it are added
to the bracket expression, so that (e.g.) `[x]' becomes `[xX]' and `[^x]'
becomes `[^xX]'.

No particular limit is imposed on the length of REs(*).  Programs intended
to be portable should not employ REs longer than 256 bytes, as an
implementation can refuse to accept such REs and remain POSIX-compliant.

Obsolete (_basic_) regular expressions differ in several respects.  `|',
`+', and `?' are ordinary characters and there is no equivalent for their
functionality.  The delimiters for bounds are `\\{' and `\\}', with `{'
and `}' by themselves ordinary characters.  The parentheses for nested
subexpressions are `\(' and `\)', with `(' and `)' by themselves ordinary
characters.  `^' is an ordinary character except at the beginning of the
RE or(*) the beginning of a parenthesized subexpression, `$' is an
ordinary character except at the end of the RE or(*) the end of a
parenthesized subexpression, and `*' is an ordinary character if it
appears at the beginning of the RE or the beginning of a parenthesized
subexpression (after a possible leading `^').  Finally, there is one new
type of atom, a _back reference_: `\\' followed by a non-zero decimal
digit _d_ matches the same sequence of characters matched by the _d_th
parenthesized subexpression (numbering subexpressions by the positions of
their opening parentheses, left to right), so that (e.g.) `\\([bc]\\)\\1'
matches `bb' or `cc' but not `bc'.


File: editor.inf,  Node: Desktop Files,  Next: Text mode attributes,  Prev: Regular Expressions,  Up: Miscellaneous

11.4 Desktop Files
==================

Each time you run the editor it searchs for a desktop file in the current
directory, if the editor can find any desktop file it searchs in the
directory indicated by the enviroment variable `SET_FILES'. If no desktop
files are found the editor uses internal default values. As you can see
creating a desktop file in the `%SET_FILES%' directory you'll indicate
default values. To create a desktop file in this directory just run the
editor in the directory, customize it and leave the editor. This feature
is very usefull to customize things like: Colors, Palette, Global editor
options, `etc.'

When you exit from the editor it saves all the settings, windows positions,
`etc.' to a desktop file stored in the current directory. Some prople
doesn't like it for this reason there is special mode where the editor
stores just one desktop file in the `%SET_FILES%' directory and not in
each directory. This approach have the advantage of saving disk space, but
you don't have local settings. If you use this approarch and want to keep
a local configuration in a directory use a project. *Note Project::. To
store only one centralized desktop file: *Note Editor General::.

The destop files have `.dst' as extension.


File: editor.inf,  Node: Text mode attributes,  Next: File Open,  Prev: Desktop Files,  Up: Miscellaneous

11.5 Text mode attributes
=========================

Text modes uses up to 16 colors for forground and 16 colors for background,
that's because the attributes of each character are stored in a 1 byte
allowing just 256 combinations. So four bits are dedicated to the
background color giving 16 combinations and the other four bits for the
foreground.

As we have only 16 colors there are a big chance that our predilect colors
aren't included. For this reason the VGA chip uses a palette of colors.
That means that these 16 colors aren't fixed and you can indicate what
color is. The values are just index values and you can assign to it any
color.

The VGA chip supports 18 bits per color giving 262,144 combinations. The
colors are created using the RGB (Red Green and Blue) methode. That's
simply because the CRT (Cathode Rays Tube) of the monitor uses this
methode to create the colors. You have 6 bits per component giving 64
different levels.

There are a little more of complexity added to the VGA card. The most
significant bit of the background is used to create blinking text. The
editor avoids this mode because it restricts the background combinations
to 8 and the editor doesn't need blinking text. The other funny thing of
the attribute is the most significant bit of the foreground color. It have
an special meaning even when using it doesn't reduce the number of
combinations. That means that this bit can select two things at the same
time. By now you'll be asking: What? This bit can be used to select a
second font, in this way you can have upto 512 different characters on the
screen. The editor can exploit it but you must understand that this bit is
used for the foreground color too. You can customize the palette to reduce
the number of foreground combinations to 8 just defining the 9th color
with the same value as the 0th color and so on. Then you can assign
different colors and different fonts to the things in the editor. You can
for example use a font for the menues and other for the text, or a font
for the code and other for the comments.  The editor goes even further
allowing different code page encodings for each font. I really never saw
it in any editor. You can use it for example to write your code using a
font with the ISO Latin 1 encoding (used by Linux and Windows in USA and
part of Europe) and have your comments in russian (using cyrilic
characters).

To learn how to customize the palette: *Note Color Palette::.
To learn how to assign colors to the things used in the editor: *Note
Colors::.
To learn how to select a font and an encoding: *Note Screen Options::.

File: editor.inf,  Node: File Open,  Next: Message Window,  Prev: Text mode attributes,  Up: Miscellaneous

11.6 File Open
==============

This dialog is used to select a file in various places. Even when it have
different names and purposes the dialog is ever the same.

The dialog is similar to the one used by most of the T/GUI programs so I'll
focus in special details and particularities.

All the files and directories are shown together, the directories have a
slash at the end. The current directory and selected file information is
shown at the bottom of the dialog.

To select a different disk, in DOS of course, you can simply type the drive
letter followed by a colon in the text input area and press <Enter>. You
can specify a mask in the text area too. Even under DOS a single asterisk
matchs with any filename, the *.* mask won't match with a filename that
lacks extension. You can use some asterisk and question marks in the mask,
they work like in most of the shells (DOS command.com included).
Additionally the mask can contain brackets, if your shell doesn't use it
and you never used it here is an example: `*.[ch]*' will match with
test.c, test.h, test.cc, test.cpp, `etc.' the brackets indicates the
posible characters that will match, in this case the first character after
the point should be c or h.
Pressing the down arrow while you are in the text input area you'll get a
list of the paths from where you selected files in past. That's very useful
when you load files from two or more directories very differents.

The `Home' changes the directory to the one from where you started the
editor, that's very useful when you navigate a lot and you want to quickly
return to the directory from where you started.

The `Options' button brings a dialog to configure the sorting options and
which files to exclude. These options are described in the following
subsections.

The editor remmembers the last place where you selected a file the last
time you used it. This information is stored in the desktop file. This
information is unique for the following selections: open a file to edit,
save a file, open a help file, save a block of text, open/save a project,
open an MP3 file and save an MP3 file. In this way you can be opening
files from a directory and saving newlly created files to another at the
same time without indicating the directory each time you open/save a file.

* Menu:

* Sort of the files and directories in the dialog::
* Files and directories excluded in the dialog::


File: editor.inf,  Node: Sort of the files and directories in the dialog,  Next: Files and directories excluded in the dialog,  Prev: File Open,  Up: File Open

11.6.1 Sort of the files and directories in the dialog
------------------------------------------------------

By default the sorting criteria is the following:

   * Names sorting is case insensitive.

   * Directories are listed after files.

   * The parent directory (`..') is the last entry.

   * Files starting with a dot are alphabetically listed.

But this can be customized with the `File open dialog' menu option or the
`Options' button of the dialog. It brings a dialog with the following
options:

   * Sort type: controls how the names are sorted.
        * Alphabetical: both, directories and file names, are mixed.

        * Directories first: the directories are listed first.

        * Files first: file names are listed first.

   * Case style: controls if the capital letters are different or not.
        * Capital letters goes first: the names are sorting according to
          the ASCII table

        * Case insensitive: the names are sorted lexicographically.

   * Parent directory: this option controls where is located the parent
     directory link (`..'). It doesn't affect the `Alphabetical' sorting.
        * First in the list: the parent is the first entry in the list.

        * At the end of the list: the parent is the last entry in the list.

   * Files starting with a dot: it controls how names starting with a dot
     are handled.
        * Normally sorted: they will be sorted alphabetically. As the
          `ASCII' code of a dot is less than the code that any letter they
          will be first in the list. That's quite annoying when you use
          UNIX style backups and they are also hidden files.

        * After the rest: they will be put at the end of the list.


The other options you'll find in this configuration dialog are described in
another subsection. *Note Files and directories excluded in the dialog::.

Something very important that you must know is how the <Shift> key is
interpreted.

When the sorting is `Alphabetical' and the list is case sensitive
(`Capital letters goes first') the shift key affects the case of the typed
letters so you must be careful, specially with the state of <Caps Lock>.

When the sorting isn't `Alphabetical' the <Shift> have an special meaning.
If you press shift while typing the first letter of the name then the
search will be done in the list of directories instead of the list of file
names. Once you are in one of the list the rest of the searchs are done in
this list. If the list is case sensitive it creates an interesting
conflict because you could need to press shift for some file name and then
the search will be done in the directories list. Don't forget it.


File: editor.inf,  Node: Files and directories excluded in the dialog,  Prev: Sort of the files and directories in the dialog,  Up: File Open

11.6.2 Files and directories excluded in the dialog
---------------------------------------------------

By default all names found are listed but this can be customized with the
`File open dialog' menu option or the `Options' button of the dialog. The
related options are:

   * Exclude files: controls which names are excluded.
        * Ending with tilde: names ending with a tilde are excluded. They
          usually belongs to UNIX backups. The editor generates these
          files when you configure it to generate UNIX style backups.

        * Ending with .bkp: names with the bkp extension are excluded. By
          default the editor generates backup files with this extension.

        * Starting with dot: names starting with a dot are excluded. In
          UNIX they are hidden files. The editor can be configured to
          create backup files as hidden files.


Personally I only exclude files with the bkp extension and sort files
starting with a dot so they appears at the end of the list.


File: editor.inf,  Node: Message Window,  Next: Error messages from an external application,  Prev: File Open,  Up: Miscellaneous

11.7 Message Window
===================

This window is used to show important information that you could want to
have at hand. Some examples are: the results of a printing operation, the
errors collected from an external program, the hits of the powered grep,
the tip of the day, the output of an external program, etc.

The message window doesn't have a number but can be accessed from the list
of windows (usually `Alt+0').

If the messages are errors or hits from grep you can use `Alt+F7' and
`Alt+F8' to quickly jump to the next/previous line. You can also just
select any of the error/hits. The errors are parsed by the editor according
to the user selection, many formats are supported by the editor and the
mechanism is configurable. See the next section for more information.

You can also delete entries in the message window pressing <Delete>. To
add more flexibility the content of the message window can be stored in a
file or copied to the clipboard, to do it just use the menu.

For more information about the behavior of the message window when you run
external programs *Note Run program (which one)::.


File: editor.inf,  Node: Error messages from an external application,  Next: Mouse under Linux,  Prev: Message Window,  Up: Miscellaneous

11.8 Error messages from an external application
================================================

Originally the editor only supported the GNU style. After many users asked
for support of other error formats Grzegorz Adam Hankiewicz suggested
doing it in a configurable way. So starting with v0.4.41 the editor can be
configured to parse the errors from an external application.

The configuration is stored in a file called `errors.cel'. The syntax is
very similar to the one used in the `syntaxhl.shl' file. All definitions
start with a `Name' declaration that indicates the name of the parsing
options and ends with an `End' marker.

The `Pattern' entry tells the editor how to parse a line containing an
error from the external program. The pattern is actually a Perl regular
expression. I used it because they are much more easy to learn than POSIX
regular expressions and they are much more clear to me.

The `File', `Line', `Severity' and `Description' entries indicates with
subexpression will contain the file name, line number, degree of severity
and description of the error. Note that actually only the first two are
used. If you don't know what a subexpression is here is a hint: look at
the parentheses.

The `EnterDirPat' is another Perl regex to indicate how make informs about
a directory change. `EnterDirDir' is the related subexpression.  That's
needed for GNU make, I guess other make tools have a similar mechanism.
`LeaveDir' is the pattern generated by make to indicate a change to the
parent directory.


File: editor.inf,  Node: Mouse under Linux,  Next: Passing extra command line options,  Prev: Error messages from an external application,  Up: Miscellaneous

11.9 Mouse under Linux
======================

When you are running in a console the mouse is captured by the editor and
you can't use it to copy/paste between consoles. If you want to do it you
must hold down the right <Alt> key and use the mouse as usually. Note this
can be altered if you changed the alt keys configuration.  *Note Alt key
configuration::. Additionally note that when you paste the keys are
interpreted as <Alt> plus the key you pressed so the carriage returns
aren't interpreted very well.

If you are using an X terminal the mouse isn't interactive because X
terminals only reports when the button is pressed and released but no when
it's moved. You can do all the normal operations but you won't get the
usual feedback.


File: editor.inf,  Node: Passing extra command line options,  Prev: Mouse under Linux,  Up: Miscellaneous

11.10 Passing extra command line options
========================================

You can pass extra command line options defining an environment variable.
It's called SET_CMDLINE. The editor will parse this variable and add it to
the options passed in the command line. These options will be interpreted
before the options passed in the command line.

Any space (including tabs) are interpreted as separators. If you need to
pass a file name containing spaces you must enclose the name with double
quotes.  If you need to pass a name containing a double quote you must
escape it using a back slash. Here are some examples:

   * ops 1
     - The editor interprets: two options "ops" and "1"

   * "ops 1"
     - The editor interprets: one option "ops 1"

   * ops"1
     - The editor interprets: one option containing a double quote inside


This mechanism can be used to set default options and avoid typing them all
the time. Another use is when you need to pass options to the editor and
you are using Eterm, in this case Eterm can't pass command line options so
you must use this mechanism.


File: editor.inf,  Node: Index,  Next: Index of key commands,  Prev: Miscellaneous,  Up: Top

12 Index
********

* Menu:

* Autoindent:                            Autoindent.
* Backspace behavior:                    Backspace unindents.
* backups, delete:                       Delete memorized backups.
* backups, delete at exit:               Quit.
* backups, enable/disable:               Editor General.
* backups, listing at the end:           Sort of the files and directories in the dialog.
* backups, memorize:                     Editor General.
* backups, not listing:                  Files and directories excluded in the dialog.
* backups, selective:                    Do not create backups for.
* backups, style:                        Editor General.
* Blocks:                                Blocks.
* Blocks - Rectangular:                  Rectangular Blocks.
* Blocks, transparent:                   Transparent Blocks.
* Bugs:                                  Bugs.
* centering the screen while typing:     Scroll Lock centers.
* closed windows, number:                Editor General.
* Column cursor:                         Column cursor.
* columns, marking:                      Column Markers.
* cpmacros.pmc:                          Pseudo Macros.
* cursor through tabs:                   Do not move inside tabs.
* desktop files, do not create:          Editor General.
* desktop files, style:                  Editor General.
* errors from external program:          Error messages from an external application.
* files, search:                         Search files under cursor in.
* How to contact me:                     How to contact me.
* Indent ammount:                        Use indent size.
* Indentation:                           Indentation.
* Insert and Delete:                     Insert and Delete.
* Intelligent C indent:                  Intelligent C indent.
* keys, names:                           Insert key name.
* macros from menu:                      sLisp macros.
* macros.slp:                            Assigning a sLisp macro.
* Match pair highlight:                  Match pair highlight.
* Match pair highlight all the time:     Match pair on the fly.
* menues and macros:                     sLisp macros.
* message window:                        Message Window.
* MIME quoted printable:                 Block quoted printable decode.
* Movement:                              Cursor movement.
* No real tabs:                          Tab indents.
* Overwrite:                             Overwrite.
* parse, errors:                         Error messages from an external application.
* Paste, do not move the cursor:         Do not move the cursor on Paste.
* Persistent Blocks:                     Block modes.
* Pseudo Macros:                         Pseudo Macros.
* quoted printable:                      Block quoted printable decode.
* Real Tabs:                             Real Tabs.
* Real Tabs when indenting:              Optimal Fill.
* redrawing the screen:                  Redraw screen.
* Row cursor:                            Row cursor.
* screen saver:                          Screen Saver.
* screen, redraw:                        Redraw screen.
* Spaces, purging at the end of line:    Do not purge spaces.
* syntax highlight extensions:           Syntax Highlight.
* syntax highlight, defining user words: User Words.
* syntax highlight, Emacs modes:         EmacsModes.
* syntax highlight, extensions:          Files.
* syntax highlight, matching a name:     NameMatch.
* syntax highlight, matching a path:     FullNameMatch.
* syntax highlight, paste mode:          Paste Emacs mode.
* syntax highlight, shell scripts:       ShellScript.
* Tab as spaces:                         Tab indents.
* TABs:                                  Real Tabs.
* TABs as spaces:                        Use indent size.
* TABs, highlight/see:                   See Tabs.
* TABs, indenting with:                  Optimal Fill.
* TABs, skipping/through:                Do not move inside tabs.
* tcedit.dst, do not create:             Editor General.
* tcedit.dst, style:                     Editor General.
* Unindenting with backspace:            Backspace unindents.
* Use Real Tabs:                         Real Tabs.
* windows, message:                      Message Window.
* wrapping:                              Wrap Words.


File: editor.inf,  Node: Index of key commands,  Prev: Index,  Up: Top

13 Index of key commands
************************

* Menu:

* Alternate case <none>:                 Blocks.
* Autoindent mode on/off <^O>:           Miscellaneous keyboard commands.
* Beginning of line <Home>:              Cursor movement.
* Bottom of file <^Q-C>:                 Cursor movement.
* Bottom of window <^Q-X>:               Cursor movement.
* Character left <Left arrow>:           Cursor movement.
* Character right <Right arrow>:         Cursor movement.
* cmcAltCase <From menu>:                Block alternate.
* cmcAltCase <none>:                     Blocks.
* cmcArbitraryIndent <From menu>:        Arbitrary indent.
* cmcBackSpace <Backspace>:              Insert and Delete.
* cmcCharLeft <Left arrow>:              Cursor movement.
* cmcCharRight <Right arrow>:            Cursor movement.
* cmcChooseMacro <From menu>:            Choose (Macro).
* cmcChoosePMacrosList <From menu>:      Pseudo Macro (menu).
* cmcClear <^Del> <1>:                   Clear.
* cmcClear <^Del>:                       Blocks.
* cmcCommentIndent <From menu>:          Comment indent.
* cmcCommentUnIndent <From menu>:        Comment unindent.
* cmcCompactBuffer <From menu> <1>:      Compact text.
* cmcCompactBuffer <From menu>:          Miscellaneous keyboard commands.
* cmcCopy <^Ins> <1>:                    Copy.
* cmcCopy <^Ins>:                        Blocks.
* cmcCopyBlock <^K-C>:                   Blocks.
* cmcCopyClipWin <From menu>:            Copy to Windows Clipoard.
* cmcCut <^K-Y>:                         Blocks.
* cmcCut <Shift+Del>:                    Cut.
* cmcCutClipWin <From menu>:             Copy to Windows Clipoard.
* cmcDelChar <Del>:                      Insert and Delete.
* cmcDelEnd <^Q-Y>:                      Insert and Delete.
* cmcDelLine <^Y>:                       Insert and Delete.
* cmcDelPrevWord <^Backspace>:           Insert and Delete.
* cmcDelStart <^Q-H>:                    Insert and Delete.
* cmcDelWord <^T>:                       Insert and Delete.
* cmcEndSelect <^K-K>:                   Blocks.
* cmcExpandAllTabs <From menu> <1>:      Expand all tabs.
* cmcExpandAllTabs <From menu>:          Miscellaneous keyboard commands.
* cmcExpandCode <^Space>:                Miscellaneous keyboard commands.
* cmcFind <^Q-F>:                        Find.
* cmcFirstLineInScreen <^Q-E>:           Cursor movement.
* cmcGenCodeForMacro <From menu>:        Generate Code.
* cmcGoBeginBlock <^Q-B>:                Blocks.
* cmcGoEndBlock <^Q-K>:                  Blocks.
* cmcGoEndOfWord <>:                     Cursor movement.
* cmcGotoEditorLine <^J> <1>:            Go to line.
* cmcGotoEditorLine <^J>:                Miscellaneous keyboard commands.
* cmcGotoMarkn <^Q n*>:                  Miscellaneous keyboard commands.
* cmcHideSelect <^K-H>:                  Blocks.
* cmcIndentBlk <^K-Tab>:                 Indentation.
* cmcIndentBlk <From menu>:              Indent one tab or gap.
* cmcIndentBlkOne <^K-I>:                Indentation.
* cmcIndentBlkOne <From menu>:           Indent one space.
* cmcIndentMode <^O>:                    Miscellaneous keyboard commands.
* cmcInsertKeyName <From menu>:          Insert key name.
* cmcInsMode <Ins>:                      Insert and Delete.
* cmcInvertCase <From menu>:             Block invert.
* cmcInvertCase <none>:                  Blocks.
* cmcJumpToFunction <Alt+F2>:            Jump to function.
* cmcJumpToPrototype <From menu>:        Jump to prototype.
* cmcLastLineInScreen <^Q-X>:            Cursor movement.
* cmcLineDown <Down arrow>:              Cursor movement.
* cmcLineEnd <End>:                      Cursor movement.
* cmcLineStart <Home>:                   Cursor movement.
* cmcLineUp <Up arrow>:                  Cursor movement.
* cmcMarkLine <^K-L>:                    Blocks.
* cmcMarkWord <^K-T>:                    Blocks.
* cmcMoveBlock <^K+V>:                   Blocks.
* cmcNewLine <Enter>:                    Insert and Delete.
* cmcPageDown <PgDn>:                    Cursor movement.
* cmcPageUp <PgUp>:                      Cursor movement.
* cmcPaste <Shift+Ins> <1>:              Paste.
* cmcPaste <Shift+Ins>:                  Blocks.
* cmcPasteClipWin <From menu>:           Paste from Windows Clipboard.
* cmcPasteEmacsMode <From menu>:         Paste Emacs mode.
* cmcPlayMacro <^F10> <1>:               Play (Macro).
* cmcPlayMacro <^F10>:                   Miscellaneous keyboard commands.
* cmcPopCursorPos <From menu>:           Pop cursor position.
* cmcProfileEditor <From menu>:          Profile Editor.
* cmcPushCursorPos <From menu>:          Push cursor position.
* cmcPutMarkn <^K n*>:                   Miscellaneous keyboard commands.
* cmcQuotedPrintDecode <From menu>:      Block quoted printable decode.
* cmcReadBlock <^K-R>:                   Blocks.
* cmcRecordMacro <Shift+F10> <1>:        Record (Macro).
* cmcRecordMacro <Shift+F10>:            Miscellaneous keyboard commands.
* cmcRedo <From menu>:                   Redo.
* cmcRepeatMacro <Shift+F3>:             Repeat (Macro).
* cmcReplace <^Q-A>:                     Replace.
* cmcReplaceSelect <Shift+^Ins>:         Blocks.
* cmcRunEnter_sLisp <From menu>:         Enter code to run.
* cmcRunSel_sLisp <From menu>:           Run selected code.
* cmcSave <F2>:                          Save.
* cmcSaveAs <From menu>:                 Save as.
* cmcSaveAsUNIX <From menu>:             Save as UNIX.
* cmcSaveSameTime <From menu>:           Save with same time.
* cmcScrollDown <^Z>:                    Cursor movement.
* cmcScrollUp <^W>:                      Cursor movement.
* cmcSearchAgain <^L>:                   Search again.
* cmcSearchClCor <Shift+^]>:             Miscellaneous keyboard commands.
* cmcSearchClPar <Shift+^0>:             Miscellaneous keyboard commands.
* cmcSearchComplement <^Q ESC>:          Miscellaneous keyboard commands.
* cmcSearchEnd <^]>:                     Miscellaneous keyboard commands.
* cmcSearchOpCor <Shift+^[>:             Miscellaneous keyboard commands.
* cmcSearchOpPar <Shift+^9>:             Miscellaneous keyboard commands.
* cmcSearchStart <^[>:                   Miscellaneous keyboard commands.
* cmcSelLength <^Q-L>:                   Blocks.
* cmcSelRectCopy <^K-Shift+C> <1>:       Copy (Rectangle).
* cmcSelRectCopy <^K-Shift+C>:           Rectangular Blocks.
* cmcSelRectCut <^K-Shift+T>:            Cut (Rectangle).
* cmcSelRectCut <^K-ShiftT>:             Rectangular Blocks.
* cmcSelRectDel <^K-Shift+L> <1>:        Clear (Rectangle).
* cmcSelRectDel <^K-Shift+L>:            Rectangular Blocks.
* cmcSelRectEnd <^K-Shift+K> <1>:        End (Rectangle).
* cmcSelRectEnd <^K-Shift+K>:            Rectangular Blocks.
* cmcSelRectHide <^K-Shift+H> <1>:       Hide (Rectangle).
* cmcSelRectHide <^K-Shift+H>:           Rectangular Blocks.
* cmcSelRectMove <^K+Shift+V>:           Rectangular Blocks.
* cmcSelRectMove <^K-Shift+M>:           Move (Rectangle).
* cmcSelRectPaste <^K-Shift+P> <1>:      Paste (Rectangle).
* cmcSelRectPaste <^K-Shift+P>:          Rectangular Blocks.
* cmcSelRectStart <^K-Shift+B> <1>:      Start (Rectangle).
* cmcSelRectStart <^K-Shift+B>:          Rectangular Blocks.
* cmcSelRectToLower <>:                  Rectangular Blocks.
* cmcSelRectToLower <From menu>:         To lower (Rectangle).
* cmcSelRectToUpper <>:                  Rectangular Blocks.
* cmcSelRectToUpper <From menu>:         To upper (Rectangle).
* cmcSetGlobalOptions <Alt+G> <1>:       Set Global.
* cmcSetGlobalOptions <Alt+G>:           Miscellaneous keyboard commands.
* cmcSetLocalOptions <Alt+L> <1>:        Set Local.
* cmcSetLocalOptions <Alt+L>:            Miscellaneous keyboard commands.
* cmcSmartIndent <^Tab>:                 Indentation.
* cmcSmartUnIndent <Shift+^Tab>:         Indentation.
* cmcStartSelect <^K-B>:                 Blocks.
* cmcStopMacro <Alt+F10> <1>:            Stop (Macro).
* cmcStopMacro <Alt+F10>:                Miscellaneous keyboard commands.
* cmcTextEnd <^Q-C>:                     Cursor movement.
* cmcTextStart <^Q-R>:                   Cursor movement.
* cmcToggleCharCase <From menu>:         Character toggle.
* cmcToLower <^K-O>:                     Blocks.
* cmcToLower <From menu>:                Block to lower.
* cmcToUpper <^K-M>:                     Blocks.
* cmcToUpper <From menu>:                Block to upper.
* cmcUndo <Alt+BackSpace>:               Undo.
* cmcUndo <Alt+Backspace>:               Miscellaneous keyboard commands.
* cmcUnIndentBlk <^K-Shift+Tab>:         Indentation.
* cmcUnIndentBlk <From menu>:            Unindent one tab or gap.
* cmcUnIndentBlkOne <^K-U>:              Indentation.
* cmcUnIndentBlkOne <From menu>:         Unindent one character.
* cmcWhichFunctionIs <>:                 Name current function.
* cmcWordLeft <^Left arrow>:             Cursor movement.
* cmcWordRight <^Right arrow>:           Cursor movement.
* cmcWriteBlock <^K-W>:                  Blocks.
* cmeAnotherInfView <From menu>:         Another InfView.
* cmeCalculator <Alt+F4>:                Calculator (command/menu).
* cmeCascade <From menu>:                Cascade.
* cmeClose <Alt+F3>:                     Close.
* cmeClosePrj <From menu>:               Close (Project).
* cmeConfRunCommand <From menu>:         Run program (which one).
* cmeDeleteBkps <From menu>:             Delete memorized backups.
* cmeDosShell <From menu>:               Shell.
* cmeEdGralOptions <From menu>:          Editor General.
* cmeEditDeflOpts <From menu>:           Default global edition.
* cmeEditKeyBind <From menu>:            Key assignment.
* cmeEditNoBkp <From menu>:              Do not create backups for.
* cmeEditPalette <From menu>:            Color Palette.
* cmeEditUserWords <From menu>:          User Words.
* cmeExportAsHTML <From menu>:           Export as HTML.
* cmeFileOpenOptions <From menu>:        File open dialog.
* cmeGrepDialog <From menu>:             Grep.
* cmeHTMLAccents <From menu>:            Convert accents to tags.
* cmeHTMLTag2Accent <From menu>:         Convert tags to accents.
* cmeIncludeList <From menu>:            Search files under cursor in.
* cmeInfView <F1>:                       InfView.
* cmeKbBackDefault <From menu>:          Back to defaults.
* cmeKeyPadBehavior <From menu>:         Key pad behavior.
* cmeListWin <Alt+0>:                    List.
* cmeNew <From menu>:                    New.
* cmeNext <F6>:                          Next (Window).
* cmeOpen <F3>:                          Open.
* cmeOpenPrj <From menu>:                Open (Project).
* cmeOpenROCopy <From menu>:             Open Read-only copy.
* cmePrev <Shift+F6>:                    Previous (Window).
* cmePrintEditor <From menu>:            Print.
* cmeQuit <Alt+X>:                       Exit.
* cmeQuitDelete <Alt+Q>:                 Quit.
* cmeReDraw <From menu>:                 Redraw screen.
* cmeRemapCodePage <From menu>:          Remap code page.
* cmeResize <^F5>:                       Size/move.
* cmeRunCommand <Ctrl+F9>:               Run program.
* cmeScreenSaverOpts <From menu>:        Screen Saver.
* cmeSDG <F9>:                           SDG.
* cmeSDGDialog <From menu>:              SDG Options.
* cmeSeeScanCodes <From menu>:           Consult scan codes.
* cmeSetColors <From menu>:              Colors.
* cmeSetScreenOps <From menu>:           Screen Options.
* cmeSetUpAltKeys <From menu>:           Setup Alt keys.
* cmeSetUpPrinter <From menu>:           Print Setup.
* cmeShowClip <From menu>:               Show clipboard.
* cmeSyntaxHelp <^F1>:                   Search (Syntax help).
* cmeSyntaxHelpFiles <From menu>:        Files to search (Syntax help).
* cmeSyntaxHelpOps <From menu>:          Options (Syntax help).
* cmeTile <From menu>:                   Tile.
* cmeTipOfTheDay <From menu>:            Tip of the day.
* cmeUserScreen <Alt+F5>:                User Screen.
* cmeZoom <F5>:                          Zoom.
* Compact the text using tabs <From menu>: Miscellaneous keyboard commands.
* Convert all tabs in spaces <From menu>: Miscellaneous keyboard commands.
* Convert to lowercase <>:               Rectangular Blocks.
* Convert to Lowercase <^K-O>:           Blocks.
* Convert to uppercase <>:               Rectangular Blocks.
* Convert to Uppercase <^K-M>:           Blocks.
* Copy the selected block <^K-C>:        Blocks.
* Copy to Clipboard <^Ins>:              Blocks.
* Copy to special Clipboard <^K-Shift+C>: Rectangular Blocks.
* Delete block <^Del>:                   Blocks.
* Delete block <^K-Shift+L>:             Rectangular Blocks.
* Delete block and copy it to an special Clipboard <^K-ShiftT>: Rectangular Blocks.
* Delete block and copy it to the Clipboard <^K-Y>: Blocks.
* Delete character to left <Backspace>:  Insert and Delete.
* Delete line <^Y>:                      Insert and Delete.
* Delete the character under cursor <Del>: Insert and Delete.
* Delete to end of line <^Q-Y>:          Insert and Delete.
* Delete to start of line <^Q-H>:        Insert and Delete.
* Delete word at left <^T>:              Insert and Delete.
* Delete word at right <^Backspace>:     Insert and Delete.
* End of line <End>:                     Cursor movement.
* End of the word <>:                    Cursor movement.
* Find place marker <^Q n*>:             Miscellaneous keyboard commands.
* Goto Line <^J>:                        Miscellaneous keyboard commands.
* Hide/Show block <^K-H>:                Blocks.
* Hide/Show block <^K-Shift+H>:          Rectangular Blocks.
* Indent block <^K-Tab>:                 Indentation.
* Indent block one position adding a space <^K-I>: Indentation.
* Insert line <Enter>:                   Insert and Delete.
* Insert mode on/off <Ins>:              Insert and Delete.
* Invert case <none>:                    Blocks.
* Line down <Down arrow>:                Cursor movement.
* Line up <Up arrow>:                    Cursor movement.
* Mark line <^K-L>:                      Blocks.
* Mark word <^K-T>:                      Blocks.
* Move block <^K+Shift+V>:               Rectangular Blocks.
* Move block <^K+V>:                     Blocks.
* Move to beginning of block <^Q-B>:     Blocks.
* Move to end of block <^Q-K>:           Blocks.
* Page down <PgDn>:                      Cursor movement.
* Page up <PgUp>:                        Cursor movement.
* Paste from Clipboard <Shift+Ins>:      Blocks.
* Paste from special Clipboard <^K-Shift+P>: Rectangular Blocks.
* Play a macro <^F10>:                   Miscellaneous keyboard commands.
* PMacro's Trigger <^Space>:             Miscellaneous keyboard commands.
* Read block from disk <^K-R>:           Blocks.
* Replace the block by the Clipboard block <Shift+^Ins>: Blocks.
* Report the length of the block <^Q-L>: Blocks.
* Scroll the screen one line down <^Z>:  Cursor movement.
* Scroll the screen one line up <^W>:    Cursor movement.
* Search the ( where the cursor is <Shift+^9>: Miscellaneous keyboard commands.
* Search the ) where the cursor is <Shift+^0>: Miscellaneous keyboard commands.
* Search the [ where the cursor is <Shift+^[>: Miscellaneous keyboard commands.
* Search the ] where the cursor is <Shift+^]>: Miscellaneous keyboard commands.
* Search the close curly bracket where the cursor is <^]>: Miscellaneous keyboard commands.
* Search the complementary pair <^Q ESC>: Miscellaneous keyboard commands.
* Search the open curly bracket where the cursor is <^[>: Miscellaneous keyboard commands.
* Set beginning of block <^K-B>:         Blocks.
* Set beginning of block <^K-Shift+B>:   Rectangular Blocks.
* Set end of block <^K-K>:               Blocks.
* Set end of block <^K-Shift+K>:         Rectangular Blocks.
* Set marker <^K n*>:                    Miscellaneous keyboard commands.
* Set the default options (Not in RHIDE) <Alt+G>: Miscellaneous keyboard commands.
* Set the options of the current window (Not in RHIDE) <Alt+L>: Miscellaneous keyboard commands.
* Smart Indent block <^Tab>:             Indentation.
* Smart Unindent block <Shift+^Tab>:     Indentation.
* Start recording a macro <Shift+F10>:   Miscellaneous keyboard commands.
* Stop recording a macro <Alt+F10>:      Miscellaneous keyboard commands.
* Top of file <^Q-R>:                    Cursor movement.
* Top of window <^Q-E>:                  Cursor movement.
* Undo <Alt+Backspace>:                  Miscellaneous keyboard commands.
* Unindent block <^K-Shift+Tab>:         Indentation.
* Unindent block one character - not an x position <^K-U>: Indentation.
* Word left <^Left arrow>:               Cursor movement.
* Word right <^Right arrow>:             Cursor movement.
* Write block to disk <^K-W>:            Blocks.



Tag Table:
Node: Top394
Node: Introduction1158
Node: Copying2710
Node: What is SETs Editor?3665
Node: About the Author4547
Node: Available commands and keys assignments5830
Node: Conventions6616
Node: Cursor movement7836
Node: Insert and Delete9648
Node: Blocks11063
Node: Block modes13513
Node: Selecting with the mouse or Shift14617
Node: Using the mouse15013
Node: Using the Shift key15415
Node: Indentation15790
Node: Rectangular Blocks18166
Node: Miscellaneous keyboard commands19679
Node: Keyboard configuration21612
Node: How to configure the keyboard22329
Node: Assigning a sequence of commands24123
Node: Assigning a sLisp macro24907
Node: Alt key configuration25338
Node: Restoring the default keyboard assignments26149
Node: Consulting scan codes26593
Node: Pull-down menues26959
Node: File27492
Node: Open27873
Node: New28494
Node: Open Read-only copy28953
Node: Save29434
Node: Save as29843
Node: Save as UNIX30303
Node: Save with same time30928
Node: Print31490
Node: Print Setup32268
Node: Shell34591
Node: Quit34886
Node: Exit35375
Node: Edit35700
Node: Undo36154
Node: Redo36390
Node: Cut36611
Node: Copy36849
Node: Paste37060
Node: Show clipboard37332
Node: Clear37552
Node: Set Local37778
Node: Set Global38390
Node: Expand all tabs39222
Node: Compact text39552
Node: Copy to Windows Clipoard39941
Node: Paste from Windows Clipboard40516
Node: Push cursor position41001
Node: Pop cursor position41438
Node: Case (Menu)41862
Node: Block to upper42208
Node: Block to lower42447
Node: Character toggle42691
Node: Block invert42984
Node: Block alternate43250
Node: Search43596
Node: Find43903
Node: Regular Expressions Options45957
Node: Replace47342
Node: Search again48008
Node: Name current function48242
Node: Jump to function48653
Node: Jump to prototype50294
Node: Go to line50813
Node: Macro51041
Node: Record (Macro)51399
Node: Stop (Macro)51677
Node: Play (Macro)51901
Node: Choose (Macro)52172
Node: Repeat (Macro)52495
Node: Generate Code52909
Node: Run selected code53330
Node: Enter code to run53589
Node: Pseudo Macro (menu)53884
Node: Rectangle54442
Node: Start (Rectangle)54963
Node: End (Rectangle)55305
Node: Hide (Rectangle)55652
Node: Copy (Rectangle)55977
Node: Paste (Rectangle)56439
Node: Cut (Rectangle)56809
Node: Clear (Rectangle)57188
Node: Move (Rectangle)57509
Node: To upper (Rectangle)57857
Node: To lower (Rectangle)58445
Node: Windows59010
Node: Size/move59327
Node: Zoom60071
Node: Tile60446
Node: Cascade60650
Node: Next (Window)60837
Node: Previous (Window)61386
Node: Close61955
Node: List62209
Node: User Screen63356
Node: Tool&Ops63583
Node: Options64080
Node: Colors64643
Node: Color Palette66038
Node: Editor General66994
Node: Screen Saver72022
Node: SDG Options73600
Node: Run program (which one)74552
Node: Keyboard80183
Node: Key assignment80534
Node: Setup Alt keys80958
Node: Key pad behavior81283
Node: Back to defaults81855
Node: Consult scan codes82236
Node: Screen Options82514
Node: User Words84834
Node: Default global edition86251
Node: File open dialog90208
Node: Do not create backups for90519
Node: Search files under cursor in91720
Node: Calculator (command/menu)92392
Node: SDG92670
Node: Run program92963
Node: Grep93235
Node: HTML Accents95674
Node: Convert accents to tags96024
Node: Convert tags to accents96505
Node: Export as HTML96891
Node: Insert key name98050
Node: Remap code page98497
Node: Profile Editor99526
Node: Redraw screen99842
Node: Paste Emacs mode100155
Node: Block quoted printable decode100778
Node: Un/Indent block101257
Node: Indent one space101664
Node: Unindent one character101948
Node: Indent one tab or gap102258
Node: Unindent one tab or gap102631
Node: Comment indent103010
Node: Comment unindent103522
Node: Arbitrary indent104149
Node: Delete memorized backups104487
Node: Project104988
Node: Open (Project)106336
Node: Close (Project)106591
Node: Help106777
Node: InfView106945
Node: Another InfView107162
Node: Tip of the day107772
Node: Syntax help108929
Node: Options (Syntax help)109550
Node: Files to search (Syntax help)110723
Node: Search (Syntax help)111983
Node: Editing Modes112343
Node: Overwrite113090
Node: Autoindent113402
Node: Real Tabs113782
Node: Persistent Blocks115650
Node: Intelligent C indent115928
Node: Can you explain to me more about the behavior of this mode?118069
Node: Do you have more examples?121202
Node: Column cursor123198
Node: Row cursor123713
Node: Match pair highlight124033
Node: Match pair on the fly125060
Node: Do not wait to search the pair125775
Node: Transparent Blocks126269
Node: Optimal Fill126658
Node: Wrap Words127134
Node: Do not move the cursor on Paste127731
Node: Scroll Lock centers128124
Node: See Tabs128626
Node: Do not move inside tabs129122
Node: Tab indents130039
Node: Use indent size131134
Node: Do not purge spaces131718
Node: Backspace unindents132246
Node: Column Markers132910
Node: Syntax Highlight133507
Node: Syntax Highlight File136035
Node: AllowedInsideNames138271
Node: CanStartAName138690
Node: Case139077
Node: CloseComment1139504
Node: EmacsModes139894
Node: EOLCInFirstCol140425
Node: EOLCInFirstCol1140701
Node: EOLCInFirstCol2140961
Node: EOLCInFirstUse1141222
Node: EOLCInFirstUse2141547
Node: EOLComment1141870
Node: Escape142286
Node: EscapeAnywhere142510
Node: Files142768
Node: FullNameMatch143387
Node: HexMarker143791
Node: Keywords144144
Node: Name144402
Node: NameMatch144633
Node: NoCheckNumbers145015
Node: OpenComment1145225
Node: Format of short syntax highlight definitions145748
Node: PartialKeywords146579
Node: PMacros147045
Node: Preprocessor147471
Node: RelaxNumberCheck147671
Node: ShellScript148064
Node: ShortString148639
Node: SpecialSymbol148934
Node: String1149475
Node: Symbols1149872
Node: Symbols2150106
Node: UseInternal150347
Node: Pseudo Macros150790
Node: Please enlighten me - what is that?151140
Node: How can I customize that?152416
Node: sLisp macros154957
Node: How to write a sLisp macro156014
Node: How strings are parsed156938
Node: Running programs with a macro157955
Node: Editor specific commands158680
Node: AskString159290
Node: ComplChoose159616
Node: defmacro160581
Node: EvalString160883
Node: ForceUpdate161109
Node: getenv161454
Node: GetSelection161794
Node: GetSyntaxAtCursor162075
Node: InsertText164322
Node: MessageBox164817
Node: OpenFile165606
Node: RunProgram165889
Node: RunProgramRedir166742
Node: SelectionExists167440
Node: SendCommands167696
Node: ShowInMessageWindow168080
Node: ShowInStatusLine168589
Node: WhichEditor169011
Node: WordUnderCursor169864
Node: General sLisp commands170597
Node: and171193
Node: Operator &171644
Node: cond172038
Node: eval172399
Node: gstr172786
Node: if173049
Node: left173575
Node: length173802
Node: not174031
Node: Operator ~174271
Node: or174540
Node: Operator |174891
Node: Operator +175250
Node: right175745
Node: setv175983
Node: ShortFileName176549
Node: sstr176924
Node: strcasecmp177248
Node: strcmp177499
Node: strstr177830
Node: strxlt178274
Node: substr178614
Node: Operator -179056
Node: tostr179327
Node: Writing macros that uses text filters179523
Node: Calculator183696
Node: How to contact me187114
Node: Bugs187399
Node: Miscellaneous187935
Node: Clipboard188331
Node: Time and date modifiers formats189407
Node: Regular Expressions191411
Node: Desktop Files200550
Node: Text mode attributes201922
Node: File Open204643
Node: Sort of the files and directories in the dialog207159
Node: Files and directories excluded in the dialog210001
Node: Message Window211161
Node: Error messages from an external application212416
Node: Mouse under Linux214087
Node: Passing extra command line options214992
Node: Index216199
Node: Index of key commands220600

End Tag Table
