Table of Contents
*****************

 RHIDE
1 Introduction
  1.1 Copying
  1.2 Installing RHIDE
  1.3 What is RHIDE?
  1.4 Requirements
  1.5 Getting started
    1.5.1 Supported languages
    1.5.2 Debugging RHIDE
  1.6 The program GPR2MAK
  1.7 The program GPREXP
  1.8 First steps with RHIDE
    1.8.1 What are these so called projects
    1.8.2 Creating your first project
  1.9 Environment variables
    1.9.1 Setting environment variables for RHIDE
    1.9.2 Where to store the environment file
2 General information about how RHIDE works
  2.1 Known suffixes
  2.2 Syntax of arguments
  2.3 Running under Windows 95
  2.4 Running under OS/2
  2.5 Running under Windows NT
  2.6 Running under GNU/Linux
  2.7 General use of RHIDE
    2.7.1 Creating a program
      2.7.1.1 Creating a program without a project
    2.7.2 Creating a library
    2.7.3 Saving/Loading the options
3 Description of the pull-down menus
  3.1 System menu
    3.1.1 About
    3.1.2 Bug report
    3.1.3 FSDB
    3.1.4 GREP
    3.1.5 GDB
    3.1.6 Refresh Desktop
    3.1.7 Calculator
    3.1.8 Puzzle
    3.1.9 Calender
    3.1.10 ASCII table
  3.2 File
    3.2.1 Open
    3.2.2 New
    3.2.3 Save
    3.2.4 Save as
    3.2.5 Save all
    3.2.6 DOS Shell
    3.2.7 Exit
  3.3 Edit
    3.3.1 Undo
    3.3.2 Redo
    3.3.3 Cut
    3.3.4 Copy
    3.3.5 Paste
    3.3.6 Show Clipboard
    3.3.7 Clear
    3.3.8 Copy to Windows clipboard
    3.3.9 Paste from Windows clipboard
    3.3.10 Expand all tabs
    3.3.11 Compact text
    3.3.12 Macro
      3.3.12.1 Record
      3.3.12.2 Stop
      3.3.12.3 Play
  3.4 Search
    3.4.1 Find
    3.4.2 Replace
    3.4.3 Search again
    3.4.4 Goto line
    3.4.5 Jump to function
    3.4.6 Next message
    3.4.7 Previous message
  3.5 Run
    3.5.1 Run
    3.5.2 Step over
    3.5.3 Trace into
    3.5.4 Go to cursor
    3.5.5 Program reset
      3.5.5.1 Main function
    3.5.6 Arguments
  3.6 Compile menu
    3.6.1 Compile
    3.6.2 Make
    3.6.3 Link
    3.6.4 Build all
  3.7 Debug
    3.7.1 Set/Reset Breakpoint
    3.7.2 Evaluate/Modify
    3.7.3 Watch an expression
    3.7.4 Breakpoints
    3.7.5 Disassembler window
    3.7.6 Call stack
    3.7.7 List of Functions
  3.8 Project
    3.8.1 Open project
    3.8.2 Close project
    3.8.3 Add item
    3.8.4 Delete item
    3.8.5 Local options
    3.8.6 Includes
    3.8.7 Main targetname
    3.8.8 Primary file
    3.8.9 Clear dependencies
    3.8.10 Delete rebuildable files
    3.8.11 Write Makefile
  3.9 Options
    3.9.1 Directories
      3.9.1.1 Include directories
      3.9.1.2 Library directories
      3.9.1.3 Object directories
      3.9.1.4 Sources directories
      3.9.1.5 Standard headers
    3.9.2 C/C++-Compiler
      3.9.2.1 Warnings
      3.9.2.2 Optimizations
      3.9.2.3 Debugging
      3.9.2.4 C options
      3.9.2.5 CXX options
      3.9.2.6 Pascal options
      3.9.2.7 Fortran options
      3.9.2.8 How to toggle these flags
    3.9.3 Libraries
    3.9.4 Linker options
    3.9.5 Compiler options
    3.9.6 Environment
      3.9.6.1 Colors
      3.9.6.2 Editor options
      3.9.6.3 Preferences
      3.9.6.4 Mouse options
      3.9.6.5 Reserved words
      3.9.6.6 Pascal reserved words
      3.9.6.7 C-Flags
      3.9.6.8 CXX-Flags
      3.9.6.9 Pascal-Flags
      3.9.6.10 Fortran-Flags
      3.9.6.11 Warning-Flags
      3.9.6.12 Debugging-Flags
      3.9.6.13 Optimization-Flags
      3.9.6.14 User words
    3.9.7 Save options
    3.9.8 Load options
  3.10 Windows
    3.10.1 Size/move
    3.10.2 Zoom
    3.10.3 Tile
    3.10.4 Cascade
    3.10.5 Next
    3.10.6 Previous
    3.10.7 Close
    3.10.8 List
    3.10.9 Project
    3.10.10 UserScreen
  3.11 Help
    3.11.1 Help
    3.11.2 RHIDE Help index
    3.11.3 Syntax help submenu
      3.11.3.1 Syntax help
      3.11.3.2 Files to search
      3.11.3.3 Options for searching
    3.11.4 Index for syntax help
    3.11.5 libc reference
    3.11.6 Help about help
4 Detailed description of some parts of RHIDE
  4.1 Selecting a window
  4.2 How the editor works
    4.2.1 Erasing commands
    4.2.2 Cursor moving commands
    4.2.3 Text selecting and searching commands
    4.2.4 Block commands
    4.2.5 Other commands
  4.3 Some hints and problems
    4.3.1 Problems with automatic dependencies
  4.4 Project window
    4.4.1 Items of your project
    4.4.2 Open a project item
    4.4.3 Dependencies of project item
    4.4.4 Local options for a project item
  4.5 Builtin compiler specs
  4.6 Builtin variables
  4.7 Change the defaults of RHIDE
  4.8 Message window
  4.9 Syntax highlighting
  4.10 Checking the dependencies
  4.11 What is Turbo Vision
  4.12 How the dialogs work
  4.13 Defining macros
  4.14 The INFO Viewer
  4.15 RCS and RHIDE
5 Debugging with RHIDE
  5.1 Limitations of the integrated debugger
  5.2 Dual display debugging
  5.3 Using the integrated debugger
    5.3.1 Stepping through the source code
    5.3.2 Evaluating the contents of variables
    5.3.3 Watching the contents of variables
  5.4 Problems with C++ programs
  5.5 Using Breakpoints
    5.5.1 Setting a breakpoint
    5.5.2 Modifying and setting a breakpoint
    5.5.3 Problems with breakpoints
6 Debugging with RHGDB
7 Some FAQs
8 Index
9 Index of key commands


 RHIDE
******

1 Introduction
**************

1.1 Copying
===========

RHIDE is copyright by Robert Ho"hne.  Parts of RHIDE are copyright by other
people as noted in the source files.

  This program is free software; you can redistribute it and/or modify   it
under the terms of the GNU General Public License as published by   the Free
Software Foundation; either version 2 of the License, or   (at your option)
any later version.

  This program is distributed in the hope that it will be useful,   but WITHOUT
ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the   GNU General Public License for
more details.

  You should have received a copy of the GNU General Public License   along
with this program; if not, write to the Free Software   Foundation, Inc., 59
Temple Place - Suite 330, Boston, MA 02111-1307, USA.

additional permission:

 As a special additional permission, the library librhuti which is  in the
source tree of the RHIDE sources in the librhuti/  subdirectory can be
distributed alone freely without any  restrictions.  It is not limited to use
under the terms of the GPL  or LGPL.  For more information see the file
COPYING.RHU in that  subdirectory.

Non-binding request

If you distribute RHIDE together with other products it would be nice, if you
could give me a note about it so I'll be informed. Of course you can send me
a copy of the distribution medium but this is not required.

For contacting the author send electronic mail to

<robert.hoehne@gmx.net>

or paper mail to

Robert Ho"hne
Am Berg 3
D - 09573 Dittmannsdorf
Germany

1.2 Installing RHIDE
====================

There are two archives

`rhide??b.zip'
     This contains the executables and the documentation for RHIDE running on
     DJGPP

`rhide-?.?-1.i386.rpm'
     This is a RPM package with the binaries of RHIDE for GNU/Linux.
     (currently they are built on SuSE 8.0)

`rhide??s.zip'
     This contains the sources of RHIDE for DJGPP.

`rhide-?.?-1.src.rpm'
     This is a RPM package with the sources of RHIDE for GNU/Linux.


NOTE: The sources for the GNU/Linux and DJGPP versions are of course in its
core the same, there are only differences in the directory structure and
maybe in some preconfigured files. But in general both archives can be used
on both systems (after some cosmetic changes).

where `??' in the above filenames stand for the digits of the actual version
of RHIDE which is as of writing this version 1.5 which leads to `15'.

These archives can be found at
The RHIDE home page (http://www.rhide.com)
or at any ftp site, which mirrors DJGPP. On that DJGPP mirrors are of course
only the DJGPP archives available.

RHIDE is now also hosted on sourceforge, from where you can download also the
latest versions.
RHIDE on sourceforge (http://sourceforge.net/projects/rhide)
To install these archives, unzip them in the DJGPP-root directory, like any
other DJGPP package.

To install the GNU/Linux RPM packages, use your favorite install program
(most Linux distributions allow to install RPM packages) or install it with
the Redhat package manager itself.

1.3 What is RHIDE?
==================

What is RHIDE? RHIDE is an Integrated Development Environment for compiling
C- or C++-files (GNU-Assembler source files also supported) in an
environment, which has an integrated editor where you can edit your source
files and a project management, where you can define, which files are needed
to build a program or a library.

For what stands the name RHIDE? This has nothing mystic in it. It comes
simply from my initials RH and IDE (Integrated Development Environment).

RHIDE works like the IDE from Borland, which comes with Turbo C++ 3.1 and is
written with the Turbo Vision library, which I have ported to use with DJGPP.
Features of this IDE are:
   - Syntax highlighting is now supported and you can customize all colors on
     your desktop.

   - You can redirect the stdout and stderr from your program to a window in
     the IDE.

   - You can generate a makefile for your project, so you can build the
     program also without the IDE.

   - Most of the commandline options of GCC can be customized.

   - You can also build a library instead of an executable.

   - When saving a file to disk, the modification time of this file will be
     set to the time of the last modification in the editor.

   - You can interrupt external programs (the compilers or your program) by
     pressing <Ctrl+C>  or <Ctrl+Break>  which are ignored by the IDE. That
     means also, that you cannot interrupt the IDE by pressing these keys. If
     you want to enable this, compile the IDE without the `-DNO_BREAK'-flag.

   - The integrated debugger. You can debug your program within RHIDE by
     executing each source line of your code and evaluating/modifying
     variables and expressions.

   - You can define another compiler to compile your source files.


In addition to RHIDE I have included a stand-alone debugger (called
`rhgdb.exe'), which is GDB 5.0 with a Turbo Vision user interface.

1.4 Requirements
================

RHIDE works under and is compiled with DJGPP V2.  To compile your programs
you need a working GCC-configuration, that means, GCC must be found in your
path. Because DJGPP works only under DPMI you need a DPMI-Server.  If you run
it under Windows 3.1(1)/95, you have DPMI. Under MS-DOS you need either a
memory-manager, which give you DPMI-services (I think QEMM is it, EMM386 has
no DPMI-support), or you use CWSDPMI, the free DPMI-server from Charles W.
Sandmann, which you can find on SimTel-ftp-sites. I use it and it works fine
for me.

Running RHIDE under Windows NT or Windows 2000 should work, since I have
W2000 and developing there.

The builtin editor uses a simple heuristic to check, if a file is in UNIX or
DOS text format. It checks the first 1024 Bytes, and if there is a lf without
a cr, all lf's will be translated to cr/lf's. This is done at first only in
memory. But if you save your file to disk, it will be saved in DOS text
format.

RHIDE will work correctly only with DJGPP version 2.03 or higher and please
if you are running under W2000 (or XP) get always the latest DJGPP, since
there are many efforts to make DJGPP working on these systems.

1.5 Getting started
===================

To run RHIDE type
     rhide [options] ['file-name']
or
     rhide [options] 'project-name' [options]
Here stands 'file-name', for a file, which you want to open at start up.  If
it has no suffix it is assumed to be a 'project-name'.

'project-name' stands for a name of your project. If you don't type it, RHIDE
searches the current directory for a project file. If there exists only one,
it will be opened. If there exist more than one or none, RHIDE will not open
a project, you have to do it manually.  *note Open project::.

Possible options are for debugging RHIDE itself *note Debugging RHIDE::.  If
no project was open, you will see an empty desktop.  At the top-line of the
screen you can see the menu. This is activated by pressing <F10>  or by
clicking with the mouse at this line.  Alternatively you can press <Alt> plus
the highlighted character of a pull-down menu, e.g. to activate the _File_
menu, press `Alt+F'. At the bottom is the status line with some hotkeys and
their functions displayed.

Other options are:

`-H'
     Do not install the console switch handler, which saves/restores the
     modified keyboard layout. This options works only when running under
     GNU/Linux.

`-S'
     Tells RHIDE to use only 16bit access to the video memory under DJGPP,
     because some video cards cannot handle the 32bit access.

`-E'
     Dump all variables known to RHIDE (the builtins and the real environment
     variables) to `stderr' end exit.

`-C'
     Disable the handling of SIGINT

`-y'
     Use long filenames (only under Windows 95)

`-n'
     Do not use long filenames (only under Windows 95)

`-c'
     Do not convert the case of any file name

`-h'
     Show a short help about all the possible options.

`-b'
     Use BIOS calls for setting and resetting the behavior of the 7th bit in
     a color attribute (blinking or 16 background colors) instead of direct
     outputs to the VGA registers.

`-p'
     Normally RHIDE converts all the num-pad keys to the equivalent keys on
     the other keyboard (of course also by checking the <NumLock> key). With
     this switch you can disable this.

`-G n'
     Select which method is used for swapping the display. Currently there
     are two, little different functions implemented.  If you have problems
     with display swapping when in graphics mode, try to use another method
     and see if that helps.

`-K'
     Tell RHIDE, to use real BIOS calls for it's keyboard input. This is
     needed sometimes, when you have installed some special keyboard drivers.

`-M'
     This tells RHIDE to not to install the mouse callback function for
     getting the mouse events. Instead of this RHIDE calls the mouse BIOS
     functions for getting any event of the mouse. This option should be used
     mainly when running under Windows NT (but there I select this now
     automatically by default)


At the upper right corner of the screen you can see the free virtual/physical
memory (where M stands for Megabytes, K for Kilobytes and B for Bytes), if
enabled *note Preferences::.

If you try to open a project, which does not exist, RHIDE will create a new
one. For the default setting in the newly created project, RHIDE will look
first in some directories if there exists an options file for RHIDE called
`rh_opt.gpr'. If this file is found, the options from that file are used for
the new project, otherwise the in RHIDE hardcoded defaults are used.

1.5.1 Supported languages
-------------------------

There is also support for multiple languages. For this RHIDE uses the GNU
gettext library. With this lib it is possible to support multiple languages
without changing any code of RHIDE, when adding a new language.

There are two ways for selecting the language. Either you set the environment
variable LANGUAGE to the language you want or give it as a commandline
argument to RHIDE. The normal way is by setting LANGUAGE. If you have
installed RHIDE as described in the `readme', you should specify the language
with a two character shortcut. Because of my limited time, the translations
to are not synronized with RHIDE.

When you want to specify the language on the commandline, use the following
syntax:
     rhide -L LANGUAGE
where LANGUAGE represents the language code.

If you do not specify any language, English is assumed.

Because it was not possible to get all the translations at the time when
RHIDE was ready, I included only the message files (that are the files with
the `.mo' suffix) as they are ready in the binary archive. That means that it
is possible that you will see some strings in English instead of your
language.

1.5.2 Debugging RHIDE
---------------------

I have added some commandline options to debug the IDE itself. These options
are the following:

`-dt'
     Do not remove the temporary files which the IDE creates. The names of
     these files will be printed to stderr.

`-dc'
     Print to `stderr' the commands which the IDE executes.

`-dd'
     Print to `stderr' how the IDE checks the dependencies.

`-df'
     Print to `stderr' how the IDE searches for files.

`-ds'
     Print to `stderr' how the IDE expands the specs.

`-da'
     Turns on all of the above


You can also combine these options like `-dct', which is the same as `-dc
-dt'.

To examine this debugging information, it is the best to use the redir
command, to redirect the stderr to a file like
     redir -e err rhide -da project
which will redirect stderr to the file `err'.

Under GNU/Linux use the following command:
     rhide -da project 2>err

Each of the letters above (after `-d') can be prefixed by a `-' or a `+' to
explicitely turn the flag on or off.  For instance `-dc' and `-d+c' are the
same and `-da-c' selects all debugging options except the `-dc' switch.

If you want to supply certain switches for RHIDE as a default, you may put
them into the environment variable `$(RHIDEOPT)'.  The contents of this
variable is used before the the real commandline is parsed.  That means you
can overwrite the switches from the environment variable.

1.6 The program GPR2MAK
=======================

This program can be used to create a makefile from your project-file.  It
does exactly the same as the function which is selectable from the RHIDE menu
*note Write Makefile::.

In RHIDE you have only the possibility to say, if in the generated makefile
all dependencies should be included or not. With `gpr2mak' you can tell also
to create recursively all the needed makefiles. This makes sense only if you
have included other projects in your project.

Here are the possible commandline options for `gpr2mak'.
`-d'
     Include all dependencies in the makefile

`-d-'
     Include only the needed dependencies to create the final program or
     library.

`-r'
     Call `gpr2mak' recursively, if there are other projects part of the
     project.

`-r-'
     Do not call `gpr2mak' recursively.

`-o OUTFILE'
     Use `OUTFILE' instead of the project name (with the suffix `.mak') as
     the created makefile. If you want to write the makefile to `stdout', use
     `-' as `OUTFILE'.


And the complete syntax for calling `gpr2mak' is also:

     gpr2mak [-d[-]] [-r[-]] [-o OUTFILE] project-file

If you give no options, (the project-file must be given), `gpr2mak' assumes
the flags `-d- -r-' as default.

1.7 The program GPREXP
======================

The main reason for this program was the need for me to have project files
which should work on different computers and also on different systems (like
DJGPP and GNU/Linux). The task for this program is to convert as most as
possible absolute filenames stored in the project file to use variables so
the project can be used by simply changing some variables outside RHIDE.

GPREXP replaces all directories, which are used also in the dialogs like the
directory customizations for include file searches, by the variables if they
are known there.

1.8 First steps with RHIDE
==========================

Here I will give you some instructions for the first steps to get contact
with RHIDE.

1.8.1 What are these so called projects
---------------------------------------

A project for RHIDE is a file, which contains all the needed information
required to build a program or library from one or more source files. Also
all the other options which belong to the look and feel of your desktop are
stored there.

In general RHIDE creates for each project two files. One for the project
itself (it has the suffix `.gpr') and one for the desktop related things (it
has the suffix `.gdt').

To create a new project either run rhide with a not existing project name as
argument or open within RHIDE a project by selecting a name which is not
existent.

1.8.2 Creating your first project
---------------------------------

For the next instructions I will assume, that you want to create a project
for the standard "Hello world" program in the current directory. Create now
the new project by running

     rhide hello

and you will see an empty desktop and one window opened, the project window.
This window will show you that there is no file defined for your project.  If
the project window is selected, (it has a double frame), then hit there <Ins>
and you will be prompted for adding an item to your project.

Type in the input line now `hello.c' and hit <ENTER>. Now hit <ESC> to leave
the dialog. You will see now, that the project window contains a line with
`hello.c'.

Now hit <ENTER> on that filename and you will get an empty editor window
named `hello.c' prepended by the current directory. In this editor window you
can type now the program:

#include <stdio.h>

int main()
{
  printf("Hello world!\n");
  exit(0);
}

Now you can select from the Run-menu the Run entry (or use the hotkey
`Ctrl+F9') and RHIDE will do all the necessary steps to compile, link and
execute the program.

If everything was correct (no typing errors) or some other error, you will
get a message box where RHIDE tells you, that the program exited with an exit
code of 0. (This is the value, which you have specified in your program above
in the `exit(0);' statement) This box you can close with <ENTER> or <ESC>.

To see the output of the program, you can switch now to the user screen with
`Alt+F5' or from the menu (Windows/User screen).  To return back to RHIDE hit
any key.

1.9 Environment variables
=========================

RHIDE uses many environment variables for it's configuration and behavior.
This includes also some standard variables, which are used by the in RHIDE
linked libraries. These are:

$(LOCALEDIR)
     This should point to the directory, where your locale files are stored.
     If it is not set, RHIDE tries to get the system default value, which is
     for GNU/Linux `/usr/share/locale' and for DJGPP `$(DJDIR)/share/locale'.

$(INFOPATH)
     This is a pathlist of directories, where your INFO files are stored. If
     not set, RHIDE tries the standard directory, which should for GNU/Linux
     `/usr/info' and for DJGPP `$(DJDIR)/info'.

$(RHIDEOPT)
     This variable can be used, to define global RHIDE commandline options.
     The value of this variable is used, as if the contents are given on
     commandline before any of the real commandline options. Which means,
     they can be overwritten on the commandline.

$(ESCDELAY)
     This variable is used _ONLY_ in the GNU/Linux version, where it defines
     the delay after pressing <ESC> to wait for another keypress to simulate
     an <Alt> keycode. The value is given in milliseconds and defaults to
     1000.

$(LANGUAGE)
     This variable is used to specify the language, in which RHIDE should
     communicate with you. The contents of this variable should be the ISO
     2-character code of your country.

$(RHIDE_SHARE)
     With this variable you can tell RHIDE where it should look at first for
     it's configuration files.


1.9.1 Setting environment variables for RHIDE
---------------------------------------------

There are some different ways for setting environment variables for RHIDE.
One of them is to set them like any other environment variable on your
system. But this means that these variables are visible also by all the other
programs.

When using the DJGPP version, you can set them in your `djgpp.env' file
either at the beginning as global variables for any DJGPP program or in a
special section `[RHIDE]' only for RHIDE. Please read the doc about the
format of the `djgpp.env' file for more information.

Derived from the technique used on DJGPP for setting environment variables
which are visible only for DJGPP programs, I have added in RHIDE a similar
thing. RHIDE can read environment variables also from a file called
`rhide.env'.

The syntax of this file is very simple. Each line has one of the following
syntax:
VARIABLE=CONTENTS
     Which means, that the environment variable `VARIABLE' should become the
     contents `CONTENTS' where `CONTENTS' can be also a variable, which is
     expanded at runtime.

include OTHER_ENV_FILE
     Such a line tells RHIDE to read in at that point the file
     `OTHER_ENV_FILE' as environment file. The name `OTHER_ENV_FILE' can be
     also an environment variable, which is expanded before reading the file.

     The word `include' may optionally also start with a dash `-', to be
     compatible with GNU make.

# comments
     A line, which begins with a `#' means, that this line is ignored.  It
     can be used for you to write there some comments about that file.

export VARIABLE=CONTENTS
     This is the same syntax as without the `export' at the beginning of the
     line but it tells RHIDE to place the variable also in the environmen so
     also other programs (called by RHIDE) can see this variable.


RHIDE is very powerful in handling the environment variables. Most of it is
taken from the behavior of GNU make. On this great things depend, that a
variable name can consist also of other variables, which are computed when
the variable should be expanded.

In general, you can use the `rhide.env' files very similar to makefiles for
GNU make if you think there only about the variables and functions from GNU
make.

As an example of this, you can take a look on the RHIDE sources in the
`rhide.env' files. There I'm using, for instance, the RHIDE builtin variable
$(RHIDE_OS) to define the libraries, which are linked in RHIDE depending on
the operating system where RHIDE is built.

An other example is distributed with RHIDE in it's binary archives as
`rhide_.env' which is commented and should be in a directory
`.../share/rhide/' where the `...' stand for a different directory on
different OS's. (on DJGPP it is %DJDIR% and on GNU/Linux it is /usr/local )

Here is a part of the environment file `rhide.var' in the main RHIDE source
directory (which is included by `rhide.env' with
include $(RHIDESRC)/rhide.var

RHIDE_OS_LIBS_Linux=ncurses gpm m
RHIDE_OS_LIBS_DJGPP_idegc.exe=dbg
RHIDE_OS_LIBS_DJGPP=$(RHIDE_OS_LIBS_DJGPP_$(MAIN_TARGET))
RHIDE_OS_LIBS=$(RHIDE_OS_LIBS_$(RHIDE_OS))

The RHIDE builtin linker spec *note Builtin compiler specs:: includes also
$(RHIDE_OS_LIBS) when linking. Since RHIDE can be built on DJGPP and
GNU/Linux and on these different operating systems I have to link different
libraries.

Description of the above: When linking on DJGPP the file `idegc.exe' (which
is RHIDE) I have to include (in addition to all the other libraries)
`libdbg.a', which contains all the DJGPP specific debugging functions. This
is done at runtime by expanding RHIDE_OS_LIBS. Here are the steps, how RHIDE
expands the variable RHIDE_OS_LIBS:

$(RHIDE_OS_LIBS)                      ->  $(RHIDE_OS_LIBS_$(RHIDE_OS))
$(RHIDE_OS_LIBS_$(RHIDE_OS))          ->  $(RHIDE_OS_LIBS_DJGPP)
$(RHIDE_OS_LIBS_DJGPP)                ->  $(RHIDE_OS_LIBS_DJGPP_$(MAIN_TARGET))
$(RHIDE_OS_LIBS_DJGPP_$(MAIN_TARGET)) ->  $(RHIDE_OS_LIBS_DJGPP_idegc.exe)
$(RHIDE_OS_LIBS_DJGPP_idegc.exe       ->  dbg

In a similar way it expands on GNU/Linux to

$(RHIDE_OS_LIBS) -> ncurses gpm m

1.9.2 Where to store the environment file
-----------------------------------------

RHIDE searches some known directories for the file `rhide.env' (and of course
also other there defined included files).

At first it searches for a global file in `/usr/local/share/rhide' (on
GNU/Linux) or `$(DJDIR)/share/rhide'. Then it searches in `$(HOME)' and at
last in the current directory.

RHIDE does not only a search, it also loads the file, if it was found in any
of the above mentioned directories. That means, if in all these directories
`rhide.env' exists, it is loaded. This has the effect, that you can define
some global defaults which can be overwritten with a `rhide.env' in the
current or your home directory.

If you need a sample usage of `rhide.env', please take a look at the RHIDE
sources.

2 General information about how RHIDE works
*******************************************

In this section I will give you some comments about the concept of RHIDE.
RHIDE works with the GNU compilers. As a result of this, most of the options
are fixed and they are mostly also specific only for this compiler. If I
speak about compilers, I mean GCC, which calls the right compilers for you.
(`cpp' for preprocessing your input files, `cc1' for compiling C programs,
`cc1plus' for compiling C++ programs and `as' for compiling assembler files
and so on)

Selecting the right compiler for a specific file is done by RHIDE in the same
way as GCC does it. It looks for the extension of the file and determines the
language of this file.

2.1 Known suffixes
==================

The list of the known suffixes is taken from GCC. Remember the fact, that GCC
and RHIDE check the suffixes in a case sensitive way especially when running
under Windows 95 *note Running under Windows 95::.

   * Valid suffixes for C source files are
    `.c'
          Normal C source file

    `.i'
          C source file, which doesn't need the preprocessor


   * Valid suffixes for C++ source files are
    `.cc'
    `.cpp'
    `.cxx'
    `.C'
          Normal C++ source file

    `.ii'
          C++ source file, which doesn't need the preprocessor


   * Valid suffixes for Objective C source files
    `.m'
          Normal Objective C source file


   * Valid suffixes for Pascal source files
    `.p'
    `.pas'
          Normal Pascal source file


   * Valid suffixes for object files
    `.o'
          Normal object file

    `'
          any other suffix, which has no predefined meaning


   * Valid suffixes for libraries
    `.a'
          Normal library file


   * Valid suffixes for executable files
    `.exe'
          Normal executable file for MS-DOS

    `.'
          No suffix means the raw COFF image of an executable file. These can
          be handled only by programs, which know about this format.  (DJGPP
          programs know this)


   * Valid suffixes for include files
    `.h'
          Normal include files

    `.hpp'
          Some people told me, that this suffix should also be treated as a
          valid suffix for header files, so I applied it.

    `'
          Theoretically there is no restriction for such a suffix, but RHIDE
          searches and finds only files with the above suffixes in the
          specified directories *note Include directories::.


   * Valid suffixes for Assembler source files
    `.s'
          Normal Assembler source file

    `.S'
          Assembler source file, which must be preprocessed by `cpp'. If you
          have such files, there is a problem, when long filenames are not
          enabled (default in MS-DOS), because RHIDE converts all filenames
          in this situation to lower case. But you can add to the local
          options for this item *note Local options:: the commandline
          argument -X ASSEMBLER-WITH-CPP, to tell `GCC' to preprocess this
          file first before assembling it.


   * Valid suffixes for Fortran source files
    `.f'
    `.for'
          Normal Fortran source files

    `.F'
    `.fpp'
          Fortran source files which need not to be run through `cpp'.

   * Valid suffixes for ADA source files
    `.adb'
          Normal ADA source file

    `.ads'
          ADA specs file

   * Valid suffixes for NASM
    `.nsm'

    `.asm'
          Normal NASM source files.


2.2 Syntax of arguments
=======================

In RHIDE you can specify some arguments to other programs. These arguments
must be a space separated list of strings. If you want to have one or more
spaces as part of an argument, you have to enclose the whole argument in
single or double quotes.

2.3 Running under Windows 95
============================

With DJGPP 2.01 were many bugs fixed, which caused problems under Windows 95
with the long (and case sensitive) filenames. Now all filenames are shown in
lower case, except they contain characters with different case. That means,
all normal 8+3 DOS filenames, which are normally reported in Windows 95 in
upper cases, are automatically converted to lower case. For more information
about filename conversion look at the libc reference.

If you really need the filenames exactly as they are reported by the OS, you
can use the -C switch *note Getting started::.

You can also run more than one instance of RHIDE at once, in several
DOS-boxes, because RHIDE creates and uses its own temp directory every time
it starts to disable conflicts, when running multiple compilers at the same
time. This is done by creating a directory in the directory pointed at by the
environment variables %TMPDIR%, %TEMP% or %TMP%, in that order, until one of
them exists. If none of them exists, the current directory is assumed. Then
RHIDE puts the value of this directory into the environment variable
%TMPDIR%. After leaving RHIDE this directory will be removed, if it is empty.

2.4 Running under OS/2
======================

Because I have no access to OS/2, I cannot say anything about it. But some
people said that they run RHIDE under OS/2 successfully, but there must be
the exclusive mouse access to the DOS window disabled.

2.5 Running under Windows NT
============================

I haven't access to NT so I cannot say something about running RHIDE on this
OS.

2.6 Running under GNU/Linux
===========================

Since RHIDE is now available also for GNU/Linux here some hints. In general
you will get the best results when you have installed RHIDE as a setuid root
program. I know, this might be a security problem but I have tried to make it
as secure as possible. After getting acces to the screen and the keyboard
RHIDE will switch back to your normal rights and does not use root rights any
more. It does not write any data or modify any file on disk with root rights
(except you are running as root of course).

The reason for this is the rudimentary support for fast access to the screen
and the totally hided acces to the keyboard in the Linux kernel.
Additionally when you want to use the dual monitor debugging feature of RHIDE
this is also needed, because RHIDE needs in that case access to the ports of
your monochrome video card.

Running RHIDE under X-Window is not full supported (but it is possible).
There are several reasons for this. The first is, that RHIDE uses in that
case only terminal functions for input and output. That means it depends
completetly on your terminfo database and these are (at least for me) in some
cases totally wrong. You can see this mostly that RHIDE does not handle
correct the keyboard. Other programs which use ncurses know this also and
have there own hardcaded patches but I do not want to do so.

To fix the keyboard conflicts when running in a xterm, I distribute little
modified terminfo file `/usr/local/share/rhide/xterm-rhide' which you can
place in `/usr/lib/terminfo/x' or when you have no root access you can place
it also in `$HOME/.terminfo/x'.  And then to use this file simply set the
environment variable to this new terminal with
  export TERM=xterm-rhide
before running RHIDE in the xterm.

An other alternative is to run RHIDE in a rxvt terminal but there you have to
set also explicitely the TERM variable, because it is set mostly to
xterm-color.
  export TERM=rxvt

2.7 General use of RHIDE
========================

2.7.1 Creating a program
------------------------

For creating a program, RHIDE allows you to define multiple source files
which should be compiled and linked to your final program. This is done by
creating a project. In this project you insert your source files (and not all
the include files).

After a source file (which is inserted in your project) compiled at least
once, RHIDE knows about all dependencies of this file, so this file will be
compiled again only, if one of the include files have changed.

2.7.1.1 Creating a program without a project
............................................

Because of many requests of users I made RHIDE to work also without using a
project. This may be good, if you have a single file, but if your program
should be build from more than one file I suggest you to use a project.

If you have only one editor window opened, the name of the resulting program
is taken from the name of the source file by removing the suffix and on DJGPP
appending `.exe'.

If you have more than one files opened, I saw no other way for determining
the name of the produced program, than naming it `aout' (on DJGPP `aout.exe').

2.7.2 Creating a library
------------------------

You can also create libraries (a collection of object files, which can be
linked with other programs) with RHIDE. The way for doing this is very
simple. Because RHIDE knows about the meaning of file suffixes, you can
change the name of the main target *note Main targetname:: to have a suffix
`.a' and that's all. Now RHIDE will run `ar' instead of linking.

2.7.3 Saving/Loading the options
--------------------------------

RHIDE supports two different ways for saving the options which you have
customized.

The first one (which I prefer) is the use of the so called default project.
This is the project `rhide.gpr' and must be located in the same directory
where `rhide.exe' is. To create or modify this default project change to that
directory (normally %DJDIR%/bin) and type there

     rhide rhide

Now change any options you want and exit RHIDE. From now on these options are
used for any newly created project or when running RHIDE without a project.

The second way is to save your options to a project file *note Save options::
or to load them from any existing project file *note Load options::.

3 Description of the pull-down menus
************************************

This chapter describes the pull-down menus and all their sub-menus.  The main
menu bar, the topmost line of the screen, is selected with the hotkey <F10>  or
by clicking with the mouse at this line. You can walk through the menu with
the cursor keys and a menu entry is selected with <ENTER>  or by clicking
with the mouse on it.

3.1 System menu
===============

This menu has its name only that one can speak about it. The symbol for this
menu is the leftmost symbol in the menu bar.  <Alt+SPACE> selects this menu.

3.1.1 About
-----------

This brings up a window with information about the author and the version of
RHIDE.

3.1.2 Bug report
----------------

This menu entry opens an editor with some important information which should
be part of a bug report and where you can describe the problem.

3.1.3 FSDB
----------

With this menu item you can call the FSDB debugger, which comes with DJGPP.
But remember, this runs the debugger as an external program and it is not
integrated in RHIDE.

3.1.4 GREP
----------

This is a very useful function. You can type the arguments for grep in the
input line, which will be shown, and after this the program grep is called.
The messages from grep are redirected to the message window *note Message
window::.

3.1.5 GDB
---------

This is analog to the call of FSDB *note FSDB::.

3.1.6 Refresh Desktop
---------------------

This function is sometimes useful, if you had run your program and it wrote
some things to the screen (for redirecting `stdout' and `stderr' from your
program to a window in RHIDE *note Preferences::.)

3.1.7 Calculator
----------------

This brings up a dialog, where you can do some calculations. This dialog is
similar to the evaluate dialog *note Evaluate/Modify::, but it uses not the
feature of GDB, but it is a separate calculator.  For more information see
*Note Documentation for the editor: (setedit)Calculator.

There can be used also some of the standard functions like `log', `sin' and
so on and it can convert also integer values between different bases (`hex',
`oct', `dec').

3.1.8 Puzzle
------------

This will open a small window, where you can play a little puzzle game. The
"stones" are moved with the cursor keys or by clicking with the mouse on it.

3.1.9 Calender
--------------

This will open a little calender. With the cursor keys <Up> and <Down> you
can switch to the next/previous month or click with the mouse on the small
symbols in the upper corners.

3.1.10 ASCII table
------------------

This will open a window with all the ASCII characters. Move around with the
cursor keys or press any key to select any wanted character.  In the bottom
line you will see the the character and the value of it (decimal and
hexadecimal). The decimal value can be used to create that character for
instance in the editor by holding the <Alt> key down and typing the value on
the numeric key pad.

3.2 File
========

In this menu you can find functions, which deal with files, like open, close,
save and so on.

3.2.1 Open
----------

Brings up the file-open dialog, where you can select a file to open (hotkey
<F3> ). This dialog contains an input line for the filename, a list of
filenames, an information window and the buttons for opening and canceling.

In the filename input line you can type directly the file, which you want to
open or you can type any mask to list only some files. The default mask is
`*.cc', but you can change this to anything and your last typed mask is
stored as the default mask for the next use. There is also a history of your
previous typed inputs available. This is selected when you hit the down key
or click at the small symbol at the end of the input line with your mouse.

The list of filenames shows all the files that correspond to the mask.  If
this list is selected you can choose a file with the cursor keys, or you can
type the first letters of the filename you want, and the bar is located at
the first file, which has these letters as the first characters. To open the
file simply press <ENTER> or double click with the mouse on it.

Below the list of filenames there is a small window with information about
the selected file (complete path, size, modification time).

To leave the dialog without opening a file press <ESC> .

3.2.2 New
---------

This is the menu entry for creating a new file to edit. This file gets the
title 'Untitled'. If you save or close it, you will be prompted for a new
name of this file by opening the file-open dialog.

3.2.3 Save
----------

Save the file in the current editor-window to disk. If the name of the
current file is 'Untitled' you will be prompted for a new name. <F2> is the
hotkey for this function.  The modification of the file on disk is set to the
time of the last modification of this file and not to the time when saving to
disk.

If the file was not modified, it is not saved!!

3.2.4 Save as
-------------

Save the file in the current editor-window to disk under a different name,
for which you will be prompted. For choosing the new name the file-open
dialog will be opened.

3.2.5 Save all
--------------

Save all the editor files to disk. If they are not modified, they will not be
saved.

3.2.6 DOS Shell
---------------

This executes a DOS-Shell. This is done by calling the program, which is set
in the environment variable COMSPEC. If this variable does not exist, the
program `c:/command.com' is executed.  To return to the IDE type `exit' at
the DOS-prompt. Before calling DOS, the program does a _Save all_ *note Save
all:: automatically.

3.2.7 Exit
----------

Here you can quit the IDE. If there are any unsaved editor-files, you will be
prompted for saving them. (<Alt+X> is the hotkey.)

3.3 Edit
========

In this menu you can activate functions, which are related to the integrated
editor. Most of them have a hotkey.

3.3.1 Undo
----------

This undoes your last change in the current editor-window.  <Alt+Backspace> is
the hotkey for this function.

3.3.2 Redo
----------

This does the reverse to undo *note Undo::. That means, it is the undo of the
undo.

3.3.3 Cut
---------

This _moves_ the selected text in the current editor-window to the clipboard.
(<Shift+Del> is the hotkey.)

3.3.4 Copy
----------

This _copys_ the selected text in the current editor-window to the clipboard.
(<Ctrl+Ins> is the hotkey.)

3.3.5 Paste
-----------

This inserts the selected text in the clipboard in the current editor-window
at the current cursor-position. (<Shift+Ins> is the hotkey.)

3.3.6 Show Clipboard
--------------------

This brings up an editor-window with the contents of the clipboard. The
contents of the clipboard will be lost, if you exit the IDE.

3.3.7 Clear
-----------

This erases the selected text in the current editor-window.

3.3.8 Copy to Windows clipboard
-------------------------------

This is the same function as *Note Copy::, but it uses the Windows clipboard
and works only, when running under Windows.

3.3.9 Paste from Windows clipboard
----------------------------------

This is the same function as *Note Paste::, but it uses the Windows clipboard
and works only, when running under Windows.

3.3.10 Expand all tabs
----------------------

When selecting this menu entry, all real tabs (all characters with the code
`0x9') are expanded to as many spaces as defined as the tabsize *note
Preferences::.

3.3.11 Compact text
-------------------

This function is the reverse to *Note Expand all tabs::. That means, RHIDE
tries to make as many as possible spaces (count is taken from the defined
tabsize) to real tabs.

3.3.12 Macro
------------

Here is a submenu for handling macros. Currently there is only one recordable
macro available and it is NOT stored anywhere. That means it is lost when you
leave RHIDE and restart it. There is another way of using macros *note
Defining macros::.

3.3.12.1 Record
...............

After selecting this function, all your keystrokes are recorded to reproduce
them later.

(<Shift+F10> is the hotkey.)

3.3.12.2 Stop
.............

This stops the recording of a macro.

(<Alt+F10> is the hotkey.)

3.3.12.3 Play
.............

This executes the recorded macro.

(<Ctrl+F10> is the hotkey.)

3.4 Search
==========

Menu for searching and replacing strings in the editor-window. These functions
have also hotkeys.

3.4.1 Find
----------

Find a string in the current editor-window. You can type the string for
searching in an input line and you can also select, if the search is case
sensitive or not and to search for whole words only or not.

(<Ctrl+Q+F> is the hotkey.)

3.4.2 Replace
-------------

Find and replace a string in the current editor-window. This works in the
same way like searching text, but additionally you can give a string, with
which the found text will be replaced.

(<Ctrl+Q+A> is the hotkey.)

3.4.3 Search again
------------------

This function repeats the last search or replace operation.

(<Ctrl+L> is the hotkey,)

3.4.4 Goto line
---------------

After prompting for a line number (with range checking), the cursor will be
located at this line.

(<Ctrl+J> is the hotkey.)

3.4.5 Jump to function
----------------------

With this feature you can easily jump to the source line of a function to
edit or see it. This is only a heuristic by parsing your source file and does
not take the information from the debugging symbols.

After selecting it you will get a dialog, from where you can select the
function to which you want to jump.

(<Alt+F2> is the hotkey.)

3.4.6 Next message
------------------

This selects the next message in the message window *note Message window::,
but only, if there is a next message available.

(<Alt+F8> is the hotkey.)

3.4.7 Previous message
----------------------

This selects the previous message in the message window *note Message
window::, but only, if there is a previous message available.

(<Alt+F7> is the hotkey.)

3.5 Run
=======

In this menu you find the functions for running your program.

3.5.1 Run
---------

If your project-target is an executable, this will be run after doing a *Note
Make::. <Ctrl+F9> is the hotkey. If the build was not successful, the program
will not be started. The debugging functions are only available if `-g' was
used for compiling *note Syntax of arguments::.

3.5.2 Step over
---------------

This executes the code for exactly one source line. If there is a function
call at the current line this function is executed at once without stepping
through this function.

When using the <Shift>-key, RHIDE will NOT switch to the user screen when
executing the debuggee.

(hotkey <F8> or hotkey <Shift+F8> may be used.)

3.5.3 Trace into
----------------

This is the same as *Note Step over::, except when there is a function call
at the current line and for this function debugging information is available,
RHIDE steps into this function.

When using the <Shift>-key, RHIDE will NOT switch to the user screen when
executing the debuggee.

(hotkey <F7> or hotkey <Shift+F7> may be used.)

3.5.4 Go to cursor
------------------

This will execute your program until the execution comes to the line, where
the cursor is. If the program is stopped at any other place by a breakpoint
the program will stop there and not at the cursor position.

When using the <Shift>-key, RHIDE will NOT switch to the user screen when
executing the debuggee.

(hotkey <F4> or hotkey <Shift+F4> may be used.)

3.5.5 Program reset
-------------------

This 'kills' your debuggee at the current execution point without executing
any other code of your program

(<Ctrl+F2> is the hotkey.)

3.5.5.1 Main function
.....................

Here you can define the name of the `main' function of your program. This is
needed at least when debugging programs, (like written with GNU Pascal or GNU
Fortran), where the function of your main program is not `main'.

But you can use this also to debug your program at locations, which are
executed normally before `main' is called (for instance the global
constructors).

3.5.6 Arguments
---------------

Here you can type the arguments, which will be passed to your program when
you do a _run_ *note Run:: and *note Syntax of arguments::.

3.6 Compile menu
================

Here are the functions to translate your source files and for updating your
project.

3.6.1 Compile
-------------

Compile the file in the current editor-window or the selected entry in the
project-window if you are there. The IDE chooses automatically the correct
compiler, depending on the suffix of the file *note Known suffixes::.

(<Alt+F9> is the hotkey.)

3.6.2 Make
----------

This makes your project up to date. It works like MAKE on commandline with a
makefile. <F9> is the hotkey. The dependencies are checked for each item of
the project. These dependencies are automatically generated, if you compile a
file within the IDE.

3.6.3 Link
----------

This function has two different results depending on the type of your
project. If your project is an executable *note Known suffixes::, the linker
is started. But if it is a library, all the object files are taken to build a
library.

3.6.4 Build all
---------------

This builds the project completely new with compiling and linking all of the
project-items.

3.7 Debug
=========

This menu contains the functions for debugging your program. Most of them
have hotkeys and they are described in more detail later *note Debugging with
RHIDE::.

3.7.1 Set/Reset Breakpoint
--------------------------

*Note Setting a breakpoint::.

(<Ctrl+F8> is the hotkey.)

3.7.2 Evaluate/Modify
---------------------

*Note Evaluating the contents of variables::.

(<Ctrl+F4> is the hotkey.)

3.7.3 Watch an expression
-------------------------

*Note Watching the contents of variables::.

(<Ctrl+F7> is the hotkey.)

3.7.4 Breakpoints
-----------------

*Note Modifying and setting a breakpoint::.

3.7.5 Disassembler window
-------------------------

This opens a window, where you can see assembler instructions.  When you are
running the debugger, you will see the instructions at the current execution
point of your program.

You can step *note Step over:: or trace *note Trace into:: here in the same
way like in an editor window and you can also debug code, which has no
debugging information.

Additionally you can scroll here also forwards or backwards but scrolling
backwards is very hard to implememnt and so you will get when scrolling
backwards most of the time wrong output. Sorry for this, but until I find
more time to implement this better you have to live with it.

3.7.6 Call stack
----------------

This shows a window with a list of functions, from which the current
execution point in the debugged program is called. If you hit <Enter> on a
function which has line number debugging information, you will go to the
source line which is shown in the window.

(<Ctrl+F3> is the hotkey.)

3.7.7 List of Functions
-----------------------

This asks first for a regular expression to list only those functions of your
program, which match that expression. The syntax for such a regular
expression is a little bit different from the wildcards you are probably
knowing from MS-DOS.

If you want to get a list of all functions you should enter either nothing
(the default), or ".*", or "?*" (both without the double quotes).  The
expression "*" does NOT mean all function. In fact, your entry will be
interpreted as a regular expression.

After you have typed the expression and pressed <Enter>, you will get a list
of functions that match the regular expression and for which debugging
information is available.

This list is sorted by the name of the function and has three parts:

NAME | RETURN VALUE | FILE

You can walk through the list with the cursor keys or the mouse. If you hit
<Enter> or double click a function, you will go the the source code of that
function.

3.8 Project
===========

Here you can add or remove items to or from your project

3.8.1 Open project
------------------

Here is the point to open a project. After selecting this menu item, the file
open dialog is opened to select a project. You can type the name of the
project or select one from the list.

If you open a project in another directory than the current, RHIDE will
change the current directory to this directory and then the project will be
opened.

If you type here a name of a project which does not exist, a new one is
created.

If no project was opened and you create a new project, all open desktop files
remain open, but they are not added to the project.  If a project was opened,
it will be automatically closed before the new project is opened.

3.8.2 Close project
-------------------

This closes the currently opened project and closes all files, which are on
the desktop.

3.8.3 Add item
--------------

A dialog will be opened, from where you can choose your file to add to your
project. If you are in the project window *note Project window:: you can use
the <Ins> key to activate this function within the project window.

Currently it is impossible to use relative or absolute paths as part of a
project item. If you have your files in several directories, you have to
setup either the search path for source files or you have to create for each
directory a library that can be included in your project.

3.8.4 Delete item
-----------------

This will remove the selected item in the project-window from your project.
If you are in the project window *note Project window:: you can use the <Del> key
to activate this function.

3.8.5 Local options
-------------------

Here you can give the selected project-item options for compiling, which will
be in effect only for this item. If you are in the project window *note
Project window:: you can use <Ctrl+O> to activate this function.  The options
you give here are passed to GCC only, when compiling this file.  For more
details see *note Local options for a project item::.

3.8.6 Includes
--------------

This shows the dependencies for the selected item in the project window. You
can use the hotkey <Ctrl+I> in the project window.  *note Project window::

3.8.7 Main targetname
---------------------

Here you can change the name of your main target. The main target is either
an executable file or a library. RHIDE selects the type of the main target
from the suffix of this name. If it has no suffix or the suffix `.exe', an
executable will be built. If it has the suffix `.a', a library will be
created.

Remember when you give it no suffix, both, the COFF image and the `.exe' file
will created. If it has the `.exe' suffix, only the `.exe' file is created.

3.8.8 Primary file
------------------

Here you can give the primary source file, when you want to use the
'automake' feature of GPC. If you type a source name here, RHIDE assumes that
your program is written in Pascal and does NOT check any dependencies of the
project, because this is done automatically by GPC with the `--automake'
option.

If you don't want to use the 'automake' feature of GPC, even when building a
Pascal program, give here an empty name, which is the default.

3.8.9 Clear dependencies
------------------------

This function removes all internal stored dependencies. The files are not
removed. This is useful when you want to create a makefile *note Write
Makefile:: and you do not want to include all the absolute filenames for the
dependencies (mostly the include files).

This function is a relict from earlier versions of RHIDE, but I have not
disabled it.

3.8.10 Delete rebuildable files
-------------------------------

This function includes the function of clearing the dependencies *note Clear
dependencies:: and removes in addition to it all the files, which can be
rebuild within RHIDE.

3.8.11 Write Makefile
---------------------

Here you can create a makefile that contains all the rules to build the
project from the command line without starting RHIDE. For this you need the
GNU make, because the generated makefile uses the features of GNU make very
extensively.

If you have used environment variables in your search paths *note
Directories::, these are not expanded in the generated makefile.  But all
variables you used will be defined at the beginning of the makefile with
their current value.

3.9 Options
===========

This menu contains many submenus for anything you can customize.

3.9.1 Directories
-----------------

Here you can define all of the paths, where RHIDE and the compilers finds the
needed files and where to store some files.

All the paths you can define in the several entries have the form of a
semicolon separated list of directories, just like your environment variable
%PATH%. You can use forward slashes and back slashes, but they are all
converted to forward slashes by RHIDE. You can also use environment variables
as part of your paths. The syntax of such a variable is that of a GNU
makefile. If you want to use the variable `%DJDIR%', you must type `$(DJDIR)'.

3.9.1.1 Include directories
...........................

Place here a list of directories, where gcc (and RHIDE) should search for
header files which you use via #include ... and which are not in the default
directories (like %DJDIR%/include) If you want to use for instance allegro,
put here the directory, where allegro.h is.

This is the list of directories, where GCC looks for include files and RHIDE
searches in this directory (after looking in the current directory) for
header files.

3.9.1.2 Library directories
...........................

This is the list of directories, where GCC looks for libraries when linking.
RHIDE searches in this directories (after looking in the current directory)
for libraries, if you have included them directly as a project item.

3.9.1.3 Object directories
..........................

This is the list of directories where RHIDE looks for object files.  If you
type here only one directory this has also the effect that the object files,
which are compiled, are stored in this directory.

3.9.1.4 Sources directories
...........................

This is the list of directories, where RHIDE looks for the source files
(after looking in the current directory).

It enables you also one feature (like I use it mostly at any time), to have
the sources in one directory tree and the objects and executables in a total
different directory. Simply Go to any directory, create there your project
and then add the needed files to your project. Finally specify the path to
your sources here and RHIDE will find them.

3.9.1.5 Standard headers
........................

Define here a space separated list of directories where your standard headers
are. Header files found in these directories are not added to the list of
dependencies which is automatically generated when compiling a C/C++ source
file.

3.9.2 C/C++-Compiler
--------------------

In this submenu you can change most flags, which have to do when compiling C
or C++ files or better for the options of all the currently supported
compilers.

3.9.2.1 Warnings
................

This opens a dialog where you can enable or disable most of the flags for
generating or suppressing warnings when you compile a C or C++ file.  *note
How to toggle these flags::

For a detailed description of the available flags see *Note Warning Options:
(gcc)Warning Options.

3.9.2.2 Optimizations
.....................

This opens a dialog where you can customize how the compiler optimizes your
code.  *note How to toggle these flags::

For a detailed description of the available flags see *Note Optimize Options:
(gcc)Optimize Options.

3.9.2.3 Debugging
.................

This opens a dialog where you can customize the amount of debugging
information the compiler should include in object files.  *note How to toggle
these flags::

For a detailed description of the available flags see *Note Debugging
Options: (gcc)Debugging Options.

3.9.2.4 C options
.................

This opens a dialog where you can select flags that are only passed to GCC
when compiling C files.  *note How to toggle these flags::

For a detailed description of the available flags see *Note C Dialect
Options: (gcc)C Dialect Options.

3.9.2.5 CXX options
...................

This opens a dialog where you can select flags which are only passed to GCC
when compiling C++ files.  *note How to toggle these flags::

For a detailed description of the available flags see *Note C++ Dialect
Options: (gcc)C++ Dialect Options.

3.9.2.6 Pascal options
......................

This opens a dialog where you can select flags which are only passed to GPC
when compiling Pascal files.  *note How to toggle these flags::

For a detailed description of the available flags see *Note Pascal Dialect
Options: (gpc)Pascal Dialect Options.

3.9.2.7 Fortran options
.......................

This opens a dialog where you can select flags which are only passed to g77
when compiling Fortran files.  *note How to toggle these flags::

For a detailed description of the available flags see *Note Fortran Dialect
Options: (g77)Fortran Dialect Options.

3.9.2.8 How to toggle these flags
.................................

The options in the dialogs for Warnings, Debugging, C-flags and CXX-Flags are
selected with the cursor-keys or the mouse and are activated or deactivated
by pressing <SPACE> or by double-clicking with the mouse at the first field
of the option. If an option can take an additional value or string, an
inputbox will be opened, and you can type them there. If the additional value
is optional, you can leave this input-box by pressing <ESC> or activating the
_Cancel_ button and no value, or the previous one will be appended to this
option.

3.9.3 Libraries
---------------

Here you can tell the linker which libraries will be linked in your program.
At this time the number of additional libraries is limited to 16. If you need
more, you have to type them manually *note Linker options::

In the input-fields of the dialog you only have to type the part of your
library name after `lib' and before `.a'. Example: If your library is
`libtv.a' put only `tv' there. You can switch between the input lines for the
libraries using <Tab> or <Down Arrow> (next field) or <Shift+Tab> or <Up
Arrow> (previous field). If you have typed your libraries you can activate or
disable them by switching the checkbox before the name on or off. This is
done by pressing <Alt> and the corresponding digit or letter of the checkbox
at the same time or by clicking with the mouse.

Normally RHIDE checks the types of your source-files and automatically adds
some standard libraries, corresponding to these source-files.  These are for
C++ files the library `libiostream.a' and for Objective C files the
`libobjc.a' library.  If you want to disable this, deactivate the _Use
standard libraries_ checkbox. This adds also the commandline option -NOSTDLIB
to GCC, that means, you must give the linker explicitly all of the standard
libraries, which you need. This includes the `libgcc.a' and `libc.a'
libraries.

3.9.4 Linker options
--------------------

Here you can enter a space separated list of options that will be passed to
GCC when linking your program.  *note Syntax of arguments::

*Note Syntax of arguments::.

3.9.5 Compiler options
----------------------

Here you can enter a space separated list of additional options that will be
passed to GCC every time it is called.  *note Syntax of arguments::

*Note Syntax of arguments::.

3.9.6 Environment
-----------------

3.9.6.1 Colors
..............

Here you can customize all of the colors of the IDE.

3.9.6.2 Editor options
......................

 autoindent
...........

When this is enabled, the editor automatically indents the next line by
referring to the previous line if you press enter.

For more information see *Note Documentation for the editor:
(setedit)Autoindent.

*Note Editor options::.

 Use tabs
.........

When this is enabled, the character `\t' is inserted into the text if you
press the <Tab>-key. Otherwise the number of spaces (defined by tabsize) is
inserted.

For more information see *Note Documentation for the editor: (setedit)Real
Tabs.

*Note Editor options::.

 Persistent blocks
..................

Normally, RHIDE uses persistent blocks. This means the selected area will not
get unselected if you press a key. If you like the behavior of earlier
versions of RHIDE, disable this option.

For more information see *Note Documentation for the editor:
(setedit)Persistent Blocks.

*Note Editor options::.

 Intelligent C indenting
........................

This option enables the so called 'C intelligent indenting', which is an
heuristic for indenting after special key words like `if' or `while' more
than the normal autoindenting. This works only if AUTOINDENT is enabled.

For more information see *Note Documentation for the editor:
(setedit)Intelligent C indent.

*Note Editor options::.

 Column cursor
..............

This is a special feature of the builtin editor. If you enable this option
you will see a vertical special color highlighted column across the whole
editor window at the cursor column.

For more information see *Note Documentation for the editor: (setedit)Column
cursor.

*Note Editor options::.

 Row cursor
...........

This is a special feature of the builtin editor. If you enable this option
you will see a horizontal special color highlighted row across the whole
editor window at the cursor row.

For more information see *Note Documentation for the editor: (setedit)Row
cursor.

*Note Editor options::.

 Match pair highlight
.....................

If this option is enabled, you will see at any time you type a bracket, brace
or parenthesis the matching highlighted or a message, that there was no
matching found.

For more information see *Note Documentation for the editor: (setedit)Match
pair highlight.

*Note Editor options::.

 Do not move the cursor on paste
................................

Enable this option, when you want to leave the cursor at it's current
position when you paste some text.

*Note Editor options::.

 Transparent Blocks
...................

When this option is enabled, the syntax highlight is still shown in selected
blocks.

*Note Editor options::.

 Optimal fill
.............

When enabling this option the editor fills the gaps in your text with an
optimal value of spaces and tabs.

*Note Editor options::.

 Tabsize
........

Additionally you can select here the tabbing size for the editor. This value
is used as the global setting for all editor windows which will be opened
after setting this value. The currently opened windows will use also this
setting.

*Note Editor options::.

3.9.6.3 Preferences
...................

Here you can customize some basic options for the work of the IDE. A dialog
will be opened where you can turn on or off the following options:

 all dependencies in makefile
.............................

When this is enabled, all internally stored dependencies for a project item
are written to the makefile *note Write Makefile::. You should disable this
option, if you want to give another user the makefile of your project, and
(s)he has a different directory structure.

*Note Preferences::.

 create backup files
....................

Create backup files when saving. When it is enabled, RHIDE creates a backup
of the file to save under the same name as the editing file, but the suffix
is replaced with `.bak'

*Note Preferences::.

 syntax highlighting
....................

Turn the Syntax highlight on or off. RHIDE automatically checks the suffix of
the editing file to determine the correct syntax highlighting.  Currently
this is supported only for C, C++, and Pascal source files.  All other files
are not specially highlighted.

*Note Preferences::.

 Use dual display
.................

Here is an very powerful option. If you have installed on your computer a
secondary display (monochrome monitor) in addition to your VGA monitor, RHIDE
can (when this option is enabled) switch to the second monitor for it's
output and you can see your program on the normal monitor.

If this option is enabled and you have not a secondary monitor installed,
RHIDE will detect this and does not switch to it.

*Note Preferences::.

 redirect stderr
................

Turn this on, if you want to redirect the output to stderr of your program to
a window in the IDE. This is also needed, if you want to use the builtin
analyzing of a call frame traceback, when your program crashes.

*Note Preferences::.

 redirect stdout
................

Turn this option on, if you want to redirect the output to stdout from your
program to a window in the IDE.

*Note Preferences::.

 show process information
.........................

Turn this option on if you want to see which files are checked, when you do a
make *note Make::, and to see the commandlines how the compilers are started
by RHIDE.

*Note Preferences::.

 show free memory
.................

Turn this option on to show in the upper right corner of the screen a readout
of the free memory of your system.  This shows both, the virtual and the
physical free memory.

*Note Preferences::.

 No file caching
................

If this option is enabled, RHIDE does not use the internal caching of
information about searching files and modification times. Use this only if
you have problems with the automatic checking of dependencies, because this
slows down RHIDE.

*Note Preferences::.

 16 background colors
.....................

On EGA/VGA video cards it is possible to use 16 background colors instead of
normal 8. This is done by telling the video card how to interpret the highest
bit of the color attribute. If you enable this, you can use up to 16
background colors, otherwise there are only 8 colors for the background
available. To get blinking foreground colors, you must use a little trick.
Enable at first this option here. Then change the color attribute to
highlight background color you want and then reset the '16 background colors'
option.

*Note Preferences::.

 Show GDB commands
..................

When this option is enabled you can see in the GDB output window which
commands are sent to the builtin GDB from RHIDE.

*Note Preferences::.

 Use no shadows
...............

When this option is enabled RHIDE uses no shadows at all for the windows and
dialogs and so on.

*Note Preferences::.

 Save text palette
..................

When you debug a program, which modifies the palette when in text mode, you
should enable this option.

 Save project only when closing
...............................

Enable this option only, when you get a system crash after starting your
program and because of the use of disk cache the project, which RHIDE
automatically saves before your program is run, is corrupted.

 Show user screen after exit
............................

When this option is enabled, RHIDE waits for a keypress after exiting your
program. It is in general the same like pressing <Alt+F5> after exiting the
user program.

 Only #include "..." in dependencies
....................................

Here you can tell RHIDE to add only header files to the list of dependencies
for a project item which are included via

#include "..."

 Directories in project items
.............................

When this option is enabled, RHIDE will allow you to include project items
which are not in the current directory or any of the directories specified in
the path for source files *note Sources directories::. If the item is
relative to any of these default searched directories only the relative
subdirectory will be part of the item.

An other side effect is, that the resutling object file will be placed also
in the same directory relative to the default output directory.

 Show disassembler window when needed
.....................................

When you select this option RHIDE will open always the disassembler window
when the execution stops at a location for which there is no line number
debugging information available. Default the window can be opened only by
explicit request.

This allows you also to debug functions or code from other libraries or the
startup code.

 Use RCS
........

Only when this option is enabled, RHIDE will use the builtin knowledge about
RCS *note RCS and RHIDE::.

 Screen mode
............

Here you can select the video mode. If you want to use a video mode other
than the ones shown, you have to select the USER MODE mode and type the value
of this mode (see in the reference of your video card) as a decimal or
hexadecimal (preceeded by `0x') number. But you can use only textmodes (modes
with starting video ram address at `0xB800:0000'. For the numbers of the
videomodes refer to the documentation of your video card.  If you type an
invalid videomode (RHIDE checks it), the 80x25-Mode will automatically
selected.

I have tested all available text modes with my et4000-card, and they work.
For some modes, (mostly every high resolution text mode) the mouse cursor is
shown by my own routine.  That means that you can use the mouse also in the
high resolution text modes.

*Note Preferences::.

 Closed windows
...............

Define here the number of closed windows which RHIDE should remember.  If you
want to disable this, give here a number 0 and when RHIDE should remember any
closed window give here -1.

3.9.6.4 Mouse options
.....................

Here you can customize a little bit the speed of the double click interval
and you can also tell RHIDE to reverse the mouse buttons.

3.9.6.5 Reserved words
......................

This opens a dialog, where you can modify the list of reserved words the
editor knows. If you choose the _Default_ button in this dialog, the default
reserved words are generated and any previous words are lost.

3.9.6.6 Pascal reserved words
.............................

This opens a dialog, where you can modify the list of reserved words for
Pascal the editor knows. If you choose the _Default_ button in this dialog,
the default reserved words are generated and any previous words are lost.

3.9.6.7 C-Flags
...............

Here you can modify the list of C options, which you can turn on or off *note
C options::.

*Note How to change the list of flags::.

3.9.6.8 CXX-Flags
.................

Here you can modify the list of CXX options, which you can turn on or off
*note CXX options::.

*Note How to change the list of flags::.

3.9.6.9 Pascal-Flags
....................

Here you can modify the list of Pascal options, which you can turn on or off
*note Pascal options::.

*Note How to change the list of flags::.

3.9.6.10 Fortran-Flags
......................

Here you can modify the list of Fortran options, which you can turn on or off
*note Fortran options::.

*Note How to change the list of flags::.

3.9.6.11 Warning-Flags
......................

Here you can modify the list of Warning-Flags, which you can turn on or off
*note Warnings::.

*Note How to change the list of flags::.

3.9.6.12 Debugging-Flags
........................

Here you can modify the list of Debugging-Flags, which you can turn on or off
*note Debugging::.

*Note How to change the list of flags::.

3.9.6.13 Optimization-Flags
...........................

Here you can modify the list of Optimization-Flags, which you can turn on or
off *note Optimizations::.

*note How to change the list of flags::.

3.9.6.14 User words
...................

Here you can define your own list of words, which can be specially
highlighted, when syntax highlighting is enabled *note Preferences::.

 How to change the list of flags
................................

The syntax of the strings, which you can modify or add with the last
menu-entries is any string followed by an optional modifier with the
following meaning:

`%d'
     if you activate this option, you _must_ enter an integer there

`%d?'
     if you activate this option, you _can_ enter an integer there

`%c'
     if you activate this option, you _must_ enter a character there

`%c?'
     if you activate this option, you _can_ enter a character there

`%s'
     if you activate this option, you _must_ enter a string there

`%s?'
     if you activate this option, you _can_ enter a string there

`%s(STRING)'
     if you activate this option, you _must_ enter a string, which contains
     only characters defined by the string STRING, there

`%s?(STRING)'
     if you activate this option, you _can_ enter a string, which contains
     only characters defined by the string STRING, there


As an example: the string for the `-O' option is defined as `-O%d?' and the
`-d' option *note Debugging:: is defined as
 `-d%s(MNDyrxjsLtfcSlgRJdkamp)'
which means, the string after `-d' must be a combination of the characters in
 `MNDyrxjsLtfcSlgRJdkamp'
If you leave the dialogs for modifying the flag lists with the _OK_ button or
if you activate the _Default_ button, all flags are disabled

3.9.7 Save options
------------------

Here you can save all the options you currently customized to a file.  RHIDE
restricts this to saving them only to a file with the `.gpr' suffix (and
`.gdt' for the desktop file).

3.9.8 Load options
------------------

Here you can load the options from any existing project file.

3.10 Windows
============

In this menu you get the functions for arranging, resizing and switching
between the windows on the desktop:

3.10.1 Size/move
----------------

With this function you can resize and/or move the current window. After
selecting this, the frame of the current window will be drawn light-green and
you can move it with the cursor-keys. To resize it, press <Shift+> cursor-keys.
To exit the moving/resizing function, press <ESC> or <ENTER>. Alternatively
you can use the mouse.  For moving, click on the top of the window and hold
the left button down. Now you can move the window by moving the mouse. To
resize it, click on lower right corner of the window, hold the button down
and resize the window by moving the mouse. (This function has the hotkey
<Ctrl+F5> )

3.10.2 Zoom
-----------

This brings up the window to maximal size or to previous size.  (hotkey <F5> or
click with the mouse at the symbol on the right upper corner of the window)

3.10.3 Tile
-----------

This arranges all the editor-windows on the desktop, to see them all
simultaneously.

3.10.4 Cascade
--------------

This arranges all the editor-windows on the desktop, to see the contents of
the current editor-window and the top-frame of all the others.

3.10.5 Next
-----------

Hotkey <F6> switches to the next window on the desktop.

3.10.6 Previous
---------------

Hotkey <Shift+F6> switches to the previous window on the desktop.

3.10.7 Close
------------

This closes the current window. If it is an editor-window and its contents
were modified, you will be prompted to save it. Hotkey <Alt+F3> or click with
the mouse on the upper-left symbol of the frame.

3.10.8 List
-----------

Hotkey <Alt+0> brings up a list of all windows that are currently on the
desktop. You can select one of them and press <ENTER> to switch to it. With
<Del> you can close the selected window.

3.10.9 Project
--------------

With this function you can select the project window *note Project window::.
If it was closed, it will be opened.

3.10.10 UserScreen
------------------

Hotkey <Alt+F5> shows the contents of the DOS-Screen.  To leave this
function, do any event. That means, press any key, or click with the mouse.

3.11 Help
=========

In this menu you have access to many predefined help entries in the big help
system.

3.11.1 Help
-----------

This opens the INFO viewer. Many thanks at this point to Salvador Eduardo
Tropea (SET). He wrote the very good INFO viewer for use with RHIDE. This was
also the most important reason for me to write the documentation in Texinfo,
because you have now an online help available with the produced INFO file
`rhide.info'.

Pressing <F1> invokes the help system from everywhere.  For help on using the
INFO viewer, press <F1> within the help window.  But the above things work
only if you have correctly installed the INFO files that come with RHIDE.

If you have installed the binary archive of RHIDE as described in the
`readme.bin', the INFO files are in `%DJDIR%/info'. If you have not modified
your `djgpp.env' file, this directory is searched for the INFO files.

But you can put the INFO files in any directory you want, if you add this
directory to the %INFOPATH% variable in your `djgpp.env' file in the section
for `info'.

3.11.2 RHIDE Help index
-----------------------

This brings up the help window with the main index for getting help for RHIDE.

3.11.3 Syntax help submenu
--------------------------

In this submenu you can set the files to be searched for getting syntax help
and you can also customize the options, how this is done.

3.11.3.1 Syntax help
....................

If you are in an editor window, and you press <Ctrl+F1> , you get help about
the function under or before the cursor.  But only if this function is
documented in the files you have given to be searched for *note Files to
search::.  If there was no help found you will be informed.  This feature can
be used also by clicking with the right mouse button on the word.

3.11.3.2 Files to search
........................

Give here a space separated list of files (if you give no suffix, the
standard suffixes are tried) which should be scanned for getting help for a
word.

3.11.3.3 Options for searching
..............................

Here you can give some options, how the syntax help should work. The
following search methods are selectable and other options. For all the search
methods it is possible to get more than one matching topic. If that is true,
you will find a list, from which you can select the wanted topic.

 Exact
......

When this is selected, you will get syntax help only, if in the selected
files a topic with that exact name was found.

 Substring
..........

When this is selected, you will get syntax help, when the word is a substring
of any of the nodes in the files to be searched for syntax help.

 Fuzzy
......

This method uses a "Fuzzy search" for getting syntax help. That means it
looks also for nodes, which are similar to the word for which you want to get
syntax help.

 Search options
...............

These are several options for the textual search:
`Case sensitive'
     When this is selected, the textual search is case sensitive.


Here you can set the bound for the fuzzy search. The range is from 1 to 1000
where 1 means that mostly every string matches any other string and 1000
means the exact match.

3.11.4 Index for syntax help
----------------------------

Here you can get a list of all available topics for the syntax help, from
where you can choose one (<Enter>, <Space> or double click).

3.11.5 libc reference
---------------------

This is a separate menu entry to open the libc reference, because this is
used very often when writing C programs.

3.11.6 Help about help
----------------------

This brings up a help-window for instructions and available keystrokes when
using the integrated INFO viewer.  (see *Note Top: (infview)Top.)

4 Detailed description of some parts of RHIDE
*********************************************

4.1 Selecting a window
======================

To select a window you can do the following. If the window has a number, this
is right on the top-frame, you can select this window by pressing <Alt> and
this number (but only if the number is a single digit).  Or you click
anywhere in the window or on the frame of the window with your mouse.

4.2 How the editor works
========================

This section should describe the work of the editor. But because the editor
is now so complex and, not my own work, there is now separate documentation
with more detailed and better description see *Note Documentation for the
editor: (setedit)Top.  But you can read also more from my doc, which
describes the most common (for me) usage of the editor.

Here I describe most of the editor commands. If there is a key command like
`Ctrl+Q+Y', press <Ctrl> and <Q> simultaneously and after this press <Y>.

I strongly recommend not to use the technique by holding down the <Ctrl> key
when pressing the second key in such key combinations, because for instance
when you press `Ctrl+K' and then `Ctrl+C' you will be prompted if you want to
interrupt RHIDE (because you pressed the interrupt key). But if you really
want to use this methode, you should use the `-C' commandline switch when
starting RHIDE to disable the handling of `SIGINIT'.

4.2.1 Erasing commands
----------------------

   * <Ctrl+G> or <Del> erases the character under the cursor or the selected
     text.

   * <Ctrl+H> or <Backspace> erases the character before the cursor or the
     selected text.

   * <Ctrl+Y> erases the current line.

   * <Ctrl+Q+Y> erases from the cursor to the end of the line.

   * <Ctrl+Q+H> erases from the cursor to the beginning of the line.

   * <Ctrl+T> erases from the cursor to the beginning of the next word on
     this line.

   * <Ctrl+Backspace> erases from the cursor to the beginning of the previous
     word.

4.2.2 Cursor moving commands
----------------------------

   * <Ctrl+S> or <Arrow left> moves the cursor one character left.

   * <Ctrl+D> or <Arrow right> moves the cursor one character right.

   * <Ctrl+E> or <Arrow up> moves the cursor one line up.

   * <Ctrl+X> or <Arrow down> moves the cursor one line down.

   * <Ctrl+A> moves the cursor one word left.

   * <Ctrl+F> moves the cursor one word right.

   * <Ctrl+C> or <Page down> moves the cursor one page down.

   * <Ctrl+R> or <Page up> moves the cursor one page up.

   * <Ctrl+Q+D> or <End> moves the cursor to the end of the line.

   * <Ctrl+Q+S> or <Home> moves the cursor to the beginning of the line.

   * <Ctrl+Q+R> or <Ctrl+PgUp> or `Ctrl+Home' moves the cursor to the
     beginning of the file.

   * <Ctrl+Q+C> or <Ctrl+PgDown> or `Ctrl+End' moves the cursor to the end of
     the file.

4.2.3 Text selecting and searching commands
-------------------------------------------

   * <Shift> cursor keys select the text as the cursor moves.

   * <Ctrl+Ins> or <Ctrl+K+K> copy the selected text to the clipboard.

   * <Shift+Del> or <Ctrl+K+Y> move the selected text to the clipboard.

   * <Shift+Ins> or <Ctrl+K+C> copy the selected text from the clipboard to
     the current cursor position.

   * <Ctrl+Del> delete the selected text.

   * <Ctrl+Q+A> open the replace dialog.

   * <Ctrl+Q+F> open the find dialog.

   * <Ctrl+L> repeat the last replace or find operation.

   * <Ctrl+K+H> unselect all.

4.2.4 Block commands
--------------------

   * <Ctrl+K+B> sets the start of the selected block.

   * <Ctrl+K+K> sets the end of the selected block.

   * <Ctrl+K+I> indents the selected block by inserting a space at the
     beginning of each line inside the block.

   * <Ctrl+K+U> unindents the selected block by erasing one character from
     the beginning of each line inside the block, which starts with a tab or
     space.

   * <Ctrl+K+M> converts all alpha characters inside the selected block to
     upper case.

   * <Ctrl+K+O> converts all alpha characters inside the selected block to
     lower case.

   * <Ctrl+K+V> moves the selected block to the current cursor position.

   * <Ctrl+K+Tab> indents the selected block by using the last non selected
     line as reference for indenting.

   * <Ctrl+K+Shift+Tab> unindents the selected block by using the last
     non-selected line as reference for unindenting.

   * <Ctrl+K+R> inserts the contents of a file at the current cursor position.

   * <Ctrl+K+W> writes the selected block to a file.

4.2.5 Other commands
--------------------

   * <Ctrl+V> Toggle insert-/overwrite-mode.

   * <Ctrl+O> Toggle auto-indent-mode on/off.

   * <Ctrl+J> Goto line ... (Will be prompted for.)

   * <Ctrl+K+?> ?, a digit (<0> - <9>). Set a marker in the text (up to ten
     different markers).

   * <Ctrl+Q+?> ?, a digit (<0> - <9>). Jump to a marker, which you have
     previously set.

   * <Shift+Space> Executes a macro, which can be defined externally by
     analyzing the last two characters before the cursor *note Defining
     macros::.

If you have set some markers, they will be stored, so you can use them later
when restarting RHIDE.

4.3 Some hints and problems
===========================

To compile only a single file, you don't need to include it in a project.
You only have to open it and do a compile. If a file is in your project, you
can compile it, if you are in its editor-window or if you are in the
project-window and this file is selected.

Warnings and errors from compiling a file are listed in the message-window.
If there are warnings or errors, you can jump to the corresponding source by
hitting <ENTER> on this message. If this file wasn't already opened, it will
be opened.

4.3.1 Problems with automatic dependencies
------------------------------------------

Most checking of the dependencies works correctly, but there are some few
situations, where this checking gets confused. The first results in the fact
that I implemented a cache function for getting the modification time of
files, that means, most files are 'stat'ed only once, after starting RHIDE.
But if someone modifies one of the files, which are in the cache, (this can
be another program, when you run RHIDE in a multitasking environment, such as
Windows) or if you run your project and it modifies some of these files, the
internal cache is after this not up to date.

Here is another situation. Your source files are not in the current
directory. You have opened a source file for editing and successfully built
your project. Now you leave RHIDE, because you want to debug your program
with `FSDB', you copy the source file (in this case it is the file, which you
have opened in the IDE) to the current directory. Now you debug it and there
are some errors. You restart RHIDE to make the changes in the file. The
previously opened file will be opened automatically and you edit it. If you
do now a _Make_, RHIDE tells you, that your project is up to date, because it
searches for source files at first in the current directory, and there is the
unmodified file.

In this chapter I will give you for some special parts a more detailed
description of what they do.

4.4 Project window
==================

The project window shows you every file, which you have included in your
project. Most time you work with RHIDE this window should be visible, but you
can also close it *note Close::.

4.4.1 Items of your project
---------------------------

The items in the project window, and therefore also in your project, are
sorted in alphabetical order. This has the effect of faster finding an item
and you can also move the selecting bar to a specified item by typing the
name of this item.

Normally, the alphabetic order of the project items causes no problems because
the linker searches at first _every_ object file for unresolved symbols
before any library. The statement, the the GNU linker is a one pass linker
makes sense only for libraries, because they are checked only once for
unresolved references. That means, if you include libraries in your project
you must know about the order, where this library is put on the command line
when linking your program.

If you have problems with that order, or if you really want to have one
object file (or library) before some others, you must rename them, to get the
right position from the name.

4.4.2 Open a project item
-------------------------

To open an editor window with the selected item press either <ENTER> or
<SPACE>. If there was already a window with this file opened on the desktop,
this window will be selected.  This works only if the selected item has a
known suffix *note Known suffixes::. If the selected item is a project file,
that project will be opened with the side effect that if you close this
project, the previous one will be reopened.

4.4.3 Dependencies of project item
----------------------------------

If you have compiled a file already in RHIDE, you bring up a list with all
dependencies of that file. In this list the files are show by their basename
followed by the directory and they are also sorted in alphabetical order.
From here you can also open an editor window with the selected dependency by
pressing <SPACE> or <ENTER> on that item.

4.4.4 Local options for a project item
--------------------------------------

You can change many options for a project item, which are in effect only for
this file. To do this, hit <Ctrl+O> on the selected item and a dialog is
shown, where you can change the options.

At this time you can change the following options.

 Local commandline options
..........................

Here you can give some additional defines or any other commandline options,
when compiling this item.

 exclude from link
..................

This is a switch to tell RHIDE, that this file should not be linked with your
program, but it is compiled and it is checked to determine if your program is
up to date.

 rebuild seldom
...............

When you select this option the item is compiled only if it does not already
exist. For most project items this is not usefull but if you have included in
your project other projects which create a library this might be usefull,
especially if the library has many source files and you know, that they
change very seldom.

 Name of the output file
........................

Here you can specify another name as the compiled file. Put here only the
basename of the file (without any directory)

 Compiler type
..............

From that list you can select exactly one type of the compiler, which is used
to create your output file. Possible values are:

`Auto'
     This is the default and should be used in most cases. When this type is
     selected, RHIDE selects the correct compiler depending on the suffixes
     of your source and output file.

`User'
     If you have any special compiler, which is not known to RHIDE, to create
     your output file, you must select this and give RHIDE also the calling
     syntax of that compiler (see below)

`None'
     If you don't want to compile this item select this.

`GNU C compiler'
     Tell RHIDE to compile this file like a normal GNU C source file.

`GNU C++ compiler'
     Tell RHIDE to compile this file like a normal GNU C++ source file.

`GNU assembler'
     Tell RHIDE to compile this file like a normal GNU assembler file.

`GNU Pascal compiler'
     Tell RHIDE to compile this file like a normal GNU Pascal file.


 User defined compiler
......................

If you have selected the User compiler type, you have to put in the next
input line the specs on how to call the compiler. These specs can use any
variables that are known to RHIDE *note Builtin variables:: together with
normal text. As an example I show here, how the builtin C compiler is defined
(the backslashes at the end of the lines are used only here to show, that the
line is continued, they are NOT part of the specs):


$(RHIDE_GCC) $(INCLUDE_DIRS) $(C_DEBUG_FLAGS) $(C_OPT_FLAGS) \
$(C_WARN_FLAGS) $(C_C_LANG_FLAGS) $(C_EXTRA_FLAGS) $(LOCAL_OPT) \
-c $(SOURCE_NAME) -o $(OUTFILE)

 Error checking
...............

Here you can select how errors or warnings that are produced by the compiler,
are checked. Possible values are:

`Auto'
     Let RHIDE select the correct way for checking the errors

`User'
     Use your own external program to check the output of the compiler to
     `stderr'

`None'
     Do not check any errors, assume that the compiler does it's job every
     time successfully.

`builtin C'
     Check the errors like when compiling a C file

`builtin assembler'
     Check the errors like when compiling an assembler file

`builtin linker'
     Check the errors like when linking

`return value'
     Determine only if the compiling was successful or not by checking the
     return value of the compiler (zero for success)


 Error program
..............

If you have selected above the User error checking, type here the program,
which should check for errors and/or warnings.  What the external error
checking program should do:

   - The program must take a filename as argument, which contain the output
     to stderr from the compiler (Error and warning messages)

   - The program has to write to stdout the Warnings, Errors or messages in a
     special format.

    `Errors'
          A line that starts with the string "!Error" (without the double
          quotes) optionally followed by "!File" and a filename in single
          quotes and "!Line" followed by a space and a line number and
          "!Column" followed by a space and a coloumn number.

          If "!Line" and/or "!Column" are not used they dafault to 0.  The
          next line contain the error text.  Example:


          !Error!File'test.c'!Line 17
          This is a sample error message

          This means, that in file 'test.c' at line 17 an error occurred with
          the description 'This is a sample error message'

    `Warnings'
          Warnings have the same format, except that !Error is replaced by
          !Warning.

    `Any other line'
          is treated as a simple message optionally preceeded by !File and
          !Line.



4.5 Builtin compiler specs
==========================

WARNING: THE LIST OF VARIABLES AND STRINGFUNCTIONS DESCRIBED BELOW MIGHT NOT
BE UPTODATE. IF YOU WANT TO GET INFORMATION ABOUT ALL FEATURES PLEASE LOOK IN
THE SOURCES FOR RHIDE.

RHIDE uses for compiling, linking, and the other stages of generating a file
also specs, like you can change in the local options for a project item *note
Local options::. Here the specs, which are used currently:

$(RHIDE_COMPILE_C)
     For compiling C source files

$(RHIDE_COMPILE_CC)
     For compiling C++ source files

$(RHIDE_COMPILE_ASM)
     For compiling assembler source files

$(RHIDE_COMPILE_PASCAL)
     For compiling Pascal source files

$(RHIDE_COMPILE_OBJC)
     For compiling objective C source files

$(RHIDE_COMPILE_LINK)
     For linking

$(RHIDE_COMPILE_LINK_PASCAL)
     For linking when the project contain Pascal source files

$(RHIDE_COMPILE_LINK_PASCAL_AUTOMAKE)
     This spec is used only, when you have set the *note Primary file::, to
     tell RHIDE, not to check for dependencies but to use the 'automake'
     feature of GPC.

$(RHIDE_COMPILE_ARCHIVE)
     For creating a library

$(RHIDE_FSDB)
     For calling FSDB.

$(RHIDE_GDB)
     For calling GDB.

$(RHIDE_GPROF)
     For calling GPROF.

$(RHIDE_GREP)
     For calling grep.


All of these specs have a default content in RHIDE, but they can be
overwritten by setting the environment variable with the same name and any
other contents.

4.6 Builtin variables
=====================

This section describes, which variables can be used within RHIDE to get
values from some of the configurations, which you have made inside RHIDE.

All of these variables are referenced by a name enclosed in parentheses
preceeded by a dollar sign. Example: `$(RHIDE_GCC)'. You can overwrite any of
the following variables, if you define in your environment the same variable
with any contents you want.

When RHIDE tries to get the contents of such a variable, it searches at first
if it is found in it's internal database. If it was not found, the environment
is checked for such a variable and if that fails, the resulting value is the
variable itself.

In addition to the use of variables, RHIDE has a limited ability of using
string manipulating functions. I have implemented some of the functions,
which are available with GNU make. They have the same name and should work
exactly like the GNU make counterpart.

`$(strip arg)'
     This function removes any leading and trailing whitespace and converts
     all multispaces to single spaces from the (whitespace separated list)
     `arg'.

`$(addsuffix arg1,arg2)'
     These functions append on each argument from the whitespace separated
     list `arg2' the string `arg1'.

`$(addprefix arg1,arg2)'
     This is the same as `$(addsuffix arg1,arg2)', except that it puts the
     string `arg1' before each argument from `arg2'.

`$(notdir arg)'
     This removes any directory part from the argument `arg'.

`$(dir)'
     This extracts only the directory part from the argument `arg'. If there
     was no directory in `arg', an empty string is returned. (The directory
     contains also the drive letter, if there was one)

`$(subst arg1,arg2,arg3)'
     This replaces every occurrence of `arg1' in `arg3' with `arg2'

The following variables have a special meaning in RHIDE with the default
contents:
$(RHIDE_GCC)
     GCC

$(RHIDE_AS)
     GCC

$(RHIDE_GXX)
     GCC

$(RHIDE_GPC)
     GPC

$(RHIDE_AR)
     ar

$(RHIDE_LD)
     GCC

$(RHIDE_LD_PASCAL)
     GPC

$(RHIDE_ARFLAGS)
     rcs

$(RHIDE_INCLUDES)
     $(SPECIAL_CFLAGS) $(addprefix -I,$(INCLUDE_DIRS))

$(RHIDE_LIBDIRS)
     $(addprefix -L,$(LIB_DIRS))

$(RHIDE_LIBS)
     $(addprefix -l,$(LIBS))

$(RHIDE_LDFLAGS)
     $(SPECIAL_LDFLAGS) $(addprefix -Xlinker ,$(LD_EXTRA_FLAGS))

$(RHIDE_COMPILE_C)
     $(RHIDE_GCC) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_C_LANG_FLAGS) \
     $(C_EXTRA_FLAGS) $(LOCAL_OPT) -c $(SOURCE_NAME) \
     -o $(OUTFILE)

$(RHIDE_COMPILE_C_FORCE)
     $(RHIDE_GCC) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_C_LANG_FLAGS) \
     $(C_EXTRA_FLAGS) -x c $(LOCAL_OPT) -c $(SOURCE_NAME) \
     -o $(OUTFILE)

$(RHIDE_COMPILE_CC)
     $(RHIDE_GXX) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_C_LANG_FLAGS) \
     $(C_CXX_LANG_FLAGS) $(C_EXTRA_FLAGS) $(LOCAL_OPT) \
     -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_CC_FORCE)
     $(RHIDE_GXX) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_C_LANG_FLAGS) \
     $(C_CXX_LANG_FLAGS) $(C_EXTRA_FLAGS) -c c++ $(LOCAL_OPT) \
     -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_ASM)
     $(RHIDE_AS) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_EXTRA_FLAGS) \
     $(LOCAL_OPT) -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_ASM_FORCE)
     $(RHIDE_AS) $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) \
     $(C_OPT_FLAGS) $(C_WARN_FLAGS) $(C_EXTRA_FLAGS) \
     -x assembler $(LOCAL_OPT) -c $(SOURCE_NAME) \
     -o $(OUTFILE)

$(RHIDE_GPC_FLAGS)
     $(RHIDE_INCLUDES) $(C_DEBUG_FLAGS) $(C_OPT_FLAGS) \
     $(C_WARN_FLAGS) $(C_P_LANG_FLAGS) $(C_EXTRA_FLAGS)

$(RHIDE_COMPILE_PASCAL)
     $(RHIDE_GPC) $(RHIDE_GPC_FLAGS) $(LOCAL_OPT) \
     -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_PASCAL_FORCE)
     $(RHIDE_GPC) $(RHIDE_GPC_FLAGS) -x pascal \
     $(LOCAL_OPT) -c $(SOURCE_NAME) -o $(OUTFILE)

$(RHIDE_COMPILE_LINK)
     $(RHIDE_LD) $(RHIDE_LIBDIRS) $(C_EXTRA_FLAGS) \
     $(RHIDE_LDFLAGS) -o $(OUTFILE) $(OBJFILES) \
     $(LIBRARIES) $(RHIDE_LIBS)

$(RHIDE_COMPILE_LINK_PASCAL)
     $(RHIDE_LD_PASCAL) $(RHIDE_LIBDIRS) $(C_EXTRA_FLAGS) \
     $(RHIDE_LDFLAGS) -o $(OUTFILE) $(OBJFILES) \
     $(LIBRARIES) $(RHIDE_LIBS)

$(RHIDE_COMPILE_LINK_PASCAL_AUTOMAKE)
     $(RHIDE_LD_PASCAL) $(RHIDE_LIBDIRS) $(RHIDE_LDFLAGS) \
     -o $(OUTFILE) \
     -automake=\"$(strip $(RHIDE_GPC_FLAGS))\" \
     $(RHIDE_GPC_FLAGS) $(SOURCE_NAME) $(LIBRARIES) $(RHIDE_LIBS)

$(RHIDE_COMPILE_ARCHIVE)
     $(RHIDE_AR) $(RHIDE_ARFLAGS) $(OUTFILE) $(OBJFILES)

$(RHIDE_FSDB)
     fsdb $(OUTFILE) $(addprefix -p ,$(SRC_DIRS)) $(PROG_ARGS)

$(RHIDE_GDB)
     gdb $(OUTFILE) $(addprefix -d ,$(SRC_DIRS))

$(RHIDE_GREP)
     grep -n $(prompt arguments for GREP)

$(RHIDE_GPROF)
     gprof $(OUTFILE)


The following are not used as real variables, but they are used to get the
contents of options from RHIDE. But you can override them also by setting
them as an environment variable.

$(INCLUDE_DIRS)
     All the include directories

$(LIB_DIRS)
     All the library directories

$(SOURCE_NAME)
     The actual compiled source file

$(OUTFILE)
     The actual created file

$(C_DEBUG_FLAGS)
     All the debugging flags

$(C_OPT_FLAGS)
     All the optimization flags

$(C_WARN_FLAGS)
     All the warning flags

$(C_C_LANG_FLAGS)
     All the C language flags

$(C_CXX_LANG_FLAGS)
     All the C++ language flags

$(C_P_LANG_FLAGS)
     All the Pascal language flags

$(LIBS)
     All the libraries, which are given in the libraries options

$(LD_EXTRA_FLAGS)
     All the additional linker options

$(LOCAL_OPT)
     All the local options for that project item

$(OBJFILES)
     All the destination files, which are part of the project and which are
     not a library and not excluded from linking

$(LIBRARIES)
     All the libraries, which are explicitly included in the project and not
     excluded from linking

$(SPECIAL_CFLAGS)
     Some special flags for `GCC'. Currently only the `-nostdlib' switch.

$(SPECIAL_LDFLAGS)
     Some special flags for `GCC' when linking. Currently only the switches
     `-pg' and `-nostdlib'.

$(prompt TITLE)
     RHIDE prompts for arguments which get the title `TITLE' and insert the
     parameters here.


4.7 Change the defaults of RHIDE
================================

If you have special wishes for compiling your source files, you can configure
for RHIDE mostly everything. For adding support for other than the builtin
known file types *note Builtin variables::. If you want to change the
behavior of RHIDE for compiling all the known file types you should know at
first really what you do. If you think, this is a good idea or if you only
want only check if it works you can do it.

Before RHIDE compiles any file (this includes also linking and building a
library) it searches the environment for a variable after the following
scheme: When compiling a file with suffix `.c' to a file with suffix `.o'
RHIDE checks for the variable $(RHIDE_COMPILE.c.o). If this variable is
defined the contents of this variable is taken as the compile spec.

If you want to change the specs for linking you must take as destination
suffix `.exe' or `.' and as source suffix the suffix of your object files.
Example:

$(RHIDE_COMPILE.o.)

4.8 Message window
==================

This window shows every time you compile a file the resulting messages, which
GCC produces. These messages were converted in a special format to show them
in the window. Some of the messages contain a file eventually combined with a
line number. If you press <ENTER> on such a message, the corresponding source
line in the file will be highlighted and the window with this file will be
selected. If this file is not already on the desktop, it will be opened.

If the file, to which the messages refer, is already in the foreground you can
see the selected source line for your messages directly on the screen.

4.9 Syntax highlighting
=======================

Syntax highlighting is now supported directly by the editor. It should work
in mostly every situation for all the supported types. Currently (in RHIDE)
only the C/C++ style syntax highlight and the Pascal style syntax highlight
are supported.

With which style a file is highlighted is chosen by RHIDE by checking the
suffix of the file and determining the file type from that suffix *Note Known
suffixes::.

4.10 Checking the dependencies
==============================

This is one of the main parts of RHIDE. To speed up the work, I have added a
cache for checking the modification time of a file and for finding a file
(computing the full name of a file). But sometimes the data in the cache
isn't valid, especially when running under Windows. If you see this, you can
clear the cache by leaving RHIDE and starting again.

If you didn't do any special things but have problems with it, please run
RHIDE with the `-df' switch and try to find out, where the problem is and
post it to me so I can fix it.

4.11 What is Turbo Vision
=========================

The Turbo Vision library is part of Turbo C++ version 3.1. I have ported this
library to use with DJGPP because I think it is the most powerful text
windowing library, which is available for MS-DOS. With the help of this
library you can write a front end application which looks very well and has
an interface that is easy to use.

The Turbo Vision library is not only a window based text user interface, it
is also a very good event handling mechanism. It supports the use of the
mouse and keyboard with the ability of defining and using of hotkeys.  That
means, you can assign to some key or combinations of keys, which function
should be executed.

The main parts of an application, which is using this library, are the
desktop, the menu bar and the status line. The menu bar is usually shown as
the topmost line of the screen. There are shown the main parts of the pull
down menus, from where you can select the most functions, which are
implemented in an application.

To use the menu you can use the mouse as well the keyboard. With the mouse
you can click every where on a menu entry and the corresponding function will
be executed. There are some different actions, which a menu entry can have.
At first some of them, these are, for example, all the entries in the menu
bar, open a submenu with more menu entries which are related to the name of
this main entry. And the others, most in such a submenu, execute a definite
function of the application.

With the keyboard you can walk through the menu very simply. Press <F10> to
activate the menu bar. In the pull down menus you can use the cursor keys to
move the highlighted bar up and down and with the cursor right and left keys
you can switch to next or previous menu. With the <ENTER> key you activate
the function, which corresponds to this entry. If this was a submenu, which
is indicated with a symbol like a small right arrow, this will be opened.

If you walk through the menu with the cursor keys or the mouse (hold the left
mouse button down and move the mouse) in the status line will be shown for
each entry a short hint for the function of this menu entry.

4.12 How the dialogs work
=========================

In a dialog, like the file open dialog, are many things which you can select
or where you can type in some data. At first some general functions. If you
press <ESC> the dialog will be closed and nothing will be changed. The same
can be done with the mouse by clicking on the close symbol (this is the small
symbol on upper left frame of the dialog).

In the next paragraphs I will describe the most used elements of a dialog.
For selecting each element of a dialog you can use the <Tab> key to select
the next element in the dialog or the `Shift+Tab' key, to select the previous
element.

A button is a rectangle with some text on it. If you activate such a button a
specified action is executed. To select a button you can use the <Tab> key,
until the button is specially highlighted and press <ENTER> then. Most times
a character of the text on this button has a different color. So you can
press <Alt> plus this character to activate the button. With the mouse you
can simply click on a button to activate it.

A Listbox is a collection of some strings in one or more columns and rows as
needed. The project window *note Project window:: is such a Listbox with the
names of the project items. You can use the cursor keys to move the focus bar
in the list, or if it is a sorted Listbox, you can also type some characters
and the focus will move to the item, which starts with these characters. To
select a item in a list box, press <SPACE> or <ENTER> or double click with
mouse on it.

In an input line you can type some text which can be edited with the usual
editing keys.

A checkbox is a collection of options, which can be turned on or off.  Each
option has in front of it a small indicator, if it is turned on (an X is
shown) or not (the X is not shown). To toggle such an option, use the cursor
keys to move the focus to the option you want and press <SPACE> or, if a
character in an option string is highlighted you can press this key and the
option will be turned on or off or click with the mouse on the option.

Radiobuttons are similar to Checkboxes, but there you can select only one of
all the shown options.

4.13 Defining macros
====================

Please look for a detailed documentation here: *Note Documentation about
Pseudo Macros: (setedit)Pseudo Macros.

4.14 The INFO Viewer
====================

The integrated help system of RHIDE is based on the INFO Viewer written by
salvador@inti.gov.ar <Salvador Eduardo Tropea (SET)>. It gives you access to
all the INFO files which you have installed in the correct directories as is
done for `info.exe'.

To get help about the INFO Viewer hit <F1> when the help-window is opened or
follow this link to *Note Top: (infview)Top.

In addition to getting help with this system you can also copy text from the
help screen to the clipboard. This is useful if you want for instance to copy
an example from the libc reference in your program. This feature is not so
powerful as in the editor, but it is good enough. To mark some text use the
<Shift> and cursor keys and copy the selected text with `Ctrl+Ins' to the
clipboard.

In RHIDE you have also the possibility to get help about a specific function.
Currently this works only for functions, which are documented in the libc
reference. For doing this, move the cursor to the function and hit <Ctrl+F1> or
click with the right button of the mouse on that word.

4.15 RCS and RHIDE
==================

RHIDE knows a little bit about RCS, the Revision Control System. Since RCS is
available also for DJGPP I enabled now some features to use RHIDE also on
packages which use RCS.

RHIDE can handle RCS files in the way, that it searches for a checked in
source file if the normal source file was not found. The complicatest part
here was to determin the correct RCS file name from the source name.
(Especially under DJGPP this is a problem since under raw DOS it is not
possible to use names like 'foo.c,v').

So I decided to use the external program `rlog' which comes with the RCS
package to determine the actual correct RCS source name. I did so because the
DJGPP implementation knows enough about the DOS limitation and how to solve
them.

This help here is not ment to be a RCS introduction. If you don't know what
RCS is or what can be done with it, please look in the manuals wich come with
RCS.

Here now what RHIDE knows about the RCS files. If a source file was not
found, it's RCS name is computed with the spec `$(RHIDE_RLOG)' which defaults
to `$(shell rlog -R $(rlog_arg))' where `$(rlog_arg)' is substituted at
runtime with the actual wanted source file.

This spec can be overwritten to speed it up. An example for this can be found
in the distributed sample environment file `rhide_.env'.

When RHIDE only wants to compile the file or only to get the modification
time it is temporary checked out (without locking it) and after the needed
operation (compiling) it is removed (for checking the modification time it is
not checked out, but the time form the RCS file is taken).

If you want to open that file for editing the same is done but now it is
checked out with setting a lock and it is not checked in after closing the
window. The spec for checking the file out is `$(RHIDE_CO)' which can be
overwritten also and it defaults to `$(shell co -q $(co_arg))' where the
switch `-l' is added when it is checked out for edititing otherwise
`$(co_arg)' is substituted at runtime only with the wanted source file.

5 Debugging with RHIDE
**********************

For debugging your programs you need now no external debugger, because RHIDE
has one integrated. The integrated debugger is not code which I have written,
but it is GDB 4.16, which is linked in RHIDE.

Because RHIDE uses a special method to communicate with GDB it is currently
not possible to use all of the features, which GDB has. I have implemented at
this time the most important functions, which are needed to debug your
program. So it is not possible to give GDB the same commands as when running
GDB stand alone. That means, if you need any very special feature of GDB you
must run GDB.

The integrated debugger is a real source level debugger like GDB. If you step
through your program you will see every time exactly where in the sources you
are. But to use the ability to debug your program needs, that you have
compiled your source files with debugging information and these symbols must
not have been stripped from the executable.

5.1 Limitations of the integrated debugger
==========================================

Because the integrated debugger is GDB, you will have all the limitations
which GDB has in addition to well known DJGPP and/or MS-DOS limitations.
Here is a (not complete) list of known misfeatures:

   * Signals are not correctly handled every time by distinguishing between
     the debuggee and RHIDE

   * Remote debugging is NOT supported

   * Debugging of graphic programs may work or not depending on the software
     you are using. Currently only the VESA modes and the standard VGA
     graphic modes are supported.

   * When using the integrated debugger under Windows 3.1x (in Windows 95
     there is no such limitation) the number of breakpoints is limited to 3,
     because you can use there only hardware breakpoints. The i386 supports
     only 4 hardware breakpoints and 1 is needed for internal use.  This is a
     common problem for all DJGPP debuggers. (Try to use FSDB with more than
     3 breakpoints under Windows 3.1x)

   * Sometimes the source line, which is shown by RHIDE in assuming that the
     execution is there, is not correct. But this is NOT a bug of RHIDE and
     NOT of GDB. This is a bug in GCC which produces wrong line number
     information in the object files. Here is a very simple test program,
     with which you can see this problem.

          /* This is an example, that GCC produces wrong line number
             information for code which is optimized out. (compile this
             with -O) */

          int a = 1;
          int b = 2;

          int main()
          {
            if (a == b) return 0;
            if ((a + 1) == b) return 1;
            return 0; /* The debugger should never come here,
                         but it comes */
          }


5.2 Dual display debugging
==========================

RHIDE supports now also to use an installed dual display. This is when you
have installed in addition to your VGA card a monochrome display card
together with a monitor. RHIDE checks this by asking the BIOS if it is
present and if this is true and the option is enabled *note Preferences::
then RHIDE switches automatically to the secondary display when debugging and
your program will run on the primary display.

With this debugging technique you will get the best debugging results
especially when debugging graphics programs.

To use the dual display with RHGDB use the `-D' switch for RHGDB.

5.3 Using the integrated debugger
=================================

If you are familiar with Borland's debugger, you will see, that most of the
functions of that debugger are implemented in the same or in a similar way
(this includes the key bindings).

5.3.1 Stepping through the source code
--------------------------------------

For stepping through your code, there are three ways. This is at first the
Step-function <F8>. With this you execute a complete source line. If there is
a function call at the current execution point, this function is called
without debugging it. This technique is the same like the `next'-command from
GDB.

The next way is the Trace-function.  It is like the Step-function, <F7>,
except that if there is a function call at the current execution point, you
will go into this function when there is debugging information for that
function available.  This technique is the same as the `step'-command from
GDB.

And the third way is the Goto-Cursor-function. For this, move the cursor to
the line in your source code and press <F4>. Now the execution of your
program is continued until it comes to that line. Sometimes you will get an
error message, that for the specified line is no code generated.  This comes
from the optimization of your code by GCC. In this case try a line below or
above.

5.3.2 Evaluating the contents of variables
------------------------------------------

You can evaluate also the the contents of variables, when your program has
been started. For this you can press `Ctrl+F4' and you will see a dialog,
where you can type in the expression to evaluate, a line with the result and
a line, where you can give the expression a new value. If you have pressed
this in an editor window, RHIDE tries to find the word under the cursor and
copies this as default in the expression input line. To get the contents of
this expression you have to press the _Evaluate_-button.

If the expression could not be evaluated so it is shown in the result line.
For the exact syntax of getting the contents of an expression see *Note
Expressions: (gdb)Expressions. You can also show the value of the expression
in several formats *note Output Formats: (gdb)Output Formats.

In addition to the functionality of the Borland debuggers, GDB (and of course
also RHIDE) can evaluate the result of function calls. If you have, for
example, in your debugged program a function
     int foo(int arg1)
     {
     /* do something and return a value */
     }
defined, you can type in the expression input line
     foo(16)
and you will get as result, what the function would return, if it is called
with the argument `16'. As arguments you can also use any known variable or
complex expressions.

A known limitation is, that the expressions are NOT checked for validity.
That means, you can produce any exception there, which will terminate your
program. As an example type in the expression input line
3/0
And, of course, you cannot assign to a function call a new value.

As an special side effect you can use this also as a calculator. You can
evaluate any trivial or complex expression and this is also available, if you
haven't started the integrated debugger.

5.3.3 Watching the contents of variables
----------------------------------------

In addition to a single look at the contents of a variable, you can add the
variable to a list which is updated after each debugger step and is shown in
the watching window. For this function you can use the hotkey `Ctrl+F7'.

Within the watch window you can press <Enter> on an expression to change that
expression (NOT the contents of that expression) or you can press <Del> to
remove the variable from the watch window.

5.4 Problems with C++ programs
==============================

Because GDB cannot handle correctly C++ debugging information when it is
generated as COFF debugging information (with stabs debugging information
there is no such limitation and you can skip reading more) you will have many
problems when debugging C++ programs to get the contents of a variable when
it is a member of a class. Because GDB does not detect, that your program is
a C++ program, it sees it as a normal C program and so GDB does nothing know
about classes and all what have to do with it.

For accessing the member of a baseclass you must do some tricks. Let me
explain it on an example:

     class A
     {
     public:
       int a;
     };

     class B : public A
     {
     public:
       void test();
     };

     void B::test()
     {
       fprintf(stdout,"%d\n",a);
     }

If you debug the program in the function `B::test()' and you want to get the
contents of the member `a', you have to access it with `this->A.a' !!! That
means: At first you must access all members with the implicit `this' variable
and at second you must give all baseclasses until that, where the member was
declared.

5.5 Using Breakpoints
=====================

Breakpoints are a very useful thing when debugging a program. You can set a
breakpoint at any location of your program and run it. It will be
automatically stopped, if the program execution reaches the breakpoint.

5.5.1 Setting a breakpoint
--------------------------

For setting a breakpoint there are two different ways. The first is by
setting a breakpoint at any line by pressing `Ctrl+F8'. You will see, that
there is a breakpoint set, that this line is shown in another color. If you
hit `Ctrl+F8' on a line, which has already a breakpoint, the breakpoint at
this line is removed.

5.5.2 Modifying and setting a breakpoint
----------------------------------------

The second way is by setting a breakpoint with the breakpoint dialog which is
selectable only from the menu. There you will see any breakpoint for your
program. These breakpoints can be modified now in many things.  In this
dialog you can enable/disable a breakpoint. This is not the same as deleting
and resetting it. If you disable a breakpoint, it is stored internally but it
is not used. If you enable it again all the settings for that breakpoint,
which you have already made, are remembered.

In the breakpoint dialog you can also set or delete a breakpoint with the
given buttons. If you want to set a new breakpoint, use the New-Button. Then
you will get a dialog which you also get when you press the Modify-Button. In
this dialog you can change many things of the breakpoint.

In this dialog is the only point for setting a breakpoint at a specified
function. For doing this you must set at first the type of the breakpoint to
Function. Then you can type in the function input line the name of the
function or hit <Ctrl+F1> to get a list of functions which are available from
where you can select one with <Enter>.

For setting a breakpoint at a specified line, set the breakpoint type to Line
and type in the filename and the linenumber.

The next what you can modify on a breakpoint is a condition. That means that
the breakpoint should stop your program only, if the condition is true. Write
the condition in the programming language of your source file and you can use
any accessible variable and you can call also functions of the debugged
program. For other information about the syntax see *Note Conditions:
(gdb)Conditions.

And at last you can give your breakpoints also a count. A breakpoint count is
a number, how often this breakpoint is ignored. That means, if you type
there, for example, `10', then the RHIDE stops the execution of the program
only, if it comes to that point the tenth time. WARNING: This count is set by
RHIDE only once. After the breakpoint is really hit, from now on the
breakpoint stops your program every time, the breakpoint is reached.

5.5.3 Problems with breakpoints
-------------------------------

Currently there is a big problem, when you have set a breakpoint at a line
(not at a function) of your program and you edit now the source code. If you
insert or delete some lines the breakpoints, which are set at lines after or
at the modified lines are NOT updated to the correct line number.

6 Debugging with RHGDB
**********************

In addition to RHIDE, which has an integrated debugger, there is also a
stand-alone debugger called RHGDB. (The name comes from my initials and GDB)

RHGDB has the same abilities as RHIDE for debugging your program. But it has
no editor. The source files are shown in read only windows where you can move
the cursor and other things (except editing) like in RHIDE.

The menu tree is analog of RHIDE's but (of course) it has not all the menu
entries of RHIDE, because RHGDB should be used only for debugging and nothing
else.

I have written it to debug DJGPP programs, for which there is no RHIDE
project file available but the program has debugging information and, if you
are short of memory, it is much smaller than RHIDE.

The syntax for using RHGDB is very simple. Run it with your program as the
first argument followed by any argument, which should be passed to your
program.

RHGDB saves and reads the options from files with the suffix `.rgd'.  This is
done automatically when you run RHGDB with your program as argument by
searching a file with the same basename of your program and the suffix `.rgd'
and in this file the options are also automatically stored, when you exit
RHGDB.

Alternatively you can also save/read the options from within RHIDE by
selecting the corresponding menu entries from the Options menu.

To use the the "Dual display debugging" feature of RHGDB you must give on
commandline the `-D' switch.

7 Some FAQs
***********

_*Question*: I have enabled the `Use tabs' option, but if I move the cursor
through that tab, it seems, that RHIDE uses spaces_ 

*Answer*:This behavior cannot (currently) be changed. Even when you have
enabled the use of real tabs (characters with the code 9), the cursor is
moved as if there are spaces.

_*Question*: Are there any sample project files, to show how RHIDE works?_ 

*Answer*:The sources of RHIDE include many project files to rebuild at least
RHIDE with itself and many others.

_*Question*: I have written some libraries. How can I use them in a project?_

_*Question*: How I can use a library, which I have?_

*Answer*: There are some different ways to do this. On the one side you can
include them directly in the project with the _Add to project item_ function
*note Add item::. But if they are not in the current directory, you must also
set the library search path to the directory, where they are *note Library
directories::. The other variant is to include them in the list of libraries
*note Libraries::.

If this library is created with RHIDE, that means you have a project file for
building this library you can also simply include that project file in your
project. For examples, look at the RHIDE sources in the project file for
RHIDE.

_*Question*: I have a directory, where all my include files are. Can I setup
RHIDE to have this directory every time in the include search path, when
creating a new project?_

_*Question*: I prefer the 80x28 video mode over the default 80x25 mode. How I
can turn this mode on by default for all newly created project files?_

*Answer*: You can create a default project file. From this file RHIDE reads
all the options, if it creates a new project. The default project must have
the same basename as the executable of RHIDE and must be located in the same
directory.

The creation of such a default project file is very simple. Change to the
directory, where `rhide.exe' is located and run there
     rhide rhide

Now make any changes in the options which you want to have as default for all
newly created projects. This includes also settings in the various search
paths. If you are ready, exit RHIDE and this project file will be your
default project file.

_*Question*: I know, that I can create a default project file. Can I create
and use more than one?_

*Answer*:Since DJGPP supports a quasi-Unix-like link for executables, you can
create such a link also for RHIDE. As an example I will create a link to
`rhide.exe' with the name `myrhide.exe'. At first I have to create the new
file.
     stubify -g myrhide.exe
Now I must tell `myrhide.exe' which program it really should run.
     stubedit myrhide.exe runfile=rhide
Thats all. Or, if you have installed the GNU fileutils, you can use also now
the `ln.exe' program to create the link:
     ln -s rhide.exe myrhide.exe

_*Question*: I don't want to type every time I start RHIDE the commandline -L
DE to use the German user interface. Is there any better way?_

*Answer*: Create an environment variable LANGUAGE with your preferred
language like
     set LANGUAGE=de
and your problem is solved.

_*Question*: I have 4 Mb RAM in my computer and every time, when I compile
large files with optimizations enabled, my hard disk is working very hard._

*Answer*:Buy more RAM!

_*Question*: I heard something about a newer version RHIDE. From where I can
get exact information about this?_

*Answer*: See
at the RHIDE home page (http://www.rhide.com).
This page contains the latest news and the latest version of RHIDE.

_*Question*: I have a lot of money and don't know what to do with it. Can you
help me?_

*Answer*: Send it to me, so I can spend more time for developing RHIDE. My
Address is:
     Robert Ho"hne
     Am Berg 3
     D-09573 Dittmannsdorf
     Germany

_*Question*: RHIDE does all sorts of unpredictable and silly things.  I.e.
does not remember the paths and other settings that I give it._

*Answer*: Did you start RHIDE with a project file i.e. invoke rhide with
     rhide projfile
RHIDE needs a place to keep this information.   Then go into projects tab and
select add then follow the dialog to add the  `.c' or `.cc'  file to the
project.

_*Question*: I do not generate an `.exe' file._

*Answer*: Enter RHIDE from the dos prompt by
     rhide projname
click project tab then add and select your `Hello.c' or `hello.cc' file.
Then compile and then link or else build all.  There should be a file
`projname.exe'.

_*Question*: The linker reports multiple `int main()' in my object file._

*Answer*: You have more than one `.c' or `.cc' file in your project with `int
main()' and the linker does not know where to start the `.exe' file.

_*Question*: It is not finding the include files `*.h'._

*Answer*: You are not referring to the djgpp distribution `*.h' files that
are part of the DJGPP standard distribution.  If so see DJGPP FAQ.  In RHIDE
click the Options tab on top of RHIDE window, then Directories, then Include,
then add the path to the `dot.h' files in the text box as follows:
     $(DJDIR)/contrib/grx/include $(DJDIR)/contrib/here/there etc
This path can also be set in the `djgpp.env' file (see the DJGPP information).

_*Question*: It's still not finding the `dot.h' files._

*Answer*: Invoke Win95 long file names at the command line via
     rhide -y projname

_*Question*: How do I set rhide to long file names without -y each time?_

*Answer*: Add the -Y to your RHIDEOPT environment variable.

_*Question*: The linker is not finding various library functions that are in
an extension to DJGPP.  For example functions that are part of SWORD Graphic
User Interface or GRX. Graphic Package._

*Answer*: Click the Options tab then Libraries then mark one of the boxes and
type in the Library name that you need i.e. GRX for `libgrx.a'.

_*Question*: It's still not finding the library functions._

*Answer*: Go into Options tab on top of the RHIDE window then Directories then
Libraries, then add the path to the `libdot.a' files in the text box as
follows:
     $(DJDIR)/contrib/lib/here/there $(DJDIR)/contrib/grx/lib
This can also be set in the `djgpp.env' file (see the DJGPP information).

_*Question*: Where is the rhide documentation and how do I read it?_

*Answer*:Get the file txixxxb.zip and unzip it.  Go into dir info and edit
the file DIR.  Add `rhide.inf' or any other `dot.inf' to DIR.  Use the same
format as the existing `dot.inf' files in DIR. It's obvious from the format
how to do this.  Save and exit from the edit session.  Type "info" take the
lesson on how to run info and you are fully equipped to run an old world non
gui browser and are ready to learn all about gnu.

If you are using RHIDE, simply hit <F1> and browse through the help, it IS
the RHIDE documentation!

_*Question*: The linker reports out of memory when linking many `*.o' files._

*Answer*: This should occour only on Windows 95 users (or W98).  Give dos
more memory. Quit rhide and dos.  Select the dos icon or its alias (it's in
`windows/start/programs') RIGHT click select properties then select memory
tab then set Protected mode DPMI to maximum 65535 and have another go.

_*Question*: I have a big svga monitor and rhide looks like cga screen.  What
can I do to take advantage of my monitor?_

*Answer*:Set the dos and rhide screens to suite your taste.  Quit rhide and
dos.  Select the dos icon or its alias (it's in `windows/start/programs')
RIGHT click select properties then select screen tab then set the type of
screen that you require in dos.  Then get into RHIDE and select options tab
on the top of the screen then Environment and then Preferences then set the
type of screen to your liking.

_*Question*: I`m running under W95/98 with long filenames and have some
source files ond/or directory names with spaces in it. I get many errors when
trying to compile or link. How can I solve this?_

*Answer*: This is a limitation of RHIDE. Theortically it could be fixed, but
this would need many changes in the RHIDE sources. I`m not willing to do. So,
simply do not not filenames with spaces.

_*Question*: How do I setup RHIDE to run under OS/2?_

*Answer*: OS/2 (WARP3 and above) Users have to pay attention to the following
DOS-Settings:
     - DPMI_DOS_API must be set to "Enabled"
     - DPMI_MEMORY_LIMIT should be set above 8MB (better >10)
     - DOS_HIGH must be set to OFF
     - DOS_UMB must be set to OFF
     - DOS_FILES should be set fairly higher than 20 (>60)
     - DOS_BREAK "ON" might be useful sometimes :-)
     - MOUSE_EXCLUSIVE_ACCESS should be set to off
     - You can use RHIDE with or without the "-M" option

_*Question*: I think, I found a bug in RHIDE. How can I report it?_

*Answer*:At first try for your own to solve the problem by checking the
documentation.

If the bug is releated to the editor (some keys do not work, autoindenting is
not like you expect, program crash after some special editing ...) please
send them to salvador@inti.gov.ar <Salvador Eduardo Tropea (SET)>, because he
is the author of the in RHIDE integrated editor.

See at the RHIDE home page (http://www.rhide.com), if this problem was
already reported by other users. As the next ask the problem in the news group
`news:comp.os.msdos.djgpp', because there may be some other people with the
same problem, and they can give you an answer or I, because I read this group
also.

GNU/Linux users should post the problems in the linux group. To make sure
that I will read it also, please send a CC to me because my time doesn`t
allow me to read that huge newsgroups.

If this don't help you, do the following:

     Try to reproduce the error with the smallest possible project or source
     file. Run RHIDE with all debugging options enabled and redirect the
     printed output to a file *note Debugging RHIDE::. Send me this file and
     a detailed as possible description of the problem and include in your
     report the exact version of RHIDE you are using.

     The exact version is shown in the About-Dialog and means the version
     number together with the build date.


And a last note. If I get bug reports or questions or problems with RHIDE
which I think that they are of common interest be warned that I bounce them
simply to the news groups because at this time it is impossible for me to
answer all the mails I get. So the best is to post the questions and/or
problems only in the news groups.

8 Index
*******

Adding a file to the project:                  See 3.8.3.          (line 1635)
Additional options for GCC:                    See 3.9.5.          (line 1905)
Arguments for your program:                    See 3.5.6.          (line 1479)
Assembler files, which must be preprocessed:   See 2.1.            (line  897)
Automatic dependencies:                        See 3.9.1.5.        (line 1780)
Automatic dependencies, problems with it:      See 4.3.1.          (line 2736)
Automatic indention:                           See 3.9.6.2.        (line 1924)
Automatic intention:                           See 3.9.6.2.        (line 1959)
Background colors, 16:                         See 3.9.6.3.        (line 2134)
Backup files:                                  See 3.9.6.3.        (line 2057)
Blinking colors:                               See 3.9.6.3.        (line 2134)
block commands:                                See 4.2.4.          (line 2669)
Bug report:                                    See 3.1.2.          (line 1096)
Bug, reporting it:                             See 7.              (line 3950)
Build:                                         See 3.6.4.          (line 1516)
Build the library:                             See 3.6.3.          (line 1508)
Building a library:                            See 3.8.7.          (line 1669)
Building an executable:                        See 3.8.7.          (line 1669)
Builtin calculator:                            See 5.3.2.          (line 3598)
Button:                                        See 4.12.           (line 3355)
C Flags, edit them:                            See 3.9.6.7.        (line 2267)
C language specific flags:                     See 3.9.2.4.        (line 1824)
C++ flags, edit them:                          See 3.9.6.8.        (line 2275)
Caching of files:                              See 3.9.6.3.        (line 2124)
Calculator:                                    See 3.1.7.          (line 1129)
Call stack:                                    See 3.7.6.          (line 1571)
Cascade the windows:                           See 3.10.4.         (line 2414)
Changing the name of the library:              See 3.8.7.          (line 1669)
Changing the name of the program:              See 3.8.7.          (line 1669)
Changing the search paths for files:           See 3.9.1.          (line 1729)
Checkbox:                                      See 4.12.           (line 3373)
Checking dependencies:                         See 4.10.           (line 3291)
Clear:                                         See 3.3.7.          (line 1283)
Clearing the dependencies:                     See 3.8.9.          (line 1693)
Clearing the project:                          See 3.8.10.         (line 1704)
Clipboard:                                     See 3.3.6.          (line 1277)
Close a project:                               See 3.8.2.          (line 1629)
Close a window:                                See 3.10.7.         (line 2430)
COFF file, Creating:                           See 3.8.7.          (line 1675)
Colors:                                        See 3.9.6.1.        (line 1916)
Column cursor:                                 See 3.9.6.2.        (line 1971)
Commandline arguments for your program:        See 3.5.6.          (line 1479)
Commandline options:                           See 1.5.            (line  379)
Compile:                                       See 3.6.1.          (line 1491)
Compile without a project:                     See 4.3.            (line 2723)
Compiler options:                              See 3.9.5.          (line 1905)
COMSPEC:                                       See 3.2.6.          (line 1226)
Configuring RHIDE:                             See 4.7.            (line 3244)
Context help:                                  See 4.14.           (line 3407)
Controlling the optimization of the code:      See 3.9.2.2.        (line 1805)
Controlling the warnings:                      See 3.9.2.1.        (line 1795)
Copy:                                          See 3.3.4.          (line 1265)
Copy to Windows clipboard:                     See 3.3.8.          (line 1288)
Cplusplus options:                             See 3.9.2.5.        (line 1833)
Creating a COFF file:                          See 3.8.7.          (line 1675)
Creating a makefile <1>:                       See 1.6.            (line  543)
Creating a makefile <2>:                       See 3.9.6.3.        (line 2047)
Creating a makefile:                           See 3.8.11.         (line 1711)
Creating a new file:                           See 3.2.2.          (line 1195)
Creating a new project:                        See 3.8.1.          (line 1611)
Creating a project:                            See 7.              (line 3843)
Creating an exe-file:                          See 7.              (line 3852)
Creating backup files:                         See 3.9.6.3.        (line 2057)
Cross cursor <1>:                              See 3.9.6.2.        (line 1983)
Cross cursor:                                  See 3.9.6.2.        (line 1971)
Cursor moving:                                 See 4.2.2.          (line 2618)
Cursor through tabs:                           See 7.              (line 3751)
Cut:                                           See 3.3.3.          (line 1259)
CXX options:                                   See 3.9.2.5.        (line 1833)
Debugging:                                     See 1.5.2.          (line  497)
Debugging info:                                See 3.9.2.3.        (line 1814)
Debugging RHIDE <1>:                           See 3.9.6.3.        (line 2148)
Debugging RHIDE:                               See 3.9.6.3.        (line 2106)
Debugging with RHIDE:                          See 3.7.            (line 1522)
Debugging, dual display:                       See 3.9.6.3.        (line 2076)
Debugging, edit the flags:                     See 3.9.6.12.       (line 2307)
Default commandline:                           See 7.              (line 3879)
Default file mask:                             See 3.2.1.          (line 1174)
Default language:                              See 7.              (line 3816)
Default project file:                          See 7.              (line 3785)
Default project file, more than one:           See 7.              (line 3802)
Define your own reserved words:                See 3.9.6.14.       (line 2323)
Defines:                                       See 3.9.5.          (line 1905)
Delete a file from the project:                See 3.8.4.          (line 1647)
Delete the selected text:                      See 3.3.7.          (line 1283)
Deleting commands:                             See 4.2.1.          (line 2597)
Dependencies for a file:                       See 3.8.6.          (line 1663)
Dependencies in makefile:                      See 3.9.6.3.        (line 2047)
Dependencies, checking:                        See 4.10.           (line 3291)
Dependencies, problems with it:                See 4.3.1.          (line 2736)
Dialog function keys:                          See 4.12.           (line 3344)
Different name for RHIDE:                      See 7.              (line 3802)
Directory for temp files:                      See 2.3.            (line  955)
Disable shadows:                               See 3.9.6.3.        (line 2156)
Disassembler:                                  See 3.7.5.          (line 1555)
Documentation for RHIDE:                       See 7.              (line 3898)
Donations to the author:                       See 7.              (line 3836)
DOS:                                           See 3.2.6.          (line 1226)
Dual display:                                  See 5.2.            (line 3522)
Dual display when debugging:                   See 3.9.6.3.        (line 2076)
Dual display with RHGDB:                       See 6.              (line 3744)
Edit a file:                                   See 3.2.1.          (line 1170)
Edit the list of C flags:                      See 3.9.6.7.        (line 2267)
Edit the list of C++ flags:                    See 3.9.6.8.        (line 2275)
Edit the list of debugging flags:              See 3.9.6.12.       (line 2307)
Edit the list of Fortran flags:                See 3.9.6.10.       (line 2291)
Edit the list of optimization flags:           See 3.9.6.13.       (line 2315)
Edit the list of Pascal flags:                 See 3.9.6.9.        (line 2283)
Edit the list of reserved words:               See 3.9.6.5.        (line 2253)
Edit the list of reserved words for Pascal:    See 3.9.6.6.        (line 2260)
Edit the list of user defined words:           See 3.9.6.14.       (line 2323)
Edit the list of warning flags:                See 3.9.6.11.       (line 2299)
Editor:                                        See 4.2.            (line 2578)
Editor options:                                See 3.9.6.2.        (line 1921)
Editor, block commands:                        See 4.2.4.          (line 2669)
Editor, cursor moving:                         See 4.2.2.          (line 2618)
Editor, erasing commands:                      See 4.2.1.          (line 2597)
Editor, other useful commands:                 See 4.2.5.          (line 2701)
Editor, select some text:                      See 4.2.3.          (line 2647)
Environment variables <1>:                     See 1.9.            (line  661)
Environment variables <2>:                     See 3.9.1.          (line 1732)
Environment variables:                         See 1.9.1.          (line  700)
Erasing commands:                              See 4.2.1.          (line 2597)
Executing your program:                        See 3.5.1.          (line 1416)
Exit:                                          See 3.2.7.          (line 1235)
Expanding tabs:                                See 3.3.10.         (line 1300)
Exporting the RHIDE project files:             See 1.7.            (line  583)
File caching:                                  See 3.9.6.3.        (line 2124)
File open dialog:                              See 3.2.1.          (line 1174)
Files for syntax help:                         See 3.11.3.2.       (line 2503)
Finding text:                                  See 3.4.1.          (line 1350)
Flags for C files:                             See 3.9.2.4.        (line 1824)
Flags for C++ files:                           See 3.9.2.5.        (line 1833)
Flags for Fortran files:                       See 3.9.2.7.        (line 1851)
Flags for Pascal files:                        See 3.9.2.6.        (line 1842)
Fortran flags, edit them:                      See 3.9.6.10.       (line 2291)
Fortran options:                               See 3.9.2.7.        (line 1851)
Free memory:                                   See 3.9.6.3.        (line 2115)
Function call stack:                           See 3.7.6.          (line 1571)
Generating of warnings:                        See 3.9.2.1.        (line 1795)
Global editor options:                         See 3.9.6.2.        (line 1921)
GNU/Linux:                                     See 2.6.            (line  980)
Goto a line number:                            See 3.4.4.          (line 1375)
GPC, -automake:                                See 3.8.8.          (line 1681)
Header files:                                  See 3.9.1.1.        (line 1742)
Help:                                          See 3.11.1.         (line 2462)
Help about a function:                         See 3.11.3.1.       (line 2494)
Help about help:                               See 3.11.6.         (line 2561)
Help about the Info-viewer:                    See 3.11.6.         (line 2561)
Help system:                                   See 4.14.           (line 3392)
Highlight the syntax:                          See 4.9.            (line 3279)
Highlighting the matching parenthesis:         See 3.9.6.2.        (line 1995)
Highlighting the syntax:                       See 3.9.6.3.        (line 2066)
Hints:                                         See 4.3.            (line 2723)
How the editor works:                          See 4.2.            (line 2578)
Include directories:                           See 3.9.1.1.        (line 1742)
Include files:                                 See 3.9.1.1.        (line 1742)
Include files, not finding:                    See 7.              (line 3865)
Include paths:                                 See 7.              (line 3865)
Info Viewer:                                   See 4.14.           (line 3392)
Input line:                                    See 4.12.           (line 3370)
Intelligent C indenting:                       See 3.9.6.2.        (line 1959)
Language, setting the default:                 See 7.              (line 3816)
Languages:                                     See 1.5.1.          (line  470)
Latest version of RHIDE:                       See 7.              (line 3829)
Leaving RHIDE:                                 See 3.2.7.          (line 1235)
LFN:                                           See 2.3.            (line  945)
Libc reference:                                See 3.11.5.         (line 2555)
Libraries:                                     See 3.9.3.          (line 1872)
Libraries in a project:                        See 7.              (line 3766)
Library paths:                                 See 7.              (line 3883)
Library search path:                           See 3.9.1.2.        (line 1754)
Link the program:                              See 3.6.3.          (line 1508)
Linker options:                                See 3.9.4.          (line 1897)
Linker problems:                               See 7.              (line 3910)
List of all windows:                           See 3.10.8.         (line 2437)
Listbox:                                       See 4.12.           (line 3362)
Lists:                                         See 4.12.           (line 3362)
Load options <1>:                              See 3.9.8.          (line 2378)
Load options:                                  See 2.7.3.          (line 1056)
Loading a file:                                See 3.2.1.          (line 1170)
Local options:                                 See 4.4.4.          (line 2808)
Local options for a project item:              See 3.8.5.          (line 1654)
Long filenames <1>:                            See 7.              (line 3927)
Long filenames:                                See 2.3.            (line  945)
Macro executing:                               See 3.3.12.3.       (line 1337)
Macro recording:                               See 3.3.12.1.       (line 1322)
Macro stop recording:                          See 3.3.12.2.       (line 1330)
Macros <1>:                                    See 3.3.12.         (line 1314)
Macros:                                        See 4.13.           (line 3386)
Main targetname:                               See 3.8.7.          (line 1669)
Make:                                          See 3.6.2.          (line 1500)
Make clear:                                    See 3.8.10.         (line 1704)
Makefile:                                      See 3.8.11.         (line 1711)
Mark some text:                                See 4.2.3.          (line 2647)
Memory exhausted:                              See 7.              (line 3910)
Message window:                                See 4.8.            (line 3266)
Miscellaneous commands:                        See 4.2.5.          (line 2701)
Mouse options:                                 See 3.9.6.4.        (line 2247)
Moving a window:                               See 3.10.1.         (line 2389)
MS-DOS:                                        See 3.2.6.          (line 1226)
Name of the main target:                       See 3.8.7.          (line 1669)
Next message:                                  See 3.4.6.          (line 1395)
Next window:                                   See 3.10.5.         (line 2420)
No shadows:                                    See 3.9.6.3.        (line 2156)
Object file search path:                       See 3.9.1.3.        (line 1761)
Object files in a different directory:         See 3.9.1.3.        (line 1761)
Open a file:                                   See 3.2.1.          (line 1170)
Open a project:                                See 3.8.1.          (line 1611)
Optimal filling:                               See 3.9.6.2.        (line 2023)
Optimizations, edit the flags:                 See 3.9.6.13.       (line 2315)
Optimizing the code:                           See 3.9.2.2.        (line 1805)
Options for a single file:                     See 3.8.5.          (line 1654)
Options for the linker:                        See 3.9.4.          (line 1897)
Options, RHIDE forgot them:                    See 7.              (line 3843)
Order of the project items:                    See 4.4.1.          (line 2774)
OS/2 <1>:                                      See 2.4.            (line  967)
OS/2:                                          See 7.              (line 3935)
Other compilers:                               See 4.7.            (line 3244)
Pascal flags, edit them:                       See 3.9.6.9.        (line 2283)
Pascal options:                                See 3.9.2.6.        (line 1842)
Pascal reserved words:                         See 3.9.6.6.        (line 2260)
Paste:                                         See 3.3.5.          (line 1271)
Paste from Windows clipboard:                  See 3.3.9.          (line 1294)
Persistent blocks:                             See 3.9.6.2.        (line 1947)
Playing the macro:                             See 3.3.12.3.       (line 1337)
Preprocessing Assembler files:                 See 2.1.            (line  897)
Previous message:                              See 3.4.7.          (line 1403)
Previous window:                               See 3.10.6.         (line 2425)
Problems:                                      See 4.3.            (line 2723)
Project window:                                See 4.4.            (line 2762)
Pseudo Macros:                                 See 4.13.           (line 3386)
Quit:                                          See 3.2.7.          (line 1235)
Radiobuttons:                                  See 4.12.           (line 3380)
RCS:                                           See 4.15.           (line 3415)
Rebuilding RHIDE:                              See 7.              (line 3757)
Redirecting stderr:                            See 3.9.6.3.        (line 2089)
Redirecting stdout:                            See 3.9.6.3.        (line 2098)
Redo:                                          See 3.3.2.          (line 1253)
Remove a file from the project:                See 3.8.4.          (line 1647)
Removing all targets:                          See 3.8.10.         (line 1704)
Removing the internal dependencies:            See 3.8.9.          (line 1693)
Repeat of replacing:                           See 3.4.3.          (line 1368)
Repeat of searching:                           See 3.4.3.          (line 1368)
Replacing text:                                See 3.4.2.          (line 1359)
Reporting bugs <1>:                            See 3.1.2.          (line 1096)
Reporting bugs:                                See 7.              (line 3950)
Reserved words:                                See 3.9.6.5.        (line 2253)
Resizing a window:                             See 3.10.1.         (line 2389)
Reverse mouse buttons:                         See 3.9.6.4.        (line 2247)
RHIDE project files:                           See 7.              (line 3757)
RHIDE, latest version:                         See 7.              (line 3829)
rhide.env:                                     See 1.9.1.          (line  710)
rhide.env, Samples:                            See 1.9.1.          (line  749)
RHIDEOPT:                                      See 7.              (line 3879)
Row cursor:                                    See 3.9.6.2.        (line 1983)
Running your program:                          See 3.5.1.          (line 1416)
Sample projects:                               See 7.              (line 3757)
Save all files to disk:                        See 3.2.5.          (line 1220)
Save options <1>:                              See 2.7.3.          (line 1056)
Save options:                                  See 3.9.7.          (line 2371)
Save the file to disk:                         See 3.2.3.          (line 1202)
Save the file under a different name:          See 3.2.4.          (line 1213)
Screen size:                                   See 7.              (line 3917)
Search a function:                             See 3.4.5.          (line 1383)
Search path for include files:                 See 3.9.1.1.        (line 1742)
Search path for libraries:                     See 3.9.1.2.        (line 1754)
Search path for object files:                  See 3.9.1.3.        (line 1761)
Search path for source files:                  See 3.9.1.4.        (line 1768)
Searching text:                                See 3.4.1.          (line 1350)
Searchmethod for syntax help:                  See 3.11.3.3.       (line 2510)
Select a window:                               See 4.1.            (line 2570)
Select the project window:                     See 3.10.9.         (line 2444)
Selecting some text:                           See 4.2.3.          (line 2647)
Show free memory:                              See 3.9.6.3.        (line 2115)
Show the includes for a file:                  See 3.8.6.          (line 1663)
Show the project window:                       See 3.10.9.         (line 2444)
Show the user screen:                          See 3.10.10.        (line 2450)
Show what RHIDE does:                          See 3.9.6.3.        (line 2106)
Single file compiling:                         See 4.3.            (line 2723)
Size for the tabs:                             See 3.9.6.2.        (line 2031)
Source file search path:                       See 3.9.1.4.        (line 1768)
Source files in a different directory:         See 3.9.1.4.        (line 1768)
Space as part of an argument:                  See 2.2.            (line  937)
Spaces in filenames:                           See 7.              (line 3927)
Specs:                                         See 1.9.1.          (line  700)
Standard headers:                              See 3.9.1.5.        (line 1780)
Start:                                         See 1.5.            (line  379)
Starting a macro:                              See 3.3.12.1.       (line 1322)
Starting your program:                         See 3.5.1.          (line 1416)
stderr redirecting:                            See 3.9.6.3.        (line 2089)
stdout redirecting:                            See 3.9.6.3.        (line 2098)
Stopping a macro:                              See 3.3.12.2.       (line 1330)
Store a file:                                  See 3.2.3.          (line 1202)
Suppressing of warnings:                       See 3.9.2.1.        (line 1795)
Syntax help:                                   See 3.11.3.1.       (line 2494)
Syntax help, Index:                            See 3.11.4.         (line 2549)
Syntax help, Options:                          See 3.11.3.3.       (line 2510)
Syntax highlighting <1>:                       See 3.9.6.3.        (line 2066)
Syntax highlighting:                           See 4.9.            (line 3279)
Tab size:                                      See 3.9.6.2.        (line 2031)
Tabs:                                          See 3.9.6.2.        (line 1935)
Tabs to spaces:                                See 3.3.10.         (line 1300)
Temp directory:                                See 2.3.            (line  955)
temporary do to DOS:                           See 3.2.6.          (line 1226)
Text mode:                                     See 3.9.6.3.        (line 2221)
Tile the windows:                              See 3.10.3.         (line 2408)
Transparent blocks:                            See 3.9.6.2.        (line 2015)
Turbo Vision:                                  See 4.11.           (line 3304)
Type of the main target:                       See 3.8.7.          (line 1669)
Undo:                                          See 3.3.1.          (line 1247)
Use of libraries:                              See 7.              (line 3766)
User defined compiler:                         See 4.4.4.          (line 2877)
User defined reserved words:                   See 3.9.6.14.       (line 2323)
User screen:                                   See 3.10.10.        (line 2450)
Using the dialog:                              See 4.12.           (line 3344)
Using the macro:                               See 3.3.12.3.       (line 1337)
Using true tabs:                               See 3.9.6.2.        (line 1935)
Version of RHIDE:                              See 3.1.1.          (line 1090)
Video mode:                                    See 3.9.6.3.        (line 2221)
Warnings:                                      See 3.9.2.1.        (line 1795)
Warnings, edit the flags:                      See 3.9.6.11.       (line 2299)
Window, close it:                              See 3.10.7.         (line 2430)
Window, moving:                                See 3.10.1.         (line 2389)
Window, resizing:                              See 3.10.1.         (line 2389)
Window, select it:                             See 4.1.            (line 2570)
Window, select the next:                       See 3.10.5.         (line 2420)
Window, select the previous:                   See 3.10.6.         (line 2425)
Window, zoom it:                               See 3.10.2.         (line 2402)
Windows:                                       See 3.10.           (line 2383)
Windows 95 <1>:                                See 2.3.            (line  945)
Windows 95:                                    See 7.              (line 3927)
Windows, cascade them:                         See 3.10.4.         (line 2414)
Windows, show a list of all:                   See 3.10.8.         (line 2437)
Windows, tile all:                             See 3.10.3.         (line 2408)
Write a makefile:                              See 3.8.11.         (line 1711)
xterm, running RHIDE in it:                    See 2.6.            (line  994)
Zoom a window:                                 See 3.10.2.         (line 2402)
9 Index of key commands
***********************

Activate a button | <ENTER>:                   See 4.12.           (line 3357)
Activate a flag | <SPACE>:                     See 3.9.2.8.        (line 1862)
Activate menu bar | <F10>:                     See 4.11.           (line 3330)
Add a project item | <Ins>:                    See 3.8.3.          (line 1637)
Again find/replace | <Ctrl+L>:                 See 4.2.3.          (line 2662)
Auto indent | <Ctrl+O>:                        See 4.2.5.          (line 2703)
Begin of file | <Ctrl+PgUp>:                   See 4.2.2.          (line 2638)
Block indenting | <Ctrl+K+Tab>:                See 4.2.4.          (line 2688)
Block unindenting | <Ctrl+K+Shift+Tab>:        See 4.2.4.          (line 2691)
Bottom of file | <Ctrl+PgDown>:                See 4.2.2.          (line 2641)
Call stack | <Ctrl+F3>:                        See 3.7.6.          (line 1576)
Close a window | <Alt+F3>:                     See 3.10.7.         (line 2431)
Close a window | <Del>:                        See 3.10.8.         (line 2439)
Compile | <Alt+F9>:                            See 3.6.1.          (line 1495)
Context help | <Ctrl+F1>:                      See 4.14.           (line 3409)
Copy | <Ctrl+Ins> <1>:                         See 4.2.3.          (line 2649)
Copy | <Ctrl+Ins>:                             See 3.3.4.          (line 1266)
Copy | <Ctrl+K+K>:                             See 4.2.3.          (line 2649)
Cursor down | <Ctrl+X>:                        See 4.2.2.          (line 2624)
Cursor left | <Ctrl+S>:                        See 4.2.2.          (line 2618)
Cursor right | <Ctrl+D>:                       See 4.2.2.          (line 2620)
Cursor up | <Ctrl+E>:                          See 4.2.2.          (line 2622)
Cut | <Ctrl+K+Y>:                              See 4.2.3.          (line 2651)
Cut | <Shift+Del> <1>:                         See 4.2.3.          (line 2651)
Cut | <Shift+Del>:                             See 3.3.3.          (line 1260)
Delete a character | <Ctrl+G>:                 See 4.2.1.          (line 2597)
Delete a character | <Ctrl+H>:                 See 4.2.1.          (line 2600)
Delete selected text | <Ctrl+Del>:             See 4.2.3.          (line 2656)
Delete to the beginning of line | <Ctrl+Q+H>:  See 4.2.1.          (line 2607)
Delete to the end of line | <Ctrl+Q+Y>:        See 4.2.1.          (line 2605)
Delete to the next word | <Ctrl+T>:            See 4.2.1.          (line 2609)
Delete to the previous word | <Ctrl+Backspace>:See 4.2.1.          (line 2612)
End of block | <Ctrl+K+K>:                     See 4.2.4.          (line 2671)
End of file | <Ctrl+Q+C>:                      See 4.2.2.          (line 2641)
End of line | <Ctrl+Q+D>:                      See 4.2.2.          (line 2634)
Erase a character | <Backspace>:               See 4.2.1.          (line 2600)
Erase a character | <Del>:                     See 4.2.1.          (line 2597)
Erase a line | <Ctrl+Y>:                       See 4.2.1.          (line 2603)
Evaluate/Modify | <Ctrl+F4>:                   See 3.7.2.          (line 1538)
Execute a macro | <Shift+Space>:               See 4.2.5.          (line 2713)
Find | <Ctrl+Q+F> <1>:                         See 4.2.3.          (line 2660)
Find | <Ctrl+Q+F>:                             See 3.4.1.          (line 1354)
Go to cursor (No display swap) | <Shift+F4>:   See 3.5.4.          (line 1455)
Go to cursor | <F4>:                           See 3.5.4.          (line 1455)
Goto line | <Ctrl+J>:                          See 3.4.4.          (line 1378)
Help about the INFO Viewer | <F1>:             See 4.14.           (line 3397)
Help about the INFO viewer | <F1>:             See 3.11.1.         (line 2469)
Help | <F1>:                                   See 3.11.1.         (line 2468)
Ignoring | <Ctrl+C>:                           See 1.3.            (line  337)
Indent block | <Ctrl+K+I>:                     See 4.2.4.          (line 2673)
Interrupting the compilers | <Ctrl+Break>:     See 1.3.            (line  337)
Jump to a line | <Ctrl+J>:                     See 4.2.5.          (line 2705)
Jump to a marker | <Ctrl+Q+?>:                 See 4.2.5.          (line 2710)
Jump to function | <Alt+F2>:                   See 3.4.5.          (line 1390)
Jump to the source line | <ENTER>:             See 4.8.            (line 3269)
Leaving a dialog | <ESC> <1>:                  See 3.9.2.8.        (line 1865)
Leaving a dialog | <ESC> <2>:                  See 3.2.1.          (line 1190)
Leaving a dialog | <ESC>:                      See 4.12.           (line 3346)
Leaving RHIDE | <Alt+X>:                       See 3.2.7.          (line 1236)
List of all windows | <Alt+0>:                 See 3.10.8.         (line 2437)
List of functions | <Ctrl+F1>:                 See 5.5.2.          (line 3685)
Local options | <Ctrl+O> <1>:                  See 4.4.4.          (line 2809)
Local options | <Ctrl+O>:                      See 3.8.5.          (line 1656)
Macro play | <Ctrl+F10>:                       See 3.3.12.3.       (line 1339)
Macro start | <Shift+F10>:                     See 3.3.12.1.       (line 1325)
Macro stop | <Alt+F10>:                        See 3.3.12.2.       (line 1332)
Make | <F9>:                                   See 3.6.2.          (line 1501)
Menu | <F10> <1>:                              See 1.5.            (line  393)
Menu | <F10>:                                  See 3.              (line 1076)
Move block | <Ctrl+K+V>:                       See 4.2.4.          (line 2686)
Next input line | <Tab>:                       See 3.9.3.          (line 1879)
Next message | <Alt+F8>:                       See 3.4.6.          (line 1398)
Next window | <F6>:                            See 3.10.5.         (line 2420)
open a file | <F3>:                            See 3.2.1.          (line 1171)
Open a project item | <ENTER>:                 See 4.4.2.          (line 2789)
Open an include file | <ENTER>:                See 4.4.3.          (line 2803)
Overwrite mode | <Ctrl+V>:                     See 4.2.5.          (line 2701)
Page down | <Ctrl+C>:                          See 4.2.2.          (line 2630)
Page up | <Ctrl+R>:                            See 4.2.2.          (line 2632)
Paste | <Ctrl+K+C>:                            See 4.2.3.          (line 2653)
Paste | <Shift+Ins> <1>:                       See 4.2.3.          (line 2653)
Paste | <Shift+Ins>:                           See 3.3.5.          (line 1272)
Previous input line | <Shift+Tab>:             See 3.9.3.          (line 1879)
Previous message | <Alt+F7>:                   See 3.4.7.          (line 1406)
Previous window | <Shift+F6>:                  See 3.10.6.         (line 2425)
Program reset | <Ctrl+F2>:                     See 3.5.5.          (line 1463)
Read block from file | <Ctrl+K+R>:             See 4.2.4.          (line 2694)
Remove a project item | <Del>:                 See 3.8.4.          (line 1648)
Remove from the watches | <Del>:               See 5.3.3.          (line 3610)
Replace | <Ctrl+Q+A> <1>:                      See 3.4.2.          (line 1363)
Replace | <Ctrl+Q+A>:                          See 4.2.3.          (line 2658)
Resize/move a window | <Ctrl+F5>:              See 3.10.1.         (line 2397)
Resizing a window | <Shift+>:                  See 3.10.1.         (line 2391)
Run | <Ctrl+F9>:                               See 3.5.1.          (line 1417)
saving a file | <F2>:                          See 3.2.3.          (line 1203)
Search again | <Ctrl+L>:                       See 3.4.3.          (line 1370)
Select a item in a Listbox | <ENTER>:          See 4.12.           (line 3367)
Select a menu entry | <ENTER>:                 See 4.11.           (line 3333)
Select a message | <ENTER>:                    See 4.3.            (line 2730)
Select a window | <ENTER>:                     See 3.10.8.         (line 2438)
Select menu item | <ENTER>:                    See 3.              (line 1078)
Select text | <Shift>:                         See 4.2.3.          (line 2647)
Selecting a window | <Alt>:                    See 4.1.            (line 2571)
Set a marker | <Ctrl+K+?>:                     See 4.2.5.          (line 2707)
Show includes | <Ctrl+I>:                      See 3.8.6.          (line 1664)
Start of block | <Ctrl+K+B>:                   See 4.2.4.          (line 2669)
Start of file | <Ctrl+Q+R>:                    See 4.2.2.          (line 2638)
Start of line | <Ctrl+Q+S>:                    See 4.2.2.          (line 2636)
Step over (No display swap) | <Shift+F8>:      See 3.5.2.          (line 1431)
Step over | <F8>:                              See 3.5.2.          (line 1431)
Syntax help | <Ctrl+F1>:                       See 3.11.3.1.       (line 2494)
System Menu | <Alt+SPACE>:                     See 3.1.            (line 1085)
To lower | <Ctrl+K+O>:                         See 4.2.4.          (line 2683)
To upper | <Ctrl+K+M>:                         See 4.2.4.          (line 2680)
Toggle a breakpoint | <Ctrl+F8>:               See 3.7.1.          (line 1531)
Toggle an option | <SPACE>:                    See 4.12.           (line 3376)
Trace into (No display swap) | <Shift+F7>:     See 3.5.3.          (line 1443)
Trace into | <F7>:                             See 3.5.3.          (line 1443)
Undo | <Alt+Backspace>:                        See 3.3.1.          (line 1247)
Unindent block | <Ctrl+K+U>:                   See 4.2.4.          (line 2676)
Unselect | <Ctrl+K+H>:                         See 4.2.3.          (line 2664)
User screen | <Alt+F5>:                        See 3.10.10.        (line 2450)
Watch an expression | <Ctrl+F7>:               See 3.7.3.          (line 1545)
Word left | <Ctrl+A>:                          See 4.2.2.          (line 2626)
Word right | <Ctrl+F>:                         See 4.2.2.          (line 2628)
Write block to file | <Ctrl+K+W>:              See 4.2.4.          (line 2696)
Zoom a window | <F5>:                          See 3.10.2.         (line 2402)

