


pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


NNAAMMEE
       pptthhrreeaadd - POSIX.1c Threading API of GNU Pth

VVEERRSSIIOONN
       GNU Pth 2.0.7 (08-Jun-2006)

SSYYNNOOPPSSIISS
       AApppplliiccaattiioonn MMaakkeeffiilleess::

        #   manually
        CFLAGS=-I/path/to/pth/include
        LDFLAGS=-L/path/to/pth/lib
        LIBS=-lpthread

        #   automatically
        CFLAGS=`pthread-config --cflags`
        LDFLAGS=`pthread-config --ldflags`
        LIBS=`pthread-config --libs`

       AApppplliiccaattiioonn ssoouurrccee ffiilleess::

        #include <pthread.h>

DDEESSCCRRIIPPTTIIOONN
       OOvveerrvviieeww

       This is the IEEE Std. 1003.1c ("POSIX.1c") conforming
       threading API of GNU Portable Threads (PPtthh). This API is
       commonly known as ``_P_O_S_I_X _t_h_r_e_a_d_s'' or in short
       ``_P_t_h_r_e_a_d_s''. It is provided by PPtthh with the intention of
       backward compatibility to existing multithreaded
       applications. It is implemented by mapping the various
       Pthread API functions to the corresponding native PPtthh API
       functions.

       SSuuppppoorrtteedd FFeeaattuurreess

       The following defined feature macros in "pthread.h"
       indicate supported features:

        #define _POSIX_THREADS
        #define _POSIX_THREAD_ATTR_STACKADDR
        #define _POSIX_THREAD_ATTR_STACKSIZE

       The following undefined feature macros in "pthread.h"
       indicate (still) unsupported features:

        #undef  _POSIX_THREAD_PRIORITY_SCHEDULING
        #undef  _POSIX_THREAD_PRIO_INHERIT
        #undef  _POSIX_THREAD_PRIO_PROTECT
        #undef  _POSIX_THREAD_PROCESS_SHARED
        #undef  _POSIX_THREAD_SAFE_FUNCTIONS





08-Jun-2006               GNU Pth 2.0.7                         1





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       NNootteess

       A few notes which you should keep in mind when working
       with the PPtthh Pthread API.

       NNoonn--PPrreeeemmppttiivvee SScchheedduulliinngg
           First you have to always remember when working with
           this Pthread library that it uses non-preemptive
           scheduling, because it is directly based on PPtthh (PPtthh
           for portability reasons is a pure non-preemptive
           thread scheduling system). So there is no implicit
           yielding of execution control unless you can
           "pthread_*" functions which could block and you cannot
           expect granular concurrency in your application, of
           course.  Nevertheless the responsiveness and
           concurrency of an event driven application is
           increased greatly because of overlapping I/O.

       CCoonnfflliiccttss wwiitthh VVeennddoorr IImmpplleemmeennttaattiioonn
           There can be a conflict between the PPtthh "pthread.h"
           header and a possibly existing vendor
           "/usr/include/pthread.h" header which was implicitly
           included by some standard vendor headers (like
           "/usr/include/unistd.h"). When this occurs try to
           ``"#define"'' header-dependent values which prevent
           the inclusion of the vendor header.

       FFuurrtthheerr RReeaaddiinngg

       There is ``_T_h_e _S_i_n_g_l_e _U_N_I_X _S_p_e_c_i_f_i_c_a_t_i_o_n_, _V_e_r_s_i_o_n _2 _-
       _T_h_r_e_a_d_s'', from _T_h_e _O_p_e_n _G_r_o_u_p of 1997 under
       http://www.opengroup.org/onlinepubs/007908799/xsh/threads.html.
       This is a very complete publically available description
       of the Pthread API. For convinience reasons, a translated
       copy of these freely available HTML pages are appended to
       this manpage below. These are _C_o_p_y_r_i_g_h_t _(_C_) _1_9_9_7 _T_h_e _O_p_e_n
       _G_r_o_u_p.

       Second, you can also buy the official standard from IEEE.
       It is the IEEE POSIX 1003.1c-1995 standard (also known as
       ISO/IEC 9945-1:1996), which is available as part of the
       ANSI/IEEE 1003.1, 1996 edition, standard.

       Finally you can look at the files "pthread.c" and
       "pthread.h" in the PPtthh source tree for details of the
       implementation, of course.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d_-_c_o_n_f_i_g(1), _p_t_h(3).

AAUUTTHHOORR
        Ralf S. Engelschall
        rse@engelschall.com
        www.engelschall.com



08-Jun-2006               GNU Pth 2.0.7                         2





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd..hh - threads

SSYYNNOOPPSSIISS
       #include <pthread.h>

DDEESSCCRRIIPPTTIIOONN
       The _<_p_t_h_r_e_a_d_._h> header defines the following symbols:

        PTHREAD_CANCEL_ASYNCHRONOUS
        PTHREAD_CANCEL_ENABLE
        PTHREAD_CANCEL_DEFERRED
        PTHREAD_CANCEL_DISABLE
        PTHREAD_CANCELED
        PTHREAD_COND_INITIALIZER
        PTHREAD_CREATE_DETACHED
        PTHREAD_CREATE_JOINABLE
        PTHREAD_EXPLICIT_SCHED
        PTHREAD_INHERIT_SCHED
        PTHREAD_MUTEX_DEFAULT
        PTHREAD_MUTEX_ERRORCHECK
        PTHREAD_MUTEX_NORMAL
        PTHREAD_MUTEX_INITIALIZER
        PTHREAD_MUTEX_RECURSIVE
        PTHREAD_ONCE_INIT
        PTHREAD_PRIO_INHERIT
        PTHREAD_PRIO_NONE
        PTHREAD_PRIO_PROTECT
        PTHREAD_PROCESS_SHARED
        PTHREAD_PROCESS_PRIVATE
        PTHREAD_RWLOCK_INITIALIZER
        PTHREAD_SCOPE_PROCESS
        PTHREAD_SCOPE_SYSTEM

       The pptthhrreeaadd__aattttrr__tt, pptthhrreeaadd__ccoonndd__tt, pptthhrreeaadd__ccoonnddaattttrr__tt,
       pptthhrreeaadd__kkeeyy__tt, pptthhrreeaadd__mmuutteexx__tt, pptthhrreeaadd__mmuutteexxaattttrr__tt,
       pptthhrreeaadd__oonnccee__tt, pptthhrreeaadd__rrwwlloocckk__tt, pptthhrreeaadd__rrwwlloocckkaattttrr__tt and
       pptthhrreeaadd__tt types are defined as described in _<_s_y_s_/_t_y_p_e_s_._h>.

       The following are declared as functions and may also be
       declared as macros. Function prototypes must be provided
       for use with an ISO C compiler.














08-Jun-2006               GNU Pth 2.0.7                         3





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


        int   pthread_attr_destroy(pthread_attr_t *);
        int   pthread_attr_getdetachstate(const pthread_attr_t *, int *);
        int   pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
        int   pthread_attr_getinheritsched(const pthread_attr_t *, int *);
        int   pthread_attr_getschedparam(const pthread_attr_t *, struct sched_param *);
        int   pthread_attr_getschedpolicy(const pthread_attr_t *, int *);
        int   pthread_attr_getscope(const pthread_attr_t *, int *);
        int   pthread_attr_getstackaddr(const pthread_attr_t *, void **);
        int   pthread_attr_getstacksize(const pthread_attr_t *, size_t *);
        int   pthread_attr_init(pthread_attr_t *);
        int   pthread_attr_setdetachstate(pthread_attr_t *, int);
        int   pthread_attr_setguardsize(pthread_attr_t *, size_t);
        int   pthread_attr_setinheritsched(pthread_attr_t *, int);
        int   pthread_attr_setschedparam(pthread_attr_t *, const struct sched_param *);
        int   pthread_attr_setschedpolicy(pthread_attr_t *, int);
        int   pthread_attr_setscope(pthread_attr_t *, int);
        int   pthread_attr_setstackaddr(pthread_attr_t *, void *);
        int   pthread_attr_setstacksize(pthread_attr_t *, size_t);
        int   pthread_cancel(pthread_t);
        void  pthread_cleanup_push(void*), void *);
        void  pthread_cleanup_pop(int);
        int   pthread_cond_broadcast(pthread_cond_t *);
        int   pthread_cond_destroy(pthread_cond_t *);
        int   pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *);
        int   pthread_cond_signal(pthread_cond_t *);
        int   pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *, const struct timespec *);
        int   pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
        int   pthread_condattr_destroy(pthread_condattr_t *);
        int   pthread_condattr_getpshared(const pthread_condattr_t *, int *);
        int   pthread_condattr_init(pthread_condattr_t *);
        int   pthread_condattr_setpshared(pthread_condattr_t *, int);
        int   pthread_create(pthread_t *, const pthread_attr_t *, void *(*)(void *), void *);
        int   pthread_detach(pthread_t);
        int   pthread_equal(pthread_t, pthread_t);
        void  pthread_exit(void *);
        int   pthread_getconcurrency(void);
        int   pthread_getschedparam(pthread_t, int *, struct sched_param *);
        void *pthread_getspecific(pthread_key_t);
        int   pthread_join(pthread_t, void **);
        int   pthread_key_create(pthread_key_t *, void (*)(void *));
        int   pthread_key_delete(pthread_key_t);
        int   pthread_mutex_destroy(pthread_mutex_t *);
        int   pthread_mutex_getprioceiling(const pthread_mutex_t *, int *);
        int   pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *);
        int   pthread_mutex_lock(pthread_mutex_t *);
        int   pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *);
        int   pthread_mutex_trylock(pthread_mutex_t *);
        int   pthread_mutex_unlock(pthread_mutex_t *);
        int   pthread_mutexattr_destroy(pthread_mutexattr_t *);
        int   pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *, int *);
        int   pthread_mutexattr_getprotocol(const pthread_mutexattr_t *, int *);
        int   pthread_mutexattr_getpshared(const pthread_mutexattr_t *, int *);
        int   pthread_mutexattr_gettype(const pthread_mutexattr_t *, int *);
        int   pthread_mutexattr_init(pthread_mutexattr_t *);



08-Jun-2006               GNU Pth 2.0.7                         4





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


        int   pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
        int   pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
        int   pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
        int   pthread_mutexattr_settype(pthread_mutexattr_t *, int);
        int   pthread_once(pthread_once_t *, void (*)(void));
        int   pthread_rwlock_destroy(pthread_rwlock_t *);
        int   pthread_rwlock_init(pthread_rwlock_t *, const pthread_rwlockattr_t *);
        int   pthread_rwlock_rdlock(pthread_rwlock_t *);
        int   pthread_rwlock_tryrdlock(pthread_rwlock_t *);
        int   pthread_rwlock_trywrlock(pthread_rwlock_t *);
        int   pthread_rwlock_unlock(pthread_rwlock_t *);
        int   pthread_rwlock_wrlock(pthread_rwlock_t *);
        int   pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
        int   pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *, int *);
        int   pthread_rwlockattr_init(pthread_rwlockattr_t *);
        int   pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
        pthread_t pthread_self(void);
        int   pthread_setcancelstate(int, int *);
        int   pthread_setcanceltype(int, int *);
        int   pthread_setconcurrency(int);
        int   pthread_setschedparam(pthread_t, int, const struct sched_param *);
        int   pthread_setspecific(pthread_key_t, const void *);
        void  pthread_testcancel(void);

       Inclusion of the _<_p_t_h_r_e_a_d_._h> header will make visible
       symbols defined in the headers _<_s_c_h_e_d_._h> and _<_t_i_m_e_._h>.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       An interpretation request has been filed with IEEE PASC
       concerning requirements for visibility of symbols in this
       header.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___g_e_t_g_u_a_r_d_s_i_z_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_), _p_t_h_r_e_a_d___c_a_n_c_e_l_(_),
       _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_u_s_h_(_), _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_), _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _p_t_h_r_e_a_d___d_e_t_a_c_h_(_), _p_t_h_r_e_a_d___e_q_u_a_l_(_), _p_t_h_r_e_a_d___e_x_i_t_(_),
       _p_t_h_r_e_a_d___g_e_t_c_o_n_c_u_r_r_e_n_c_y_(_), _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_),
       _p_t_h_r_e_a_d___j_o_i_n_(_), _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_),
       _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_), _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_t_y_p_e_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_o_t_o_c_o_l_(_), _p_t_h_r_e_a_d___o_n_c_e_(_),
       _p_t_h_r_e_a_d___s_e_l_f_(_), _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_),
       _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_),
       _<_s_c_h_e_d_._h>, _<_t_i_m_e_._h>.




08-Jun-2006               GNU Pth 2.0.7                         5





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattffoorrkk - register fork handlers

SSYYNNOOPPSSIISS
       #include <sys/types.h>

       #include <unistd.h>

       int pthread_atfork(void (*_p_r_e_p_a_r_e)(void), void
       (*_p_a_r_e_n_t)(void), void (*_c_h_i_l_d)(void));

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___a_t_f_o_r_k_(_) function declares fork handlers to be
       called before and after _f_o_r_k_(_), in the context of the
       thread that called _f_o_r_k_(_). The _p_r_e_p_a_r_e fork handler is
       called before _f_o_r_k_(_) processing commences. The _p_a_r_e_n_t fork
       handle is called after _f_o_r_k_(_) processing completes in the
       parent process. The _c_h_i_l_d fork handler is called after
       _f_o_r_k_(_) processing completes in the child process. If no
       handling is desired at one or more of these three points,
       the corresponding fork handler address(es) may be set to
       NULL.

       The order of calls to _p_t_h_r_e_a_d___a_t_f_o_r_k_(_) is significant. The
       _p_a_r_e_n_t and _c_h_i_l_d fork handlers are called in the order in
       which they were established by calls to _p_t_h_r_e_a_d___a_t_f_o_r_k_(_).
       The _p_r_e_p_a_r_e fork handlers are called in the opposite
       order.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___a_t_f_o_r_k_(_) returns a
       value of zero.  Otherwise, an error number is returned to
       indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_f_o_r_k_(_) function will fail if:

       [ENOMEM]
           Insufficient table space exists to record the fork
           handler addresses.

       The _p_t_h_r_e_a_d___a_t_f_o_r_k_(_) function will not return an error
       code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.




08-Jun-2006               GNU Pth 2.0.7                         6





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSEEEE AALLSSOO
       _a_t_e_x_i_t_(_), _f_o_r_k_(_), _<_s_y_s_/_t_y_p_e_s_._h>

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__iinniitt,, pptthhrreeaadd__aattttrr__ddeessttrrooyy - initialise and
       destroy threads attribute object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_init(pthread_attr_t *_a_t_t_r);

       int pthread_attr_destroy(pthread_attr_t *_a_t_t_r);

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_) initialises a thread
       attributes object _a_t_t_r with the default value for all of
       the individual attributes used by a given implementation.

       The resulting attribute object (possibly modified by
       setting individual attribute values), when used by
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), defines the attributes of the thread
       created. A single attributes object can be used in
       multiple simultaneous calls to _p_t_h_r_e_a_d___c_r_e_a_t_e_(_).

       The _p_t_h_r_e_a_d___a_t_t_r___d_e_s_t_r_o_y_(_) function is used to destroy a
       thread attributes object. An implementation may cause
       _p_t_h_r_e_a_d___a_t_t_r___d_e_s_t_r_o_y_(_) to set _a_t_t_r to an implementation-
       dependent invalid value. The behaviour of using the
       attribute after it has been destroyed is undefined.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___d_e_s_t_r_o_y_(_) return a value of 0. Otherwise, an
       error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_) function will fail if:

       [ENOMEM]
           Insufficient memory exists to initialise the thread
           attributes object.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.



08-Jun-2006               GNU Pth 2.0.7                         7





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettddeettaacchhssttaattee,, pptthhrreeaadd__aattttrr__ggeettddeettaacchhssttaattee -
       set and get detachstate attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setdetachstate(pthread_attr_t *_a_t_t_r, int
       _d_e_t_a_c_h_s_t_a_t_e);

       int pthread_attr_getdetachstate(const pthread_attr_t
       *_a_t_t_r, int *_d_e_t_a_c_h_s_t_a_t_e);

DDEESSCCRRIIPPTTIIOONN
       The _d_e_t_a_c_h_s_t_a_t_e attribute controls whether the thread is
       created in a detached state. If the thread is created
       detached, then use of the ID of the newly created thread
       by the _p_t_h_r_e_a_d___d_e_t_a_c_h_(_) or _p_t_h_r_e_a_d___j_o_i_n_(_) function is an
       error.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_d_e_t_a_c_h_s_t_a_t_e_(_), respectively, set and get
       the _d_e_t_a_c_h_s_t_a_t_e attribute in the _a_t_t_r object.

       The _d_e_t_a_c_h_s_t_a_t_e can be set to either
       PTHREAD_CREATE_DETACHED or PTHREAD_CREATE_JOINABLE. A
       value of PTHREAD_CREATE_DETACHED causes all threads
       created with _a_t_t_r to be in the detached state, whereas
       using a value of PTHREAD_CREATE_JOINABLE causes all
       threads created with _a_t_t_r to be in the joinable state. The
       default value of the _d_e_t_a_c_h_s_t_a_t_e attribute is
       PTHREAD_CREATE_JOINABLE .

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_)
       and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_d_e_t_a_c_h_s_t_a_t_e_(_) return a value of 0.
       Otherwise, an error number is returned to indicate the
       error.

       The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_d_e_t_a_c_h_s_t_a_t_e_(_) function stores the
       value of the _d_e_t_a_c_h_s_t_a_t_e attribute in _d_e_t_a_c_h_s_t_a_t_e if
       successful.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_) function will fail if:

       [EINVAL]
           The value of _d_e_t_a_c_h_s_t_a_t_e was not valid



08-Jun-2006               GNU Pth 2.0.7                         8





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__ggeettgguuaarrddssiizzee,, pptthhrreeaadd__aattttrr__sseettgguuaarrddssiizzee - get
       or set the thread guardsize attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_getguardsize(const pthread_attr_t _*_a_t_t_r,
       size_t _*_g_u_a_r_d_s_i_z_e); int
       pthread_attr_setguardsize(pthread_attr_t _*_a_t_t_r, size_t
       _g_u_a_r_d_s_i_z_e);

DDEESSCCRRIIPPTTIIOONN
       The _g_u_a_r_d_s_i_z_e attribute controls the size of the guard
       area for the created thread's stack. The _g_u_a_r_d_s_i_z_e
       attribute provides protection against overflow of the
       stack pointer. If a thread's stack is created with guard
       protection, the implementation allocates extra memory at
       the overflow end of the stack as a buffer against stack
       overflow of the stack pointer. If an application overflows
       into this buffer an error results (possibly in a SIGSEGV
       signal being delivered to the thread).

       The _g_u_a_r_d_s_i_z_e attribute is provided to the application for
       two reasons:

       1.  Overflow protection can potentially result in wasted
           system resources.  An application that creates a large
           number of threads, and which knows its threads will
           never overflow their stack, can save system resources
           by turning off guard areas.

       2.  When threads allocate large data structures on the
           stack, large guard areas may be needed to detect stack
           overflow.

       The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_g_u_a_r_d_s_i_z_e_(_) function gets the



08-Jun-2006               GNU Pth 2.0.7                         9





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _g_u_a_r_d_s_i_z_e attribute in the _a_t_t_r object. This attribute is
       returned in the _g_u_a_r_d_s_i_z_e parameter.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_g_u_a_r_d_s_i_z_e_(_) function sets the
       _g_u_a_r_d_s_i_z_e attribute in the _a_t_t_r object. The new value of
       this attribute is obtained from the _g_u_a_r_d_s_i_z_e parameter.
       If _g_u_a_r_d_s_i_z_e is zero, a guard area will not be provided
       for threads created with _a_t_t_r.  If _g_u_a_r_d_s_i_z_e is greater
       than zero, a guard area of at least size _g_u_a_r_d_s_i_z_e bytes
       is provided for each thread created with _a_t_t_r.

       A conforming implementation is permitted to round up the
       value contained in _g_u_a_r_d_s_i_z_e to a multiple of the
       configurable system variable PAGESIZE (see _<_s_y_s_/_m_m_a_n_._h>).
       If an implementation rounds up the value of _g_u_a_r_d_s_i_z_e to a
       multiple of PAGESIZE, a call to
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_g_u_a_r_d_s_i_z_e_(_) specifying _a_t_t_r will store in
       the _g_u_a_r_d_s_i_z_e parameter the guard size specified by the
       previous _p_t_h_r_e_a_d___a_t_t_r___s_e_t_g_u_a_r_d_s_i_z_e_(_) function call.

       The default value of the _g_u_a_r_d_s_i_z_e attribute is PAGESIZE
       bytes. The actual value of PAGESIZE is implementation-
       dependent and may not be the same on all implementations.

       If the _s_t_a_c_k_a_d_d_r attribute has been set (that is, the
       caller is allocating and managing its own thread stacks),
       the _g_u_a_r_d_s_i_z_e attribute is ignored and no protection will
       be provided by the implementation. It is the
       responsibility of the application to manage stack overflow
       along with stack allocation and management in this case.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___g_e_t_g_u_a_r_d_s_i_z_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_g_u_a_r_d_s_i_z_e_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_g_u_a_r_d_s_i_z_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_g_u_a_r_d_s_i_z_e_(_) functions will fail if:

       [EINVAL]
           The attribute _a_t_t_r is invalid.

       [EINVAL]
           The parameter _g_u_a_r_d_s_i_z_e is invalid.

       [EINVAL]
           The parameter _g_u_a_r_d_s_i_z_e contains an invalid value.

EEXXAAMMPPLLEESS
       None.





08-Jun-2006               GNU Pth 2.0.7                        10





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettiinnhheerriittsscchheedd,, pptthhrreeaadd__aattttrr__ggeettiinnhheerriittsscchheedd
       - set and get inheritsched attribute (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setinheritsched(pthread_attr_t *_a_t_t_r, int
       _i_n_h_e_r_i_t_s_c_h_e_d); int pthread_attr_getinheritsched(const
       pthread_attr_t *_a_t_t_r, int *_i_n_h_e_r_i_t_s_c_h_e_d);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_), respectively, set and get
       the _i_n_h_e_r_i_t_s_c_h_e_d attribute in the _a_t_t_r argument.

       When the attribute objects are used by _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       the _i_n_h_e_r_i_t_s_c_h_e_d attribute determines how the other
       scheduling attributes of the created thread are to be set:

       PTHREAD_INHERIT_SCHED
           Specifies that the scheduling policy and associated
           attributes are to be inherited from the creating
           thread, and the scheduling attributes in this _a_t_t_r
           argument are to be ignored.

       PTHREAD_EXPLICIT_SCHED
           Specifies that the scheduling policy and associated
           attributes are to be set to the corresponding values
           from this attribute object.

       The symbols PTHREAD_INHERIT_SCHED and
       PTHREAD_EXPLICIT_SCHED are defined in the header
       _<_p_t_h_r_e_a_d_._h>.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) functions will fail if:



08-Jun-2006               GNU Pth 2.0.7                        11





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [ENOSYS]
           The option _POSIX_THREAD_PRIORITY_SCHEDULING is not
           defined and the implementation does not support the
           function.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) function may fail if:

       [EINVAL]
           The value of the attribute being set is not valid.

       [ENOTSUP]
           An attempt was made to set the attribute to an
           unsupported value.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       After these attributes have been set, a thread can be
       created with the specified attributes using
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_). Using these routines does not affect the
       current running thread.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _<_s_c_h_e_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettsscchheeddppaarraamm,, pptthhrreeaadd__aattttrr__ggeettsscchheeddppaarraamm -
       set and get schedparam attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setschedparam(pthread_attr_t *_a_t_t_r, const
       struct sched_param *_p_a_r_a_m);

       int pthread_attr_getschedparam(const pthread_attr_t *_a_t_t_r,
       struct sched_param *_p_a_r_a_m);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_a_r_a_m_(_), respectively, set and get
       the scheduling parameter attributes in the _a_t_t_r argument.
       The contents of the _p_a_r_a_m structure are defined in
       _<_s_c_h_e_d_._h>. For the SCHED_FIFO and SCHED_RR policies, the
       only required member of _p_a_r_a_m is _s_c_h_e_d___p_r_i_o_r_i_t_y.




08-Jun-2006               GNU Pth 2.0.7                        12





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) function may fail if:

       [EINVAL]
           The value of the attribute being set is not valid.

       [ENOTSUP]
           An attempt was made to set the attribute to an
           unsupported value.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) functions will not return an
       error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       After these attributes have been set, a thread can be
       created with the specified attributes using
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_). Using these routines does not affect the
       current running thread.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _<_s_c_h_e_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettsscchheeddppoolliiccyy,, pptthhrreeaadd__aattttrr__ggeettsscchheeddppoolliiccyy -
       set and get schedpolicy attribute (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setschedpolicy(pthread_attr_t *_a_t_t_r, int
       _p_o_l_i_c_y); int pthread_attr_getschedpolicy(const
       pthread_attr_t *_a_t_t_r, int *_p_o_l_i_c_y);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_o_l_i_c_y_(_), respectively, set and get
       the _s_c_h_e_d_p_o_l_i_c_y attribute in the _a_t_t_r argument.



08-Jun-2006               GNU Pth 2.0.7                        13





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       The supported values of _p_o_l_i_c_y include SCHED_FIFO,
       SCHED_RR and SCHED_OTHER, which are defined by the header
       _<_s_c_h_e_d_._h>. When threads executing with the scheduling
       policy SCHED_FIFO or SCHED_RR are waiting on a mutex, they
       acquire the mutex in priority order when the mutex is
       unlocked.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIORITY_SCHEDULING is not
           defined and the implementation does not support the
           function.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) function may fail if:

       [EINVAL]
           The value of the attribute being set is not valid.

       [ENOTSUP]
           An attempt was made to set the attribute to an
           unsupported value.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       After these attributes have been set, a thread can be
       created with the specified attributes using
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_). Using these routines does not affect the
       current running thread.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _<_s_c_h_e_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettssccooppee,, pptthhrreeaadd__aattttrr__ggeettssccooppee - set and get
       contentionscope attribute (RREEAALLTTIIMMEE TTHHRREEAADDSS)




08-Jun-2006               GNU Pth 2.0.7                        14





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setscope(pthread_attr_t *_a_t_t_r, int
       _c_o_n_t_e_n_t_i_o_n_s_c_o_p_e); int pthread_attr_getscope(const
       pthread_attr_t *_a_t_t_r, int *_c_o_n_t_e_n_t_i_o_n_s_c_o_p_e);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_) and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_o_p_e_(_)
       functions are used to set and get the _c_o_n_t_e_n_t_i_o_n_s_c_o_p_e
       attribute in the _a_t_t_r object.

       The _c_o_n_t_e_n_t_i_o_n_s_c_o_p_e attribute may have the values
       PTHREAD_SCOPE_SYSTEM, signifying system scheduling
       contention scope, or PTHREAD_SCOPE_PROCESS, signifying
       process scheduling contention scope.  The symbols
       PTHREAD_SCOPE_SYSTEM and PTHREAD_SCOPE_PROCESS are defined
       by the header _<_p_t_h_r_e_a_d_._h>.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_o_p_e_(_) functions return zero. Otherwise,
       an error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_) and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_o_p_e_(_)
       functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIORITY_SCHEDULING is not
           defined and the implementation does not support the
           function.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_), function may fail if:

       [EINVAL]
           The value of the attribute being set is not valid.

       [ENOTSUP]
           An attempt was made to set the attribute to an
           unsupported value.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       After these attributes have been set, a thread can be
       created with the specified attributes using
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_). Using these routines does not affect the
       current running thread.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.




08-Jun-2006               GNU Pth 2.0.7                        15





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _<_s_c_h_e_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettssttaacckkaaddddrr,, pptthhrreeaadd__aattttrr__ggeettssttaacckkaaddddrr - set
       and get stackaddr attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setstackaddr(pthread_attr_t *_a_t_t_r, void
       *_s_t_a_c_k_a_d_d_r);

       int pthread_attr_getstackaddr(const pthread_attr_t *_a_t_t_r,
       void **_s_t_a_c_k_a_d_d_r);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_a_d_d_r_(_), respectively, set and get the
       thread creation _s_t_a_c_k_a_d_d_r attribute in the _a_t_t_r object.

       The _s_t_a_c_k_a_d_d_r attribute specifies the location of storage
       to be used for the created thread's stack. The size of the
       storage is at least PTHREAD_STACK_MIN.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_)
       and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_a_d_d_r_(_) return a value of 0.
       Otherwise, an error number is returned to indicate the
       error.

       The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_a_d_d_r_(_) function stores the
       _s_t_a_c_k_a_d_d_r attribute value in _s_t_a_c_k_a_d_d_r if successful.

EERRRROORRSS
       No errors are defined.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_),



08-Jun-2006               GNU Pth 2.0.7                        16





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _<_l_i_m_i_t_s_._h>,
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettssttaacckkssiizzee,, pptthhrreeaadd__aattttrr__ggeettssttaacckkssiizzee - set
       and get stacksize attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setstacksize(pthread_attr_t *_a_t_t_r, size_t
       _s_t_a_c_k_s_i_z_e); int pthread_attr_getstacksize(const
       pthread_attr_t *_a_t_t_r, size_t *_s_t_a_c_k_s_i_z_e);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_s_i_z_e_(_), respectively, set and get the
       thread creation _s_t_a_c_k_s_i_z_e attribute in the _a_t_t_r object.

       The _s_t_a_c_k_s_i_z_e attribute defines the minimum stack size (in
       bytes) allocated for the created threads stack.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_)
       and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_s_i_z_e_(_) return a value of 0.
       Otherwise, an error number is returned to indicate the
       error.  The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_s_i_z_e_(_) function stores
       the _s_t_a_c_k_s_i_z_e attribute value in _s_t_a_c_k_s_i_z_e if successful.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_) function will fail if:

       [EINVAL]
           The value of _s_t_a_c_k_s_i_z_e is less than PTHREAD_STACK_MIN
           or exceeds a system-imposed limit.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_l_i_m_i_t_s_._h>, _<_p_t_h_r_e_a_d_._h>.





08-Jun-2006               GNU Pth 2.0.7                        17





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__iinniitt,, pptthhrreeaadd__aattttrr__ddeessttrrooyy - initialise and
       destroy threads attribute object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_init(pthread_attr_t *_a_t_t_r); int
       pthread_attr_destroy(pthread_attr_t *_a_t_t_r);

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_) initialises a thread
       attributes object _a_t_t_r with the default value for all of
       the individual attributes used by a given implementation.

       The resulting attribute object (possibly modified by
       setting individual attribute values), when used by
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), defines the attributes of the thread
       created.  A single attributes object can be used in
       multiple simultaneous calls to _p_t_h_r_e_a_d___c_r_e_a_t_e_(_).

       The _p_t_h_r_e_a_d___a_t_t_r___d_e_s_t_r_o_y_(_) function is used to destroy a
       thread attributes object.  An implementation may cause
       _p_t_h_r_e_a_d___a_t_t_r___d_e_s_t_r_o_y_(_) to set _a_t_t_r to an implementation-
       dependent invalid value.  The behaviour of using the
       attribute after it has been destroyed is undefined.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___d_e_s_t_r_o_y_(_) return a value of 0.  Otherwise, an
       error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_) function will fail if:

       [ENOMEM]
           Insufficient memory exists to initialise the thread
           attributes object.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),



08-Jun-2006               GNU Pth 2.0.7                        18





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettddeettaacchhssttaattee,, pptthhrreeaadd__aattttrr__ggeettddeettaacchhssttaattee -
       set and get detachstate attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setdetachstate(pthread_attr_t *_a_t_t_r, int
       _d_e_t_a_c_h_s_t_a_t_e); int pthread_attr_getdetachstate(const
       pthread_attr_t *_a_t_t_r, int *_d_e_t_a_c_h_s_t_a_t_e);

DDEESSCCRRIIPPTTIIOONN
       The _d_e_t_a_c_h_s_t_a_t_e attribute controls whether the thread is
       created in a detached state.  If the thread is created
       detached, then use of the ID of the newly created thread
       by the _p_t_h_r_e_a_d___d_e_t_a_c_h_(_) or _p_t_h_r_e_a_d___j_o_i_n_(_) function is an
       error.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_d_e_t_a_c_h_s_t_a_t_e_(_), respectively, set and get
       the _d_e_t_a_c_h_s_t_a_t_e attribute in the _a_t_t_r object.

       The _d_e_t_a_c_h_s_t_a_t_e can be set to either
       PTHREAD_CREATE_DETACHED or PTHREAD_CREATE_JOINABLE.  A
       value of PTHREAD_CREATE_DETACHED causes all threads
       created with _a_t_t_r to be in the detached state, whereas
       using a value of PTHREAD_CREATE_JOINABLE causes all
       threads created with _a_t_t_r to be in the joinable state.
       The default value of the _d_e_t_a_c_h_s_t_a_t_e attribute is
       PTHREAD_CREATE_JOINABLE .

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_)
       and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_d_e_t_a_c_h_s_t_a_t_e_(_) return a value of 0.
       Otherwise, an error number is returned to indicate the
       error.

       The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_d_e_t_a_c_h_s_t_a_t_e_(_) function stores the
       value of the _d_e_t_a_c_h_s_t_a_t_e attribute in _d_e_t_a_c_h_s_t_a_t_e if
       successful.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_) function will fail if:

       [EINVAL]
           The value of _d_e_t_a_c_h_s_t_a_t_e was not valid

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.



08-Jun-2006               GNU Pth 2.0.7                        19





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__ggeettgguuaarrddssiizzee,, pptthhrreeaadd__aattttrr__sseettgguuaarrddssiizzee - get
       or set the thread guardsize attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_getguardsize(const pthread_attr_t _*_a_t_t_r,
       size_t _*_g_u_a_r_d_s_i_z_e); int
       pthread_attr_setguardsize(pthread_attr_t _*_a_t_t_r, size_t
       _g_u_a_r_d_s_i_z_e);

DDEESSCCRRIIPPTTIIOONN
       The _g_u_a_r_d_s_i_z_e attribute controls the size of the guard
       area for the created thread's stack. The _g_u_a_r_d_s_i_z_e
       attribute provides protection against overflow of the
       stack pointer. If a thread's stack is created with guard
       protection, the implementation allocates extra memory at
       the overflow end of the stack as a buffer against stack
       overflow of the stack pointer. If an application overflows
       into this buffer an error results (possibly in a SIGSEGV
       signal being delivered to the thread).

       The _g_u_a_r_d_s_i_z_e attribute is provided to the application for
       two reasons:

       1.  Overflow protection can potentially result in wasted
           system resources. An application that creates a large
           number of threads, and which knows its threads will
           never overflow their stack, can save system resources
           by turning off guard areas.

       2.  When threads allocate large data structures on the
           stack, large guard areas may be needed to detect stack
           overflow.

       The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_g_u_a_r_d_s_i_z_e_(_) function gets the
       _g_u_a_r_d_s_i_z_e attribute in the _a_t_t_r object. This attribute is
       returned in the _g_u_a_r_d_s_i_z_e parameter.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_g_u_a_r_d_s_i_z_e_(_) function sets the
       _g_u_a_r_d_s_i_z_e attribute in the _a_t_t_r object. The new value of



08-Jun-2006               GNU Pth 2.0.7                        20





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       this attribute is obtained from the _g_u_a_r_d_s_i_z_e parameter.
       If _g_u_a_r_d_s_i_z_e is zero, a guard area will not be provided
       for threads created with _a_t_t_r. If _g_u_a_r_d_s_i_z_e is greater
       than zero, a guard area of at least size _g_u_a_r_d_s_i_z_e bytes
       is provided for each thread created with _a_t_t_r.

       A conforming implementation is permitted to round up the
       value contained in _g_u_a_r_d_s_i_z_e to a multiple of the
       configurable system variable PAGESIZE (see _<_s_y_s_/_m_m_a_n_._h>).
       If an implementation rounds up the value of _g_u_a_r_d_s_i_z_e to a
       multiple of PAGESIZE, a call to
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_g_u_a_r_d_s_i_z_e_(_) specifying _a_t_t_r will store in
       the _g_u_a_r_d_s_i_z_e parameter the guard size specified by the
       previous _p_t_h_r_e_a_d___a_t_t_r___s_e_t_g_u_a_r_d_s_i_z_e_(_) function call.

       The default value of the _g_u_a_r_d_s_i_z_e attribute is PAGESIZE
       bytes.  The actual value of PAGESIZE is implementation-
       dependent and may not be the same on all implementations.

       If the _s_t_a_c_k_a_d_d_r attribute has been set (that is, the
       caller is allocating and managing its own thread stacks),
       the _g_u_a_r_d_s_i_z_e attribute is ignored and no protection will
       be provided by the implementation. It is the
       responsibility of the application to manage stack overflow
       along with stack allocation and management in this case.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___g_e_t_g_u_a_r_d_s_i_z_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_g_u_a_r_d_s_i_z_e_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_g_u_a_r_d_s_i_z_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_g_u_a_r_d_s_i_z_e_(_) functions will fail if:

       [EINVAL]
           The attribute _a_t_t_r is invalid.

       [EINVAL]
           The parameter _g_u_a_r_d_s_i_z_e is invalid.

       [EINVAL]
           The parameter _g_u_a_r_d_s_i_z_e contains an invalid value.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.




08-Jun-2006               GNU Pth 2.0.7                        21





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettiinnhheerriittsscchheedd,, pptthhrreeaadd__aattttrr__ggeettiinnhheerriittsscchheedd
       - set and get inheritsched attribute (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setinheritsched(pthread_attr_t *_a_t_t_r, int
       _i_n_h_e_r_i_t_s_c_h_e_d); int pthread_attr_getinheritsched(const
       pthread_attr_t *_a_t_t_r, int *_i_n_h_e_r_i_t_s_c_h_e_d);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_), respectively, set and get
       the _i_n_h_e_r_i_t_s_c_h_e_d attribute in the _a_t_t_r argument.

       When the attribute objects are used by _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       the _i_n_h_e_r_i_t_s_c_h_e_d attribute determines how the other
       scheduling attributes of the created thread are to be set:

       PTHREAD_INHERIT_SCHED
           Specifies that the scheduling policy and associated
           attributes are to be inherited from the creating
           thread, and the scheduling attributes in this _a_t_t_r
           argument are to be ignored.

       PTHREAD_EXPLICIT_SCHED
           Specifies that the scheduling policy and associated
           attributes are to be set to the corresponding values
           from this attribute object.

       The symbols PTHREAD_INHERIT_SCHED and
       PTHREAD_EXPLICIT_SCHED are defined in the header
       _<_p_t_h_r_e_a_d_._h>.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIORITY_SCHEDULING is not
           defined and the implementation does not support the
           function.




08-Jun-2006               GNU Pth 2.0.7                        22





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_) function may fail if:

       [EINVAL]
           The value of the attribute being set is not valid.

       [ENOTSUP]
           An attempt was made to set the attribute to an
           unsupported value.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       After these attributes have been set, a thread can be
       created with the specified attributes using
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_).  Using these routines does not affect
       the current running thread.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _<_s_c_h_e_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettsscchheeddppaarraamm,, pptthhrreeaadd__aattttrr__ggeettsscchheeddppaarraamm -
       set and get schedparam attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setschedparam(pthread_attr_t *_a_t_t_r, const
       struct sched_param *_p_a_r_a_m); int
       pthread_attr_getschedparam(const pthread_attr_t *_a_t_t_r,
       struct sched_param *_p_a_r_a_m);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_a_r_a_m_(_), respectively, set and get
       the scheduling parameter attributes in the _a_t_t_r argument.
       The contents of the _p_a_r_a_m structure are defined in
       _<_s_c_h_e_d_._h>.  For the SCHED_FIFO and SCHED_RR policies, the
       only required member of _p_a_r_a_m is _s_c_h_e_d___p_r_i_o_r_i_t_y.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.




08-Jun-2006               GNU Pth 2.0.7                        23





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) function may fail if:

       [EINVAL]
           The value of the attribute being set is not valid.

       [ENOTSUP]
           An attempt was made to set the attribute to an
           unsupported value.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) functions will not return an
       error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       After these attributes have been set, a thread can be
       created with the specified attributes using
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_).  Using these routines does not affect
       the current running thread.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _<_s_c_h_e_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettsscchheeddppoolliiccyy,, pptthhrreeaadd__aattttrr__ggeettsscchheeddppoolliiccyy -
       set and get schedpolicy attribute (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setschedpolicy(pthread_attr_t *_a_t_t_r, int
       _p_o_l_i_c_y); int pthread_attr_getschedpolicy(const
       pthread_attr_t *_a_t_t_r, int *_p_o_l_i_c_y);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_o_l_i_c_y_(_), respectively, set and get
       the _s_c_h_e_d_p_o_l_i_c_y attribute in the _a_t_t_r argument.

       The supported values of _p_o_l_i_c_y include SCHED_FIFO,
       SCHED_RR and SCHED_OTHER, which are defined by the header
       _<_s_c_h_e_d_._h>.  When threads executing with the scheduling
       policy SCHED_FIFO or SCHED_RR are waiting on a mutex, they
       acquire the mutex in priority order when the mutex is



08-Jun-2006               GNU Pth 2.0.7                        24





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       unlocked.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIORITY_SCHEDULING is not
           defined and the implementation does not support the
           function.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_) function may fail if:

       [EINVAL]
           The value of the attribute being set is not valid.

       [ENOTSUP]
           An attempt was made to set the attribute to an
           unsupported value.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       After these attributes have been set, a thread can be
       created with the specified attributes using
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_).  Using these routines does not affect
       the current running thread.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _<_s_c_h_e_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettssccooppee,, pptthhrreeaadd__aattttrr__ggeettssccooppee - set and get
       contentionscope attribute (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setscope(pthread_attr_t *_a_t_t_r, int
       _c_o_n_t_e_n_t_i_o_n_s_c_o_p_e); int pthread_attr_getscope(const



08-Jun-2006               GNU Pth 2.0.7                        25





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       pthread_attr_t *_a_t_t_r, int *_c_o_n_t_e_n_t_i_o_n_s_c_o_p_e);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_) and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_o_p_e_(_)
       functions are used to set and get the _c_o_n_t_e_n_t_i_o_n_s_c_o_p_e
       attribute in the _a_t_t_r object.

       The _c_o_n_t_e_n_t_i_o_n_s_c_o_p_e attribute may have the values
       PTHREAD_SCOPE_SYSTEM, signifying system scheduling
       contention scope, or PTHREAD_SCOPE_PROCESS, signifying
       process scheduling contention scope.  The symbols
       PTHREAD_SCOPE_SYSTEM and PTHREAD_SCOPE_PROCESS are defined
       by the header _<_p_t_h_r_e_a_d_._h>.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_o_p_e_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_) and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_c_o_p_e_(_)
       functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIORITY_SCHEDULING is not
           defined and the implementation does not support the
           function.

       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_o_p_e_(_), function may fail if:

       [EINVAL]
           The value of the attribute being set is not valid.

       [ENOTSUP]
           An attempt was made to set the attribute to an
           unsupported value.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       After these attributes have been set, a thread can be
       created with the specified attributes using
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_).  Using these routines does not affect
       the current running thread.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_i_n_h_e_r_i_t_s_c_h_e_d_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_o_l_i_c_y_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_), _<_s_c_h_e_d_._h>.



08-Jun-2006               GNU Pth 2.0.7                        26





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettssttaacckkaaddddrr,, pptthhrreeaadd__aattttrr__ggeettssttaacckkaaddddrr - set
       and get stackaddr attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setstackaddr(pthread_attr_t *_a_t_t_r, void
       *_s_t_a_c_k_a_d_d_r); int pthread_attr_getstackaddr(const
       pthread_attr_t *_a_t_t_r, void **_s_t_a_c_k_a_d_d_r);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_a_d_d_r_(_), respectively, set and get the
       thread creation _s_t_a_c_k_a_d_d_r attribute in the _a_t_t_r object.

       The _s_t_a_c_k_a_d_d_r attribute specifies the location of storage
       to be used for the created thread's stack.  The size of
       the storage is at least PTHREAD_STACK_MIN.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_)
       and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_a_d_d_r_(_) return a value of 0.
       Otherwise, an error number is returned to indicate the
       error.

       The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_a_d_d_r_(_) function stores the
       _s_t_a_c_k_a_d_d_r attribute value in _s_t_a_c_k_a_d_d_r if successful.

EERRRROORRSS
       No errors are defined.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _<_l_i_m_i_t_s_._h>,
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__aattttrr__sseettssttaacckkssiizzee,, pptthhrreeaadd__aattttrr__ggeettssttaacckkssiizzee - set
       and get stacksize attribute




08-Jun-2006               GNU Pth 2.0.7                        27





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_attr_setstacksize(pthread_attr_t *_a_t_t_r, size_t
       _s_t_a_c_k_s_i_z_e); int pthread_attr_getstacksize(const
       pthread_attr_t *_a_t_t_r, size_t *_s_t_a_c_k_s_i_z_e);

DDEESSCCRRIIPPTTIIOONN
       The functions _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_) and
       _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_s_i_z_e_(_), respectively, set and get the
       thread creation _s_t_a_c_k_s_i_z_e attribute in the _a_t_t_r object.

       The _s_t_a_c_k_s_i_z_e attribute defines the minimum stack size (in
       bytes) allocated for the created threads stack.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_)
       and _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_s_i_z_e_(_) return a value of 0.
       Otherwise, an error number is returned to indicate the
       error.  The _p_t_h_r_e_a_d___a_t_t_r___g_e_t_s_t_a_c_k_s_i_z_e_(_) function stores
       the _s_t_a_c_k_s_i_z_e attribute value in _s_t_a_c_k_s_i_z_e if successful.

EERRRROORRSS
       The _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_s_i_z_e_(_) function will fail if:

       [EINVAL]
           The value of _s_t_a_c_k_s_i_z_e is less than PTHREAD_STACK_MIN
           or exceeds a system-imposed limit.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___a_t_t_r___s_e_t_s_t_a_c_k_a_d_d_r_(_),
       _p_t_h_r_e_a_d___a_t_t_r___s_e_t_d_e_t_a_c_h_s_t_a_t_e_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _<_l_i_m_i_t_s_._h>, _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccaanncceell - cancel execution of a thread

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_cancel(pthread_t _t_h_r_e_a_d);




08-Jun-2006               GNU Pth 2.0.7                        28





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___c_a_n_c_e_l_(_) function requests that _t_h_r_e_a_d be
       canceled.  The target threads cancelability state and type
       determines when the cancellation takes effect.  When the
       cancellation is acted on, the cancellation cleanup
       handlers for _t_h_r_e_a_d are called.  When the last
       cancellation cleanup handler returns, the thread-specific
       data destructor functions are called for _t_h_r_e_a_d.  When the
       last destructor function returns, _t_h_r_e_a_d is terminated.

       The cancellation processing in the target thread runs
       asynchronously with respect to the calling thread
       returning from _p_t_h_r_e_a_d___c_a_n_c_e_l_(_).

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_a_n_c_e_l_(_) function returns zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_a_n_c_e_l_(_) function may fail if:

       [ESRCH]
           No thread could be found corresponding to that
           specified by the given thread ID.

       The _p_t_h_r_e_a_d___c_a_n_c_e_l_(_) function will not return an error
       code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___e_x_i_t_(_), _p_t_h_r_e_a_d___j_o_i_n_(_), _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_),
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__cclleeaannuupp__ppuusshh,, pptthhrreeaadd__cclleeaannuupp__ppoopp - establish
       cancellation handlers

SSYYNNOOPPSSIISS
       #include <pthread.h>

       void pthread_cleanup_push(void (*_r_o_u_t_i_n_e)(void*), void
       *_a_r_g); void pthread_cleanup_pop(int _e_x_e_c_u_t_e);




08-Jun-2006               GNU Pth 2.0.7                        29





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_u_s_h_(_) function pushes the specified
       cancellation cleanup handler _r_o_u_t_i_n_e onto the calling
       thread's cancellation cleanup stack.  The cancellation
       cleanup handler is popped from the cancellation cleanup
       stack and invoked with the argument _a_r_g when: (a) the
       thread exits (that is, calls _p_t_h_r_e_a_d___e_x_i_t_(_)), (b) the
       thread acts upon a cancellation request, or (c) the thread
       calls _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_) with a non-zero _e_x_e_c_u_t_e
       argument.

       The _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_) function removes the routine at
       the top of the calling thread's cancellation cleanup stack
       and optionally invokes it (if _e_x_e_c_u_t_e is non-zero).

       These functions may be implemented as macros and will
       appear as statements and in pairs within the same lexical
       scope (that is, the _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_u_s_h_(_) macro may be
       thought to expand to a token list whose first token is ``{{''
       with _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_) expanding to a token list whose
       last token is the corresponding ``}}''.

       The effect of calling _l_o_n_g_j_m_p_(_) or _s_i_g_l_o_n_g_j_m_p_(_) is
       undefined if there have been any calls to
       _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_u_s_h_(_) or _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_) made
       without the matching call since the jump buffer was
       filled.  The effect of calling _l_o_n_g_j_m_p_(_) or _s_i_g_l_o_n_g_j_m_p_(_)
       from inside a cancellation cleanup handler is also
       undefined unless the jump buffer was also filled in the
       cancellation cleanup handler.

RREETTUURRNN VVAALLUUEE
       The _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_u_s_h_(_) and _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_)
       functions return no value.

EERRRROORRSS
       No errors are defined.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_a_n_c_e_l_(_), _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________




08-Jun-2006               GNU Pth 2.0.7                        30





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


NNAAMMEE
       pptthhrreeaadd__cclleeaannuupp__ppuusshh,, pptthhrreeaadd__cclleeaannuupp__ppoopp - establish
       cancellation handlers

SSYYNNOOPPSSIISS
       #include <pthread.h>

       void pthread_cleanup_push(void (*_r_o_u_t_i_n_e)(void*), void
       *_a_r_g); void pthread_cleanup_pop(int _e_x_e_c_u_t_e);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_u_s_h_(_) function pushes the specified
       cancellation cleanup handler _r_o_u_t_i_n_e onto the calling
       thread's cancellation cleanup stack.  The cancellation
       cleanup handler is popped from the cancellation cleanup
       stack and invoked with the argument _a_r_g when: (a) the
       thread exits (that is, calls _p_t_h_r_e_a_d___e_x_i_t_(_)), (b) the
       thread acts upon a cancellation request, or (c) the thread
       calls _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_) with a non-zero _e_x_e_c_u_t_e
       argument.

       The _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_) function removes the routine at
       the top of the calling thread's cancellation cleanup stack
       and optionally invokes it (if _e_x_e_c_u_t_e is non-zero).

       These functions may be implemented as macros and will
       appear as statements and in pairs within the same lexical
       scope (that is, the _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_u_s_h_(_) macro may be
       thought to expand to a token list whose first token is ``{{''
       with _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_) expanding to a token list whose
       last token is the corresponding ``}}''.

       The effect of calling _l_o_n_g_j_m_p_(_) or _s_i_g_l_o_n_g_j_m_p_(_) is
       undefined if there have been any calls to
       _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_u_s_h_(_) or _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_) made
       without the matching call since the jump buffer was
       filled.  The effect of calling _l_o_n_g_j_m_p_(_) or _s_i_g_l_o_n_g_j_m_p_(_)
       from inside a cancellation cleanup handler is also
       undefined unless the jump buffer was also filled in the
       cancellation cleanup handler.

RREETTUURRNN VVAALLUUEE
       The _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_u_s_h_(_) and _p_t_h_r_e_a_d___c_l_e_a_n_u_p___p_o_p_(_)
       functions return no value.

EERRRROORRSS
       No errors are defined.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.





08-Jun-2006               GNU Pth 2.0.7                        31





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_a_n_c_e_l_(_), _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccoonndd__ssiiggnnaall,, pptthhrreeaadd__ccoonndd__bbrrooaaddccaasstt - signal or
       broadcast a condition

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_cond_signal(pthread_cond_t *_c_o_n_d); int
       pthread_cond_broadcast(pthread_cond_t *_c_o_n_d);

DDEESSCCRRIIPPTTIIOONN
       These two functions are used to unblock threads blocked on
       a condition variable.

       The _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) call unblocks at least one of
       the threads that are blocked on the specified condition
       variable _c_o_n_d (if any threads are blocked on _c_o_n_d).

       The _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_) call unblocks all threads
       currently blocked on the specified condition variable
       _c_o_n_d.

       If more than one thread is blocked on a condition
       variable, the scheduling policy determines the order in
       which threads are unblocked.  When each thread unblocked
       as a result of a _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_) returns from its call to
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_), the
       thread owns the mutex with which it called
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_).  The
       thread(s) that are unblocked contend for the mutex
       according to the scheduling policy (if applicable), and as
       if each had called _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_).

       The _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) or _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_)
       functions may be called by a thread whether or not it
       currently owns the mutex that threads calling
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) have
       associated with the condition variable during their waits;
       however, if predictable scheduling behaviour is required,
       then that mutex is locked by the thread calling
       _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) or _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_).

       The _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) and _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_)



08-Jun-2006               GNU Pth 2.0.7                        32





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       functions have no effect if there are no threads currently
       blocked on _c_o_n_d.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) and
       _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) and _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_)
       function may fail if:

       [EINVAL]
           The value _c_o_n_d does not refer to an initialised
           condition variable.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccoonndd__iinniitt,, pptthhrreeaadd__ccoonndd__ddeessttrrooyy - initialise and
       destroy condition variables

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_cond_init(pthread_cond_t *_c_o_n_d, const
       pthread_condattr_t *_a_t_t_r); int
       pthread_cond_destroy(pthread_cond_t *_c_o_n_d); pthread_cond_t
       _c_o_n_d = PTHREAD_COND_INITIALIZER;

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) initialises the condition
       variable referenced by _c_o_n_d with attributes referenced by
       _a_t_t_r.  If _a_t_t_r is NULL, the default condition variable
       attributes are used; the effect is the same as passing the
       address of a default condition variable attributes object.
       Upon successful initialisation, the state of the condition
       variable becomes initialised.




08-Jun-2006               GNU Pth 2.0.7                        33





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       Attempting to initialise an already initialised condition
       variable results in undefined behaviour.

       The function _p_t_h_r_e_a_d___c_o_n_d___d_e_s_t_r_o_y_(_) destroys the given
       condition variable specified by _c_o_n_d; the object becomes,
       in effect, uninitialised.  An implementation may cause
       _p_t_h_r_e_a_d___c_o_n_d___d_e_s_t_r_o_y_(_) to set the object referenced by
       _c_o_n_d to an invalid value.  A destroyed condition variable
       object can be re-initialised using _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_);
       the results of otherwise referencing the object after it
       has been destroyed are undefined.

       It is safe to destroy an initialised condition variable
       upon which no threads are currently blocked.  Attempting
       to destroy a condition variable upon which other threads
       are currently blocked results in undefined behaviour.

       In cases where default condition variable attributes are
       appropriate, the macro PTHREAD_COND_INITIALIZER can be
       used to initialise condition variables that are statically
       allocated.  The effect is equivalent to dynamic
       initialisation by a call to _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) with
       parameter _a_t_t_r specified as NULL, except that no error
       checks are performed.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___c_o_n_d___d_e_s_t_r_o_y_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.  The
       [EBUSY] and [EINVAL] error checks, if implemented, act as
       if they were performed immediately at the beginning of
       processing for the function and caused an error return
       prior to modifying the state of the condition variable
       specified by _c_o_n_d.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) function will fail if:

       [EAGAIN]
           The system lacked the necessary resources (other than
           memory) to initialise another condition variable.

       [ENOMEM]
           Insufficient memory exists to initialise the condition
           variable.

       The _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to re-
           initialise the object referenced by _c_o_n_d, a previously
           initialised, but not yet destroyed, condition
           variable.




08-Jun-2006               GNU Pth 2.0.7                        34





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___c_o_n_d___d_e_s_t_r_o_y_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to destroy
           the object referenced by _c_o_n_d while it is referenced
           (for example, while being used in a
           _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)) by
           another thread.

       [EINVAL]
           The value specified by _c_o_n_d is invalid.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_), _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccoonndd__iinniitt,, pptthhrreeaadd__ccoonndd__ddeessttrrooyy - initialise and
       destroy condition variables

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_cond_init(pthread_cond_t *_c_o_n_d, const
       pthread_condattr_t *_a_t_t_r); int
       pthread_cond_destroy(pthread_cond_t *_c_o_n_d); pthread_cond_t
       _c_o_n_d = PTHREAD_COND_INITIALIZER;

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) initialises the condition
       variable referenced by _c_o_n_d with attributes referenced by
       _a_t_t_r.  If _a_t_t_r is NULL, the default condition variable
       attributes are used; the effect is the same as passing the
       address of a default condition variable attributes object.
       Upon successful initialisation, the state of the condition
       variable becomes initialised.

       Attempting to initialise an already initialised condition



08-Jun-2006               GNU Pth 2.0.7                        35





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       variable results in undefined behaviour.

       The function _p_t_h_r_e_a_d___c_o_n_d___d_e_s_t_r_o_y_(_) destroys the given
       condition variable specified by _c_o_n_d; the object becomes,
       in effect, uninitialised.  An implementation may cause
       _p_t_h_r_e_a_d___c_o_n_d___d_e_s_t_r_o_y_(_) to set the object referenced by
       _c_o_n_d to an invalid value.  A destroyed condition variable
       object can be re-initialised using _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_);
       the results of otherwise referencing the object after it
       has been destroyed are undefined.

       It is safe to destroy an initialised condition variable
       upon which no threads are currently blocked.  Attempting
       to destroy a condition variable upon which other threads
       are currently blocked results in undefined behaviour.

       In cases where default condition variable attributes are
       appropriate, the macro PTHREAD_COND_INITIALIZER can be
       used to initialise condition variables that are statically
       allocated.  The effect is equivalent to dynamic
       initialisation by a call to _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) with
       parameter _a_t_t_r specified as NULL, except that no error
       checks are performed.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___c_o_n_d___d_e_s_t_r_o_y_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.  The
       [EBUSY] and [EINVAL] error checks, if implemented, act as
       if they were performed immediately at the beginning of
       processing for the function and caused an error return
       prior to modifying the state of the condition variable
       specified by _c_o_n_d.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) function will fail if:

       [EAGAIN]
           The system lacked the necessary resources (other than
           memory) to initialise another condition variable.

       [ENOMEM]
           Insufficient memory exists to initialise the condition
           variable.

       The _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to re-
           initialise the object referenced by _c_o_n_d, a previously
           initialised, but not yet destroyed, condition
           variable.





08-Jun-2006               GNU Pth 2.0.7                        36





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___c_o_n_d___d_e_s_t_r_o_y_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to destroy
           the object referenced by _c_o_n_d while it is referenced
           (for example, while being used in a
           _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)) by
           another thread.

       [EINVAL]
           The value specified by _c_o_n_d is invalid.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_), _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccoonndd__ssiiggnnaall,, pptthhrreeaadd__ccoonndd__bbrrooaaddccaasstt - signal or
       broadcast a condition

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_cond_signal(pthread_cond_t *_c_o_n_d); int
       pthread_cond_broadcast(pthread_cond_t *_c_o_n_d);

DDEESSCCRRIIPPTTIIOONN
       These two functions are used to unblock threads blocked on
       a condition variable.

       The _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) call unblocks at least one of
       the threads that are blocked on the specified condition
       variable _c_o_n_d (if any threads are blocked on _c_o_n_d).

       The _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_) call unblocks all threads
       currently blocked on the specified condition variable
       _c_o_n_d.




08-Jun-2006               GNU Pth 2.0.7                        37





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       If more than one thread is blocked on a condition
       variable, the scheduling policy determines the order in
       which threads are unblocked.  When each thread unblocked
       as a result of a _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_) returns from its call to
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_), the
       thread owns the mutex with which it called
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_).  The
       thread(s) that are unblocked contend for the mutex
       according to the scheduling policy (if applicable), and as
       if each had called _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_).

       The _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) or _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_)
       functions may be called by a thread whether or not it
       currently owns the mutex that threads calling
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) have
       associated with the condition variable during their waits;
       however, if predictable scheduling behaviour is required,
       then that mutex is locked by the thread calling
       _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) or _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_).

       The _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) and _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_)
       functions have no effect if there are no threads currently
       blocked on _c_o_n_d.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) and
       _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) and _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_)
       function may fail if:

       [EINVAL]
           The value _c_o_n_d does not refer to an initialised
           condition variable.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_), _<_p_t_h_r_e_a_d_._h>.




08-Jun-2006               GNU Pth 2.0.7                        38





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccoonndd__wwaaiitt,, pptthhrreeaadd__ccoonndd__ttiimmeeddwwaaiitt - wait on a
       condition

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_cond_wait(pthread_cond_t *_c_o_n_d,
       pthread_mutex_t *_m_u_t_e_x); int
       pthread_cond_timedwait(pthread_cond_t *_c_o_n_d,
       pthread_mutex_t *_m_u_t_e_x, const struct timespec *_a_b_s_t_i_m_e);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) and _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)
       functions are used to block on a condition variable.  They
       are called with _m_u_t_e_x locked by the calling thread or
       undefined behaviour will result.

       These functions atomically release _m_u_t_e_x and cause the
       calling thread to block on the condition variable _c_o_n_d;
       atomically here means &quot;atomically with respect to
       access by another thread to the mutex and then the
       condition variable&quot;.  That is, if another thread is
       able to acquire the mutex after the about-to-block thread
       has released it, then a subsequent call to
       _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) or _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_) in that
       thread behaves as if it were issued after the about-to-
       block thread has blocked.

       Upon successful return, the mutex has been locked and is
       owned by the calling thread.

       When using condition variables there is always a boolean
       predicate involving shared variables associated with each
       condition wait that is true if the thread should proceed.
       Spurious wakeups from the _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) functions may occur.  Since the
       return from _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) does not imply anything about the
       value of this predicate, the predicate should be re-
       evaluated upon such return.

       The effect of using more than one mutex for concurrent
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) operations
       on the same condition variable is undefined; that is, a
       condition variable becomes bound to a unique mutex when a
       thread waits on the condition variable, and this (dynamic)
       binding ends when the wait returns.

       A condition wait (whether timed or not) is a cancellation
       point.  When the cancelability enable state of a thread is
       set to PTHREAD_CANCEL_DEFERRED, a side effect of acting
       upon a cancellation request while in a condition wait is



08-Jun-2006               GNU Pth 2.0.7                        39





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       that the mutex is (in effect) re-acquired before calling
       the first cancellation cleanup handler.  The effect is as
       if the thread were unblocked, allowed to execute up to the
       point of returning from the call to _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_), but at that point notices the
       cancellation request and instead of returning to the
       caller of _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_),
       starts the thread cancellation activities, which includes
       calling cancellation cleanup handlers.

       A thread that has been unblocked because it has been
       canceled while blocked in a call to _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) does not consume any condition
       signal that may be directed concurrently at the condition
       variable if there are other threads blocked on the
       condition variable.

       The _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) function is the same as
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) except that an error is returned if
       the absolute time specified by _a_b_s_t_i_m_e passes (that is,
       system time equals or exceeds _a_b_s_t_i_m_e) before the
       condition _c_o_n_d is signaled or broadcasted, or if the
       absolute time specified by _a_b_s_t_i_m_e has already been passed
       at the time of the call.  When such time-outs occur,
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) will nonetheless release and
       reacquire the mutex referenced by _m_u_t_e_x.  The function
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) is also a cancellation point.

       If a signal is delivered to a thread waiting for a
       condition variable, upon return from the signal handler
       the thread resumes waiting for the condition variable as
       if it was not interrupted, or it returns zero due to
       spurious wakeup.

RREETTUURRNN VVAALLUUEE
       Except in the case of [ETIMEDOUT], all these error checks
       act as if they were performed immediately at the beginning
       of processing for the function and cause an error return,
       in effect, prior to modifying the state of the mutex
       specified by _m_u_t_e_x or the condition variable specified by
       _c_o_n_d.

       Upon successful completion, a value of zero is returned.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) function will fail if:

       [ETIMEDOUT]
           The time specified by _a_b_s_t_i_m_e to
           _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) has passed.

       The _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) and _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)



08-Jun-2006               GNU Pth 2.0.7                        40





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       functions may fail if:

       [EINVAL]
           The value specified by _c_o_n_d, _m_u_t_e_x, or _a_b_s_t_i_m_e is
           invalid.

       [EINVAL]
           Different mutexes were supplied for concurrent
           _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)
           operations on the same condition variable.

       [EINVAL]
           The mutex was not owned by the current thread at the
           time of the call.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_), _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccoonndd__wwaaiitt,, pptthhrreeaadd__ccoonndd__ttiimmeeddwwaaiitt - wait on a
       condition

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_cond_wait(pthread_cond_t *_c_o_n_d,
       pthread_mutex_t *_m_u_t_e_x); int
       pthread_cond_timedwait(pthread_cond_t *_c_o_n_d,
       pthread_mutex_t *_m_u_t_e_x, const struct timespec *_a_b_s_t_i_m_e);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) and _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)
       functions are used to block on a condition variable.  They
       are called with _m_u_t_e_x locked by the calling thread or
       undefined behaviour will result.

       These functions atomically release _m_u_t_e_x and cause the
       calling thread to block on the condition variable _c_o_n_d;
       atomically here means &quot;atomically with respect to
       access by another thread to the mutex and then the
       condition variable&quot;.  That is, if another thread is



08-Jun-2006               GNU Pth 2.0.7                        41





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       able to acquire the mutex after the about-to-block thread
       has released it, then a subsequent call to
       _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_) or _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_) in that
       thread behaves as if it were issued after the about-to-
       block thread has blocked.

       Upon successful return, the mutex has been locked and is
       owned by the calling thread.

       When using condition variables there is always a boolean
       predicate involving shared variables associated with each
       condition wait that is true if the thread should proceed.
       Spurious wakeups from the _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) functions may occur.  Since the
       return from _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) does not imply anything about the
       value of this predicate, the predicate should be re-
       evaluated upon such return.

       The effect of using more than one mutex for concurrent
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) operations
       on the same condition variable is undefined; that is, a
       condition variable becomes bound to a unique mutex when a
       thread waits on the condition variable, and this (dynamic)
       binding ends when the wait returns.

       A condition wait (whether timed or not) is a cancellation
       point.  When the cancelability enable state of a thread is
       set to PTHREAD_CANCEL_DEFERRED, a side effect of acting
       upon a cancellation request while in a condition wait is
       that the mutex is (in effect) re-acquired before calling
       the first cancellation cleanup handler.  The effect is as
       if the thread were unblocked, allowed to execute up to the
       point of returning from the call to _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_), but at that point notices the
       cancellation request and instead of returning to the
       caller of _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_),
       starts the thread cancellation activities, which includes
       calling cancellation cleanup handlers.

       A thread that has been unblocked because it has been
       canceled while blocked in a call to _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) does not consume any condition
       signal that may be directed concurrently at the condition
       variable if there are other threads blocked on the
       condition variable.

       The _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) function is the same as
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) except that an error is returned if
       the absolute time specified by _a_b_s_t_i_m_e passes (that is,
       system time equals or exceeds _a_b_s_t_i_m_e) before the
       condition _c_o_n_d is signaled or broadcasted, or if the
       absolute time specified by _a_b_s_t_i_m_e has already been passed
       at the time of the call.  When such time-outs occur,



08-Jun-2006               GNU Pth 2.0.7                        42





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) will nonetheless release and
       reacquire the mutex referenced by _m_u_t_e_x.  The function
       _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) is also a cancellation point.

       If a signal is delivered to a thread waiting for a
       condition variable, upon return from the signal handler
       the thread resumes waiting for the condition variable as
       if it was not interrupted, or it returns zero due to
       spurious wakeup.

RREETTUURRNN VVAALLUUEE
       Except in the case of [ETIMEDOUT], all these error checks
       act as if they were performed immediately at the beginning
       of processing for the function and cause an error return,
       in effect, prior to modifying the state of the mutex
       specified by _m_u_t_e_x or the condition variable specified by
       _c_o_n_d.

       Upon successful completion, a value of zero is returned.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) function will fail if:

       [ETIMEDOUT]
           The time specified by _a_b_s_t_i_m_e to
           _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) has passed.

       The _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) and _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)
       functions may fail if:

       [EINVAL]
           The value specified by _c_o_n_d, _m_u_t_e_x, or _a_b_s_t_i_m_e is
           invalid.

       [EINVAL]
           Different mutexes were supplied for concurrent
           _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)
           operations on the same condition variable.

       [EINVAL]
           The mutex was not owned by the current thread at the
           time of the call.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.





08-Jun-2006               GNU Pth 2.0.7                        43





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d___s_i_g_n_a_l_(_), _p_t_h_r_e_a_d___c_o_n_d___b_r_o_a_d_c_a_s_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccoonnddaattttrr__iinniitt,, pptthhrreeaadd__ccoonnddaattttrr__ddeessttrrooyy -
       initialise and destroy condition variable attributes
       object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_condattr_init(pthread_condattr_t *_a_t_t_r); int
       pthread_condattr_destroy(pthread_condattr_t *_a_t_t_r);

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_) initialises a
       condition variable attributes object _a_t_t_r with the default
       value for all of the attributes defined by the
       implementation.

       Attempting to initialise an already initialised condition
       variable attributes object results in undefined behaviour.

       After a condition variable attributes object has been used
       to initialise one or more condition variables, any
       function affecting the attributes object (including
       destruction) does not affect any previously initialised
       condition variables.

       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___d_e_s_t_r_o_y_(_) function destroys a
       condition variable attributes object; the object becomes,
       in effect, uninitialised.  An implementation may cause
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___d_e_s_t_r_o_y_(_) to set the object referenced by
       _a_t_t_r to an invalid value.  A destroyed condition variable
       attributes object can be re-initialised using
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_); the results of otherwise
       referencing the object after it has been destroyed are
       undefined.

       Additional attributes, their default values, and the names
       of the associated functions to get and set those attribute
       values are implementation-dependent.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___d_e_s_t_r_o_y_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.




08-Jun-2006               GNU Pth 2.0.7                        44





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_) function will fail if:

       [ENOMEM]
           Insufficient memory exists to initialise the condition
           variable attributes object.

       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___d_e_s_t_r_o_y_(_) function may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccoonnddaattttrr__ggeettppsshhaarreedd,, pptthhrreeaadd__ccoonnddaattttrr__sseettppsshhaarreedd -
       get and set the process-shared condition variable
       attributes

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_condattr_getpshared(const pthread_condattr_t
       *_a_t_t_r, int *_p_s_h_a_r_e_d); int
       pthread_condattr_setpshared(pthread_condattr_t *_a_t_t_r, int
       _p_s_h_a_r_e_d);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) function obtains the
       value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute from the attributes
       object referenced by _a_t_t_r.  The
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function is used to set the
       _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute in an initialised attributes
       object referenced by _a_t_t_r.

       The _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is set to
       PTHREAD_PROCESS_SHARED to permit a condition variable to
       be operated upon by any thread that has access to the
       memory where the condition variable is allocated, even if
       the condition variable is allocated in memory that is



08-Jun-2006               GNU Pth 2.0.7                        45





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       shared by multiple processes.  If the _p_r_o_c_e_s_s_-_s_h_a_r_e_d
       attribute is PTHREAD_PROCESS_PRIVATE, the condition
       variable will only be operated upon by threads created
       within the same process as the thread that initialised the
       condition variable; if threads of differing processes
       attempt to operate on such a condition variable, the
       behaviour is undefined.  The default value of the
       attribute is PTHREAD_PROCESS_PRIVATE.

       Additional attributes, their default values, and the names
       of the associated functions to get and set those attribute
       values are implementation-dependent.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       If successful, the _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) function
       returns zero and stores the value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d
       attribute of _a_t_t_r into the object referenced by the
       _p_s_h_a_r_e_d parameter.  Otherwise, an error number is returned
       to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) and
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function may fail if:

       [EINVAL]
           The new value specified for the attribute is outside
           the range of legal values for that attribute.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________




08-Jun-2006               GNU Pth 2.0.7                        46





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


NNAAMMEE
       pptthhrreeaadd__ccoonnddaattttrr__iinniitt,, pptthhrreeaadd__ccoonnddaattttrr__ddeessttrrooyy -
       initialise and destroy condition variable attributes
       object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_condattr_init(pthread_condattr_t *_a_t_t_r); int
       pthread_condattr_destroy(pthread_condattr_t *_a_t_t_r);

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_) initialises a
       condition variable attributes object _a_t_t_r with the default
       value for all of the attributes defined by the
       implementation.

       Attempting to initialise an already initialised condition
       variable attributes object results in undefined behaviour.

       After a condition variable attributes object has been used
       to initialise one or more condition variables, any
       function affecting the attributes object (including
       destruction) does not affect any previously initialised
       condition variables.

       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___d_e_s_t_r_o_y_(_) function destroys a
       condition variable attributes object; the object becomes,
       in effect, uninitialised.  An implementation may cause
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___d_e_s_t_r_o_y_(_) to set the object referenced by
       _a_t_t_r to an invalid value.  A destroyed condition variable
       attributes object can be re-initialised using
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_); the results of otherwise
       referencing the object after it has been destroyed are
       undefined.

       Additional attributes, their default values, and the names
       of the associated functions to get and set those attribute
       values are implementation-dependent.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___d_e_s_t_r_o_y_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_) function will fail if:

       [ENOMEM]
           Insufficient memory exists to initialise the condition
           variable attributes object.

       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___d_e_s_t_r_o_y_(_) function may fail if:



08-Jun-2006               GNU Pth 2.0.7                        47





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccoonnddaattttrr__ggeettppsshhaarreedd,, pptthhrreeaadd__ccoonnddaattttrr__sseettppsshhaarreedd -
       get and set the process-shared condition variable
       attributes

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_condattr_getpshared(const pthread_condattr_t
       *_a_t_t_r, int *_p_s_h_a_r_e_d); int
       pthread_condattr_setpshared(pthread_condattr_t *_a_t_t_r, int
       _p_s_h_a_r_e_d);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) function obtains the
       value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute from the attributes
       object referenced by _a_t_t_r.  The
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function is used to set the
       _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute in an initialised attributes
       object referenced by _a_t_t_r.

       The _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is set to
       PTHREAD_PROCESS_SHARED to permit a condition variable to
       be operated upon by any thread that has access to the
       memory where the condition variable is allocated, even if
       the condition variable is allocated in memory that is
       shared by multiple processes.  If the _p_r_o_c_e_s_s_-_s_h_a_r_e_d
       attribute is PTHREAD_PROCESS_PRIVATE, the condition
       variable will only be operated upon by threads created
       within the same process as the thread that initialised the
       condition variable; if threads of differing processes
       attempt to operate on such a condition variable, the
       behaviour is undefined.  The default value of the
       attribute is PTHREAD_PROCESS_PRIVATE.




08-Jun-2006               GNU Pth 2.0.7                        48





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       Additional attributes, their default values, and the names
       of the associated functions to get and set those attribute
       values are implementation-dependent.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       If successful, the _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) function
       returns zero and stores the value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d
       attribute of _a_t_t_r into the object referenced by the
       _p_s_h_a_r_e_d parameter.  Otherwise, an error number is returned
       to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) and
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function may fail if:

       [EINVAL]
           The new value specified for the attribute is outside
           the range of legal values for that attribute.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d_a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___c_r_e_a_t_e_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ccrreeaattee - thread creation

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_create(pthread_t *_t_h_r_e_a_d, const pthread_attr_t
       *_a_t_t_r, void *(*_s_t_a_r_t___r_o_u_t_i_n_e)(void*), void *_a_r_g);





08-Jun-2006               GNU Pth 2.0.7                        49





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___c_r_e_a_t_e_(_) function is used to create a new
       thread, with attributes specified by _a_t_t_r, within a
       process.  If _a_t_t_r is NULL, the default attributes are
       used.  If the attributes specified by _a_t_t_r are modified
       later, the thread's attributes are not affected.  Upon
       successful completion, _p_t_h_r_e_a_d___c_r_e_a_t_e_(_) stores the ID of
       the created thread in the location referenced by _t_h_r_e_a_d.

       The thread is created executing _s_t_a_r_t___r_o_u_t_i_n_e with _a_r_g as
       its sole argument.  If the _s_t_a_r_t___r_o_u_t_i_n_e returns, the
       effect is as if there was an implicit call to
       _p_t_h_r_e_a_d___e_x_i_t_(_) using the return value of _s_t_a_r_t___r_o_u_t_i_n_e as
       the exit status.  Note that the thread in which _m_a_i_n_(_) was
       originally invoked differs from this.  When it returns
       from _m_a_i_n_(_), the effect is as if there was an implicit
       call to _e_x_i_t_(_) using the return value of _m_a_i_n_(_) as the
       exit status.

       The signal state of the new thread is initialised as
       follows:

       o   The signal mask is inherited from the creating thread.

       o   The set of signals pending for the new thread is
           empty.

       If _p_t_h_r_e_a_d___c_r_e_a_t_e_(_) fails, no new thread is created and
       the contents of the location referenced by _t_h_r_e_a_d are
       undefined.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___c_r_e_a_t_e_(_) function returns zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___c_r_e_a_t_e_(_) function will fail if:

       [EAGAIN]
           The system lacked the necessary resources to create
           another thread, or the system-imposed limit on the
           total number of threads in a process
           PTHREAD_THREADS_MAX would be exceeded.

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       [EPERM]
           The caller does not have appropriate permission to set
           the required scheduling parameters or scheduling
           policy.

       The _p_t_h_r_e_a_d___c_r_e_a_t_e_(_) function will not return an error



08-Jun-2006               GNU Pth 2.0.7                        50





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___e_x_i_t_(_), _p_t_h_r_e_a_d___j_o_i_n_(_), _f_o_r_k_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ddeettaacchh - detach a thread

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_detach(pthread_t _t_h_r_e_a_d);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___d_e_t_a_c_h_(_) function is used to indicate to the
       implementation that storage for the thread _t_h_r_e_a_d can be
       reclaimed when that thread terminates.  If _t_h_r_e_a_d has not
       terminated, _p_t_h_r_e_a_d___d_e_t_a_c_h_(_) will not cause it to
       terminate.  The effect of multiple _p_t_h_r_e_a_d___d_e_t_a_c_h_(_) calls
       on the same target thread is unspecified.

RREETTUURRNN VVAALLUUEE
       If the call succeeds, _p_t_h_r_e_a_d___d_e_t_a_c_h_(_) returns 0.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___d_e_t_a_c_h_(_) function will fail if:

       [EINVAL]
           The implementation has detected that the value
           specified by _t_h_r_e_a_d does not refer to a joinable
           thread.

       [ESRCH]
           No thread could be found corresponding to that
           specified by the given thread ID.

       The _p_t_h_r_e_a_d___d_e_t_a_c_h_(_) function will not return an error
       code of [EINTR].

EEXXAAMMPPLLEESS
       None.




08-Jun-2006               GNU Pth 2.0.7                        51





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___j_o_i_n_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__eeqquuaall - compare thread IDs

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_equal(pthread_t _t_1, pthread_t _t_2);

DDEESSCCRRIIPPTTIIOONN
       This function compares the thread IDs _t_1 and _t_2.

RREETTUURRNN VVAALLUUEE
       The _p_t_h_r_e_a_d___e_q_u_a_l_(_) function returns a non-zero value if
       _t_1 and _t_2 are equal; otherwise, zero is returned.

       If either _t_1 or _t_2 are not valid thread IDs, the behaviour
       is undefined.

EERRRROORRSS
       No errors are defined.

       The _p_t_h_r_e_a_d___e_q_u_a_l_(_) function will not return an error code
       of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___s_e_l_f_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__eexxiitt - thread termination

SSYYNNOOPPSSIISS
       #include <pthread.h>

       void pthread_exit(void *_v_a_l_u_e___p_t_r);



08-Jun-2006               GNU Pth 2.0.7                        52





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___e_x_i_t_(_) function terminates the calling thread
       and makes the value _v_a_l_u_e___p_t_r available to any successful
       join with the terminating thread.  Any cancellation
       cleanup handlers that have been pushed and not yet popped
       are popped in the reverse order that they were pushed and
       then executed.  After all cancellation cleanup handlers
       have been executed, if the thread has any thread-specific
       data, appropriate destructor functions will be called in
       an unspecified order.  Thread termination does not release
       any application visible process resources, including, but
       not limited to, mutexes and file descriptors, nor does it
       perform any process level cleanup actions, including, but
       not limited to, calling any _a_t_e_x_i_t_(_) routines that may
       exist.

       An implicit call to _p_t_h_r_e_a_d___e_x_i_t_(_) is made when a thread
       other than the thread in which _m_a_i_n_(_) was first invoked
       returns from the start routine that was used to create it.
       The function's return value serves as the thread's exit
       status.

       The behaviour of _p_t_h_r_e_a_d___e_x_i_t_(_) is undefined if called
       from a cancellation cleanup handler or destructor function
       that was invoked as a result of either an implicit or
       explicit call to _p_t_h_r_e_a_d___e_x_i_t_(_).

       After a thread has terminated, the result of access to
       local (auto) variables of the thread is undefined.  Thus,
       references to local variables of the exiting thread should
       not be used for the _p_t_h_r_e_a_d___e_x_i_t_(_) _v_a_l_u_e___p_t_r parameter
       value.

       The process exits with an exit status of 0 after the last
       thread has been terminated.  The behaviour is as if the
       implementation called _e_x_i_t_(_) with a zero argument at
       thread termination time.

RREETTUURRNN VVAALLUUEE
       The _p_t_h_r_e_a_d___e_x_i_t_(_) function cannot return to its caller.

EERRRROORRSS
       No errors are defined.

       The _p_t_h_r_e_a_d___e_x_i_t_(_) function will not return an error code
       of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.





08-Jun-2006               GNU Pth 2.0.7                        53





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___j_o_i_n_(_), _e_x_i_t_(_), ___e_x_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ggeettccoonnccuurrrreennccyy,, pptthhrreeaadd__sseettccoonnccuurrrreennccyy - get or
       set level of concurrency

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_getconcurrency(void); int
       pthread_setconcurrency(int _n_e_w___l_e_v_e_l);

DDEESSCCRRIIPPTTIIOONN
       Unbound threads in a process may or may not be required to
       be simultaneously active. By default, the threads
       implementation ensures that a sufficient number of threads
       are active so that the process can continue to make
       progress. While this conserves system resources, it may
       not produce the most effective level of concurrency.

       The _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) function allows an
       application to inform the threads implementation of its
       desired concurrency level, _n_e_w___l_e_v_e_l.  The actual level of
       concurrency provided by the implementation as a result of
       this function call is unspecified.

       If _n_e_w___l_e_v_e_l is zero, it causes the implementation to
       maintain the concurrency level at its discretion as if
       _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) was never called.

       The _p_t_h_r_e_a_d___g_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) function returns the value
       set by a previous call to the _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_)
       function.  If the _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) function was
       not previously called, this function returns zero to
       indicate that the implementation is maintaining the
       concurrency level.

       When an application calls _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) it is
       informing the implementation of its desired concurrency
       level. The implementation uses this as a hint, not a
       requirement.

       If an implementation does not support multiplexing of user
       threads on top of several kernel scheduled entities, the
       _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) and _p_t_h_r_e_a_d___g_e_t_c_o_n_c_u_r_r_e_n_c_y_(_)
       functions will be provided for source code compatibility
       but they will have no effect when called. To maintain the
       function semantics, the _n_e_w___l_e_v_e_l parameter will be saved



08-Jun-2006               GNU Pth 2.0.7                        54





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       when _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) is called so that a
       subsequent call to _p_t_h_r_e_a_d___g_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) returns the
       same value.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       The _p_t_h_r_e_a_d___g_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) function always returns the
       concurrency level set by a previous call to
       _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_).  If the _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_)
       function has never been called, _p_t_h_r_e_a_d___g_e_t_c_o_n_c_u_r_r_e_n_c_y_(_)
       returns zero.

EERRRROORRSS
       The _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) function will fail if:

       [EINVAL]
           The value specified by _n_e_w___l_e_v_e_l is negative.

       [EAGAIN]
           The value specific by _n_e_w___l_e_v_e_l would cause a system
           resource to be exceeded.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Use of these functions changes the state of the underlying
       concurrency upon which the application depends. Library
       developers are advised to not use the
       _p_t_h_r_e_a_d___g_e_t_c_o_n_c_u_r_r_e_n_c_y_(_) and _p_t_h_r_e_a_d___s_e_t_c_o_n_c_u_r_r_e_n_c_y_(_)
       functions since their use may conflict with an
       applications use of these functions.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ggeettsscchheeddppaarraamm,, pptthhrreeaadd__sseettsscchheeddppaarraamm - dynamic
       thread scheduling parameters access (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_getschedparam(pthread_t _t_h_r_e_a_d, int *_p_o_l_i_c_y,
       struct sched_param *_p_a_r_a_m); int
       pthread_setschedparam(pthread_t _t_h_r_e_a_d, int _p_o_l_i_c_y, const
       struct sched_param *_p_a_r_a_m);



08-Jun-2006               GNU Pth 2.0.7                        55





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) and _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_)
       allow the scheduling policy and scheduling parameters of
       individual threads within a multi-threaded process to be
       retrieved and set.  For SCHED_FIFO and SCHED_RR, the only
       required member of the sscchheedd__ppaarraamm structure is the
       priority _s_c_h_e_d___p_r_i_o_r_i_t_y.  For SCHED_OTHER, the affected
       scheduling parameters are implementation-dependent.

       The _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) function retrieves the
       scheduling policy and scheduling parameters for the thread
       whose thread ID is given by _t_h_r_e_a_d and stores those values
       in _p_o_l_i_c_y and _p_a_r_a_m, respectively.  The priority value
       returned from _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) is the value
       specified by the most recent _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) or
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_) call affecting the target thread, and
       reflects any temporary adjustments to its priority as a
       result of any priority inheritance or ceiling functions.
       The _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) function sets the scheduling
       policy and associated scheduling parameters for the thread
       whose thread ID is given by _t_h_r_e_a_d to the policy and
       associated parameters provided in _p_o_l_i_c_y and _p_a_r_a_m,
       respectively.

       The _p_o_l_i_c_y parameter may have the value SCHED_OTHER, that
       has implementation-dependent scheduling parameters,
       SCHED_FIFO or SCHED_RR, that have the single scheduling
       parameter, _p_r_i_o_r_i_t_y_.

       If the _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) function fails, no
       scheduling parameters will be changed for the target
       thread.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) and
       _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) and _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_)
       functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIORITY_SCHEDULING is not
           defined and the implementation does not support the
           function.

       The _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) function may fail if:

       [ESRCH]
           The value specified by _t_h_r_e_a_d does not refer to a
           existing thread.

       The _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) function may fail if:



08-Jun-2006               GNU Pth 2.0.7                        56





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EINVAL]
           The value specified by _p_o_l_i_c_y or one of the scheduling
           parameters associated with the scheduling policy
           _p_o_l_i_c_y is invalid.

       [ENOTSUP]
           An attempt was made to set the policy or scheduling
           parameters to an unsupported value.

       [EPERM]
           The caller does not have the appropriate permission to
           set either the scheduling parameters or the scheduling
           policy of the specified thread.

       [EPERM]
           The implementation does not allow the application to
           modify one of the parameters to the value specified.

       [ESRCH]
           The value specified by _t_h_r_e_a_d does not refer to a
           existing thread.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _s_c_h_e_d___s_e_t_p_a_r_a_m_(_), _s_c_h_e_d___g_e_t_p_a_r_a_m_(_), _s_c_h_e_d___s_e_t_s_c_h_e_d_u_l_e_r_(_),
       _s_c_h_e_d___g_e_t_s_c_h_e_d_u_l_e_r_(_), _<_p_t_h_r_e_a_d_._h>, _<_s_c_h_e_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__sseettssppeecciiffiicc,, pptthhrreeaadd__ggeettssppeecciiffiicc - thread-specific
       data management

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_setspecific(pthread_key_t _k_e_y, const void
       *_v_a_l_u_e); void *pthread_getspecific(pthread_key_t _k_e_y);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) function associates a thread-
       specific _v_a_l_u_e with a _k_e_y obtained via a previous call to
       _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_).  Different threads may bind
       different values to the same key.  These values are
       typically pointers to blocks of dynamically allocated
       memory that have been reserved for use by the calling
       thread.



08-Jun-2006               GNU Pth 2.0.7                        57





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       The _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_) function returns the value
       currently bound to the specified _k_e_y on behalf of the
       calling thread.

       The effect of calling _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) or
       _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_) with a _k_e_y value not obtained from
       _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_) or after _k_e_y has been deleted with
       _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_) is undefined.

       Both _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) and _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_) may
       be called from a thread-specific data destructor function.
       However, calling _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) from a destructor
       may result in lost storage or infinite loops.

       Both functions may be implemented as macros.

RREETTUURRNN VVAALLUUEE
       The function _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_) returns the thread-
       specific data value associated with the given _k_e_y.  If no
       thread-specific data value is associated with _k_e_y, then
       the value NULL is returned.

       If successful, the _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) function returns
       zero.  Otherwise, an error number is returned to indicate
       the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) function will fail if:

       [ENOMEM]
           Insufficient memory exists to associate the value with
           the key.

       The _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) function may fail if:

       [EINVAL]
           The key value is invalid.

       No errors are returned from _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_).

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_), _<_p_t_h_r_e_a_d_._h>.




08-Jun-2006               GNU Pth 2.0.7                        58





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__jjooiinn - wait for thread termination

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_join(pthread_t _t_h_r_e_a_d, void **_v_a_l_u_e___p_t_r);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___j_o_i_n_(_) function suspends execution of the
       calling thread until the target _t_h_r_e_a_d terminates, unless
       the target _t_h_r_e_a_d has already terminated.  On return from
       a successful _p_t_h_r_e_a_d___j_o_i_n_(_) call with a non-NULL _v_a_l_u_e___p_t_r
       argument, the value passed to _p_t_h_r_e_a_d___e_x_i_t_(_) by the
       terminating thread is made available in the location
       referenced by _v_a_l_u_e___p_t_r.  When a _p_t_h_r_e_a_d___j_o_i_n_(_) returns
       successfully, the target thread has been terminated.  The
       results of multiple simultaneous calls to _p_t_h_r_e_a_d___j_o_i_n_(_)
       specifying the same target thread are undefined.  If the
       thread calling _p_t_h_r_e_a_d___j_o_i_n_(_) is canceled, then the target
       thread will not be detached.

       It is unspecified whether a thread that has exited but
       remains unjoined counts against _POSIX_THREAD_THREADS_MAX.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___j_o_i_n_(_) function returns zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___j_o_i_n_(_) function will fail if:

       [EINVAL]
           The implementation has detected that the value
           specified by _t_h_r_e_a_d does not refer to a joinable
           thread.

       [ESRCH]
           No thread could be found corresponding to that
           specified by the given thread ID.

       The _p_t_h_r_e_a_d___j_o_i_n_(_) function may fail if:

       [EDEADLK]
           A deadlock was detected or the value of _t_h_r_e_a_d
           specifies the calling thread.

       The _p_t_h_r_e_a_d___j_o_i_n_(_) function will not return an error code
       of [EINTR].

EEXXAAMMPPLLEESS
       None.



08-Jun-2006               GNU Pth 2.0.7                        59





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _w_a_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__kkeeyy__ccrreeaattee - thread-specific data key creation

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_key_create(pthread_key_t *_k_e_y, void
       (*_d_e_s_t_r_u_c_t_o_r)(void*));

DDEESSCCRRIIPPTTIIOONN
       This function creates a thread-specific data key visible
       to all threads in the process.  Key values provided by
       _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_) are opaque objects used to locate
       thread-specific data.  Although the same key value may be
       used by different threads, the values bound to the key by
       _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) are maintained on a per-thread basis
       and persist for the life of the calling thread.

       Upon key creation, the value NULL is associated with the
       new key in all active threads.  Upon thread creation, the
       value NULL is associated with all defined keys in the new
       thread.

       An optional destructor function may be associated with
       each key value.  At thread exit, if a key value has a non-
       NULL destructor pointer, and the thread has a non-NULL
       value associated with that key, the function pointed to is
       called with the current associated value as its sole
       argument.  The order of destructor calls is unspecified if
       more than one destructor exists for a thread when it
       exits.

       If, after all the destructors have been called for all
       non-NULL values with associated destructors, there are
       still some non-NULL values with associated destructors,
       then the process will be repeated.  If, after at least
       PTHREAD_DESTRUCTOR_ITERATIONS iterations of destructor
       calls for outstanding non-NULL values, there are still
       some non-NULL values with associated destructors,
       implementations may stop calling destructors, or they may
       continue calling destructors until no non-NULL values with
       associated destructors exist, even though this might
       result in an infinite loop.




08-Jun-2006               GNU Pth 2.0.7                        60





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_) function stores
       the newly created key value at _*_k_e_y and returns zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_) function will fail if:

       [EAGAIN]
           The system lacked the necessary resources to create
           another thread-specific data key, or the system-
           imposed limit on the total number of keys per process
           PTHREAD_KEYS_MAX has been exceeded.

       [ENOMEM]
           Insufficient memory exists to create the key.

       The _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_) function will not return an error
       code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_), _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_),
       _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__kkeeyy__ddeelleettee - thread-specific data key deletion

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_key_delete(pthread_key_t _k_e_y);

DDEESSCCRRIIPPTTIIOONN
       This function deletes a thread-specific data key
       previously returned by _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_).  The thread-
       specific data values associated with _k_e_y need not be NULL
       at the time _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_) is called.  It is the
       responsibility of the application to free any application
       storage or perform any cleanup actions for data structures
       related to the deleted key or associated thread-specific
       data in any threads; this cleanup can be done either
       before or after _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_) is called.  Any
       attempt to use _k_e_y following the call to



08-Jun-2006               GNU Pth 2.0.7                        61





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_) results in undefined behaviour.

       The _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_) function is callable from within
       destructor functions.  No destructor functions will be
       invoked by _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_).  Any destructor function
       that may have been associated with _k_e_y will no longer be
       called upon thread exit.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_) function returns
       zero.  Otherwise, an error number is returned to indicate
       the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_) function may fail if:

       [EINVAL]
           The _k_e_y value is invalid.

       The _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_) function will not return an error
       code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__kkiillll - send a signal to a thread

SSYYNNOOPPSSIISS
       #include <signal.h>

       int pthread_kill(pthread_t _t_h_r_e_a_d, int _s_i_g);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___k_i_l_l_(_) function is used to request that a
       signal be delivered to the specified thread.

       As in _k_i_l_l_(_), if _s_i_g is zero, error checking is performed
       but no signal is actually sent.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, the function returns a value
       of zero.  Otherwise the function returns an error number.
       If the _p_t_h_r_e_a_d___k_i_l_l_(_) function fails, no signal is sent.



08-Jun-2006               GNU Pth 2.0.7                        62





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


EERRRROORRSS
       The _p_t_h_r_e_a_d___k_i_l_l_(_) function will fail if:

       [ESRCH]
           No thread could be found corresponding to that
           specified by the given thread ID.

       [EINVAL]
           The value of the _s_i_g argument is an invalid or
           unsupported signal number.

       The _p_t_h_r_e_a_d___k_i_l_l_(_) function will not return an error code
       of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _k_i_l_l_(_), _p_t_h_r_e_a_d___s_e_l_f_(_), _r_a_i_s_e_(_), _<_s_i_g_n_a_l_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexx__iinniitt,, pptthhrreeaadd__mmuutteexx__ddeessttrrooyy - initialise or
       destroy a mutex

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutex_init(pthread_mutex_t *_m_u_t_e_x, const
       pthread_mutexattr_t *_a_t_t_r); int
       pthread_mutex_destroy(pthread_mutex_t *_m_u_t_e_x);
       pthread_mutex_t _m_u_t_e_x = PTHREAD_MUTEX_INITIALIZER;

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) function initialises the mutex
       referenced by _m_u_t_e_x with attributes specified by _a_t_t_r.  If
       _a_t_t_r is NULL, the default mutex attributes are used; the
       effect is the same as passing the address of a default
       mutex attributes object.  Upon successful initialisation,
       the state of the mutex becomes initialised and unlocked.

       Attempting to initialise an already initialised mutex
       results in undefined behaviour.

       The _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_) function destroys the mutex
       object referenced by _m_u_t_e_x; the mutex object becomes, in
       effect, uninitialised.  An implementation may cause
       _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_) to set the object referenced by



08-Jun-2006               GNU Pth 2.0.7                        63





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _m_u_t_e_x to an invalid value.  A destroyed mutex object can
       be re-initialised using _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_); the results
       of otherwise referencing the object after it has been
       destroyed are undefined.

       It is safe to destroy an initialised mutex that is
       unlocked.  Attempting to destroy a locked mutex results in
       undefined behaviour.

       In cases where default mutex attributes are appropriate,
       the macro PTHREAD_MUTEX_INITIALIZER can be used to
       initialise mutexes that are statically allocated.  The
       effect is equivalent to dynamic initialisation by a call
       to _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) with parameter _a_t_t_r specified as
       NULL, except that no error checks are performed.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.  The
       [EBUSY] and [EINVAL] error checks, if implemented, act as
       if they were performed immediately at the beginning of
       processing for the function and cause an error return
       prior to modifying the state of the mutex specified by
       _m_u_t_e_x.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) function will fail if:

       [EAGAIN]
           The system lacked the necessary resources (other than
           memory) to initialise another mutex.

       [ENOMEM]
           Insufficient memory exists to initialise the mutex.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

       The _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to re-
           initialise the object referenced by _m_u_t_e_x, a
           previously initialised, but not yet destroyed, mutex.

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to destroy



08-Jun-2006               GNU Pth 2.0.7                        64





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


           the object referenced by _m_u_t_e_x while it is locked or
           referenced (for example, while being used in a
           _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)) by
           another thread.

       [EINVAL]
           The value specified by _m_u_t_e_x is invalid.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_), _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexx__sseettpprriioocceeiilliinngg,, pptthhrreeaadd__mmuutteexx__ggeettpprriioocceeiilliinngg
       - change the priority ceiling of a mutex (RREEAALLTTIIMMEE
       TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutex_setprioceiling(pthread_mutex_t *_m_u_t_e_x,
       int _p_r_i_o_c_e_i_l_i_n_g, int *_o_l_d___c_e_i_l_i_n_g);

       int pthread_mutex_getprioceiling(const pthread_mutex_t
       *_m_u_t_e_x, int *_p_r_i_o_c_e_i_l_i_n_g);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) function returns the
       current priority ceiling of the mutex.

       The _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) function either locks
       the mutex if it is unlocked, or blocks until it can
       successfully lock the mutex, then it changes the mutex's
       priority ceiling and releases the mutex.  When the change
       is successful, the previous value of the priority ceiling
       is returned in _o_l_d___c_e_i_l_i_n_g.  The process of locking the
       mutex need not adhere to the priority protect protocol.

       If the _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) function fails, the
       mutex priority ceiling is not changed.



08-Jun-2006               GNU Pth 2.0.7                        65





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIO_PROTECT is not defined
           and the implementation does not support the function.

       The _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions may fail if:

       [EINVAL]
           The priority requested by _p_r_i_o_c_e_i_l_i_n_g is out of range.

       [EINVAL]
           The value specified by _m_u_t_e_x does not refer to a
           currently existing mutex.

       [ENOSYS]
           The implementation does not support the priority
           ceiling protocol for mutexes.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_), _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexx__iinniitt,, pptthhrreeaadd__mmuutteexx__ddeessttrrooyy - initialise or
       destroy a mutex

SSYYNNOOPPSSIISS
       #include <pthread.h>




08-Jun-2006               GNU Pth 2.0.7                        66





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       int pthread_mutex_init(pthread_mutex_t *_m_u_t_e_x, const
       pthread_mutexattr_t *_a_t_t_r); int
       pthread_mutex_destroy(pthread_mutex_t *_m_u_t_e_x);
       pthread_mutex_t _m_u_t_e_x = PTHREAD_MUTEX_INITIALIZER;

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) function initialises the mutex
       referenced by _m_u_t_e_x with attributes specified by _a_t_t_r.  If
       _a_t_t_r is NULL, the default mutex attributes are used; the
       effect is the same as passing the address of a default
       mutex attributes object.  Upon successful initialisation,
       the state of the mutex becomes initialised and unlocked.

       Attempting to initialise an already initialised mutex
       results in undefined behaviour.

       The _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_) function destroys the mutex
       object referenced by _m_u_t_e_x; the mutex object becomes, in
       effect, uninitialised.  An implementation may cause
       _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_) to set the object referenced by
       _m_u_t_e_x to an invalid value.  A destroyed mutex object can
       be re-initialised using _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_); the results
       of otherwise referencing the object after it has been
       destroyed are undefined.

       It is safe to destroy an initialised mutex that is
       unlocked.  Attempting to destroy a locked mutex results in
       undefined behaviour.

       In cases where default mutex attributes are appropriate,
       the macro PTHREAD_MUTEX_INITIALIZER can be used to
       initialise mutexes that are statically allocated.  The
       effect is equivalent to dynamic initialisation by a call
       to _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) with parameter _a_t_t_r specified as
       NULL, except that no error checks are performed.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.  The
       [EBUSY] and [EINVAL] error checks, if implemented, act as
       if they were performed immediately at the beginning of
       processing for the function and cause an error return
       prior to modifying the state of the mutex specified by
       _m_u_t_e_x.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) function will fail if:

       [EAGAIN]
           The system lacked the necessary resources (other than
           memory) to initialise another mutex.





08-Jun-2006               GNU Pth 2.0.7                        67





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [ENOMEM]
           Insufficient memory exists to initialise the mutex.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

       The _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to re-
           initialise the object referenced by _m_u_t_e_x, a
           previously initialised, but not yet destroyed, mutex.

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to destroy
           the object referenced by _m_u_t_e_x while it is locked or
           referenced (for example, while being used in a
           _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_)) by
           another thread.

       [EINVAL]
           The value specified by _m_u_t_e_x is invalid.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_), _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexx__lloocckk,, pptthhrreeaadd__mmuutteexx__ttrryylloocckk,,
       pptthhrreeaadd__mmuutteexx__uunnlloocckk - lock and unlock a mutex

SSYYNNOOPPSSIISS
       #include <pthread.h>




08-Jun-2006               GNU Pth 2.0.7                        68





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       int pthread_mutex_lock(pthread_mutex_t *_m_u_t_e_x); int
       pthread_mutex_trylock(pthread_mutex_t *_m_u_t_e_x); int
       pthread_mutex_unlock(pthread_mutex_t *_m_u_t_e_x);

DDEESSCCRRIIPPTTIIOONN
       The mutex object referenced by _m_u_t_e_x is locked by calling
       _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_).  If the mutex is already locked, the
       calling thread blocks until the mutex becomes available.
       This operation returns with the mutex object referenced by
       _m_u_t_e_x in the locked state with the calling thread as its
       owner.

       If the mutex type is PTHREAD_MUTEX_NORMAL, deadlock
       detection is not provided. Attempting to relock the mutex
       causes deadlock. If a thread attempts to unlock a mutex
       that it has not locked or a mutex which is unlocked,
       undefined behaviour results.

       If the mutex type is PTHREAD_MUTEX_ERRORCHECK, then error
       checking is provided.  If a thread attempts to relock a
       mutex that it has already locked, an error will be
       returned. If a thread attempts to unlock a mutex that it
       has not locked or a mutex which is unlocked, an error will
       be returned.

       If the mutex type is PTHREAD_MUTEX_RECURSIVE, then the
       mutex maintains the concept of a lock count.  When a
       thread successfully acquires a mutex for the first time,
       the lock count is set to one. Every time a thread relocks
       this mutex, the lock count is incremented by one. Each
       time the thread unlocks the mutex, the lock count is
       decremented by one.  When the lock count reaches zero, the
       mutex becomes available for other threads to acquire. If a
       thread attempts to unlock a mutex that it has not locked
       or a mutex which is unlocked, an error will be returned.

       If the mutex type is PTHREAD_MUTEX_DEFAULT, attempting to
       recursively lock the mutex results in undefined behaviour.
       Attempting to unlock the mutex if it was not locked by the
       calling thread results in undefined behaviour. Attempting
       to unlock the mutex if it is not locked results in
       undefined behaviour.

       The function _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) is identical to
       _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) except that if the mutex object
       referenced by _m_u_t_e_x is currently locked (by any thread,
       including the current thread), the call returns
       immediately.

       The _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) function releases the mutex
       object referenced by _m_u_t_e_x.  The manner in which a mutex
       is released is dependent upon the mutex's type attribute.
       If there are threads blocked on the mutex object
       referenced by _m_u_t_e_x when _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) is called,



08-Jun-2006               GNU Pth 2.0.7                        69





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       resulting in the mutex becoming available, the scheduling
       policy is used to determine which thread shall acquire the
       mutex.  (In the case of PTHREAD_MUTEX_RECURSIVE mutexes,
       the mutex becomes available when the count reaches zero
       and the calling thread no longer has any locks on this
       mutex).

       If a signal is delivered to a thread waiting for a mutex,
       upon return from the signal handler the thread resumes
       waiting for the mutex as if it was not interrupted.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.

       The function _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) returns zero if a
       lock on the mutex object referenced by _m_u_t_e_x is acquired.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) and _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_)
       functions will fail if:

       [EINVAL]
           The _m_u_t_e_x was created with the protocol attribute
           having the value PTHREAD_PRIO_PROTECT and the calling
           thread's priority is higher than the mutex's current
           priority ceiling.

       The _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) function will fail if:

       [EBUSY]
           The _m_u_t_e_x could not be acquired because it was already
           locked.

       The _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) functions may fail if:

       [EINVAL]
           The value specified by _m_u_t_e_x does not refer to an
           initialised mutex object.

       [EAGAIN]
           The mutex could not be acquired because the maximum
           number of recursive locks for _m_u_t_e_x has been exceeded.

       The _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) function may fail if:

       [EDEADLK]
           The current thread already owns the mutex.

       The _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) function may fail if:



08-Jun-2006               GNU Pth 2.0.7                        70





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EPERM]
           The current thread does not own the mutex.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_), _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexx__sseettpprriioocceeiilliinngg,, pptthhrreeaadd__mmuutteexx__ggeettpprriioocceeiilliinngg
       - change the priority ceiling of a mutex (RREEAALLTTIIMMEE
       TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutex_setprioceiling(pthread_mutex_t *_m_u_t_e_x,
       int _p_r_i_o_c_e_i_l_i_n_g, int *_o_l_d___c_e_i_l_i_n_g);

       int pthread_mutex_getprioceiling(const pthread_mutex_t
       *_m_u_t_e_x, int *_p_r_i_o_c_e_i_l_i_n_g);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) function returns the
       current priority ceiling of the mutex.

       The _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) function either locks
       the mutex if it is unlocked, or blocks until it can
       successfully lock the mutex, then it changes the mutex's
       priority ceiling and releases the mutex.  When the change
       is successful, the previous value of the priority ceiling
       is returned in _o_l_d___c_e_i_l_i_n_g.  The process of locking the
       mutex need not adhere to the priority protect protocol.

       If the _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) function fails, the
       mutex priority ceiling is not changed.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.




08-Jun-2006               GNU Pth 2.0.7                        71





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIO_PROTECT is not defined
           and the implementation does not support the function.

       The _p_t_h_r_e_a_d___m_u_t_e_x___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions may fail if:

       [EINVAL]
           The priority requested by _p_r_i_o_c_e_i_l_i_n_g is out of range.

       [EINVAL]
           The value specified by _m_u_t_e_x does not refer to a
           currently existing mutex.

       [ENOSYS]
           The implementation does not support the priority
           ceiling protocol for mutexes.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_), _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexx__lloocckk,, pptthhrreeaadd__mmuutteexx__ttrryylloocckk,,
       pptthhrreeaadd__mmuutteexx__uunnlloocckk - lock and unlock a mutex

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutex_lock(pthread_mutex_t *_m_u_t_e_x); int
       pthread_mutex_trylock(pthread_mutex_t *_m_u_t_e_x); int
       pthread_mutex_unlock(pthread_mutex_t *_m_u_t_e_x);

DDEESSCCRRIIPPTTIIOONN
       The mutex object referenced by _m_u_t_e_x is locked by calling



08-Jun-2006               GNU Pth 2.0.7                        72





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_).  If the mutex is already locked, the
       calling thread blocks until the mutex becomes available.
       This operation returns with the mutex object referenced by
       _m_u_t_e_x in the locked state with the calling thread as its
       owner.

       If the mutex type is PTHREAD_MUTEX_NORMAL, deadlock
       detection is not provided. Attempting to relock the mutex
       causes deadlock. If a thread attempts to unlock a mutex
       that it has not locked or a mutex which is unlocked,
       undefined behaviour results.

       If the mutex type is PTHREAD_MUTEX_ERRORCHECK, then error
       checking is provided.  If a thread attempts to relock a
       mutex that it has already locked, an error will be
       returned. If a thread attempts to unlock a mutex that it
       has not locked or a mutex which is unlocked, an error will
       be returned.

       If the mutex type is PTHREAD_MUTEX_RECURSIVE, then the
       mutex maintains the concept of a lock count.  When a
       thread successfully acquires a mutex for the first time,
       the lock count is set to one. Every time a thread relocks
       this mutex, the lock count is incremented by one. Each
       time the thread unlocks the mutex, the lock count is
       decremented by one.  When the lock count reaches zero, the
       mutex becomes available for other threads to acquire. If a
       thread attempts to unlock a mutex that it has not locked
       or a mutex which is unlocked, an error will be returned.

       If the mutex type is PTHREAD_MUTEX_DEFAULT, attempting to
       recursively lock the mutex results in undefined behaviour.
       Attempting to unlock the mutex if it was not locked by the
       calling thread results in undefined behaviour. Attempting
       to unlock the mutex if it is not locked results in
       undefined behaviour.

       The function _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) is identical to
       _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) except that if the mutex object
       referenced by _m_u_t_e_x is currently locked (by any thread,
       including the current thread), the call returns
       immediately.

       The _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) function releases the mutex
       object referenced by _m_u_t_e_x.  The manner in which a mutex
       is released is dependent upon the mutex's type attribute.
       If there are threads blocked on the mutex object
       referenced by _m_u_t_e_x when _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) is called,
       resulting in the mutex becoming available, the scheduling
       policy is used to determine which thread shall acquire the
       mutex.  (In the case of PTHREAD_MUTEX_RECURSIVE mutexes,
       the mutex becomes available when the count reaches zero
       and the calling thread no longer has any locks on this
       mutex).



08-Jun-2006               GNU Pth 2.0.7                        73





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       If a signal is delivered to a thread waiting for a mutex,
       upon return from the signal handler the thread resumes
       waiting for the mutex as if it was not interrupted.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.

       The function _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) returns zero if a
       lock on the mutex object referenced by _m_u_t_e_x is acquired.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) and _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_)
       functions will fail if:

       [EINVAL]
           The _m_u_t_e_x was created with the protocol attribute
           having the value PTHREAD_PRIO_PROTECT and the calling
           thread's priority is higher than the mutex's current
           priority ceiling.

       The _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) function will fail if:

       [EBUSY]
           The _m_u_t_e_x could not be acquired because it was already
           locked.

       The _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) functions may fail if:

       [EINVAL]
           The value specified by _m_u_t_e_x does not refer to an
           initialised mutex object.

       [EAGAIN]
           The mutex could not be acquired because the maximum
           number of recursive locks for _m_u_t_e_x has been exceeded.

       The _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) function may fail if:

       [EDEADLK]
           The current thread already owns the mutex.

       The _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) function may fail if:

       [EPERM]
           The current thread does not own the mutex.

       These functions will not return an error code of [EINTR].





08-Jun-2006               GNU Pth 2.0.7                        74





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_), _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexx__lloocckk,, pptthhrreeaadd__mmuutteexx__ttrryylloocckk,,
       pptthhrreeaadd__mmuutteexx__uunnlloocckk - lock and unlock a mutex

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutex_lock(pthread_mutex_t *_m_u_t_e_x); int
       pthread_mutex_trylock(pthread_mutex_t *_m_u_t_e_x); int
       pthread_mutex_unlock(pthread_mutex_t *_m_u_t_e_x);

DDEESSCCRRIIPPTTIIOONN
       The mutex object referenced by _m_u_t_e_x is locked by calling
       _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_).  If the mutex is already locked, the
       calling thread blocks until the mutex becomes available.
       This operation returns with the mutex object referenced by
       _m_u_t_e_x in the locked state with the calling thread as its
       owner.

       If the mutex type is PTHREAD_MUTEX_NORMAL, deadlock
       detection is not provided. Attempting to relock the mutex
       causes deadlock. If a thread attempts to unlock a mutex
       that it has not locked or a mutex which is unlocked,
       undefined behaviour results.

       If the mutex type is PTHREAD_MUTEX_ERRORCHECK, then error
       checking is provided.  If a thread attempts to relock a
       mutex that it has already locked, an error will be
       returned. If a thread attempts to unlock a mutex that it
       has not locked or a mutex which is unlocked, an error will
       be returned.

       If the mutex type is PTHREAD_MUTEX_RECURSIVE, then the
       mutex maintains the concept of a lock count.  When a
       thread successfully acquires a mutex for the first time,
       the lock count is set to one. Every time a thread relocks
       this mutex, the lock count is incremented by one. Each
       time the thread unlocks the mutex, the lock count is
       decremented by one.  When the lock count reaches zero, the
       mutex becomes available for other threads to acquire. If a



08-Jun-2006               GNU Pth 2.0.7                        75





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       thread attempts to unlock a mutex that it has not locked
       or a mutex which is unlocked, an error will be returned.

       If the mutex type is PTHREAD_MUTEX_DEFAULT, attempting to
       recursively lock the mutex results in undefined behaviour.
       Attempting to unlock the mutex if it was not locked by the
       calling thread results in undefined behaviour. Attempting
       to unlock the mutex if it is not locked results in
       undefined behaviour.

       The function _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) is identical to
       _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) except that if the mutex object
       referenced by _m_u_t_e_x is currently locked (by any thread,
       including the current thread), the call returns
       immediately.

       The _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) function releases the mutex
       object referenced by _m_u_t_e_x.  The manner in which a mutex
       is released is dependent upon the mutex's type attribute.
       If there are threads blocked on the mutex object
       referenced by _m_u_t_e_x when _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) is called,
       resulting in the mutex becoming available, the scheduling
       policy is used to determine which thread shall acquire the
       mutex.  (In the case of PTHREAD_MUTEX_RECURSIVE mutexes,
       the mutex becomes available when the count reaches zero
       and the calling thread no longer has any locks on this
       mutex).

       If a signal is delivered to a thread waiting for a mutex,
       upon return from the signal handler the thread resumes
       waiting for the mutex as if it was not interrupted.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.

       The function _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) returns zero if a
       lock on the mutex object referenced by _m_u_t_e_x is acquired.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) and _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_)
       functions will fail if:

       [EINVAL]
           The _m_u_t_e_x was created with the protocol attribute
           having the value PTHREAD_PRIO_PROTECT and the calling
           thread's priority is higher than the mutex's current
           priority ceiling.

       The _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) function will fail if:




08-Jun-2006               GNU Pth 2.0.7                        76





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EBUSY]
           The _m_u_t_e_x could not be acquired because it was already
           locked.

       The _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_), _p_t_h_r_e_a_d___m_u_t_e_x___t_r_y_l_o_c_k_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) functions may fail if:

       [EINVAL]
           The value specified by _m_u_t_e_x does not refer to an
           initialised mutex object.

       [EAGAIN]
           The mutex could not be acquired because the maximum
           number of recursive locks for _m_u_t_e_x has been exceeded.

       The _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_) function may fail if:

       [EDEADLK]
           The current thread already owns the mutex.

       The _p_t_h_r_e_a_d___m_u_t_e_x___u_n_l_o_c_k_(_) function may fail if:

       [EPERM]
           The current thread does not own the mutex.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_), _p_t_h_r_e_a_d___m_u_t_e_x___d_e_s_t_r_o_y_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__iinniitt,, pptthhrreeaadd__mmuutteexxaattttrr__ddeessttrrooyy -
       initialise and destroy mutex attributes object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutexattr_init(pthread_mutexattr_t *_a_t_t_r); int
       pthread_mutexattr_destroy(pthread_mutexattr_t *_a_t_t_r);

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_) initialises a mutex
       attributes object _a_t_t_r with the default value for all of



08-Jun-2006               GNU Pth 2.0.7                        77





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       the attributes defined by the implementation.

       The effect of initialising an already initialised mutex
       attributes object is undefined.

       After a mutex attributes object has been used to
       initialise one or more mutexes, any function affecting the
       attributes object (including destruction) does not affect
       any previously initialised mutexes.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___d_e_s_t_r_o_y_(_) function destroys a mutex
       attributes object; the object becomes, in effect,
       uninitialised.  An implementation may cause
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___d_e_s_t_r_o_y_(_) to set the object referenced
       by _a_t_t_r to an invalid value.  A destroyed mutex attributes
       object can be re-initialised using
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_); the results of otherwise
       referencing the object after it has been destroyed are
       undefined.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___d_e_s_t_r_o_y_(_) return zero.  Otherwise, an
       error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_) function may fail if:

       [ENOMEM]
           Insufficient memory exists to initialise the mutex
           attributes object.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___d_e_s_t_r_o_y_(_) function may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.





08-Jun-2006               GNU Pth 2.0.7                        78





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__sseettpprriioocceeiilliinngg,,
       pptthhrreeaadd__mmuutteexxaattttrr__ggeettpprriioocceeiilliinngg - set and get prioceiling
       attribute of mutex attribute object (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutexattr_setprioceiling(pthread_mutexattr_t
       *_a_t_t_r, int _p_r_i_o_c_e_i_l_i_n_g); int
       pthread_mutexattr_getprioceiling(const pthread_mutexattr_t
       *_a_t_t_r, int *_p_r_i_o_c_e_i_l_i_n_g);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions,
       respectively, set and get the priority ceiling attribute
       of a mutex attribute object pointed to by _a_t_t_r which was
       previously created by the function
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_).

       The _p_r_i_o_c_e_i_l_i_n_g attribute contains the priority ceiling of
       initialised mutexes.  The values of _p_r_i_o_c_e_i_l_i_n_g will be
       within the maximum range of priorities defined by
       SCHED_FIFO.

       The _p_r_i_o_c_e_i_l_i_n_g attribute defines the priority ceiling of
       initialised mutexes, which is the minimum priority level
       at which the critical section guarded by the mutex is
       executed.  In order to avoid priority inversion, the
       priority ceiling of the mutex will be set to a priority
       higher than or equal to the highest priority of all the
       threads that may lock that mutex.  The values of
       _p_r_i_o_c_e_i_l_i_n_g will be within the maximum range of priorities
       defined under the SCHED_FIFO scheduling policy.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, the
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIO_PROTECT is not defined
           and the implementation does not support the function.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions may fail if:



08-Jun-2006               GNU Pth 2.0.7                        79





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EINVAL]
           The value specified by _a_t_t_r or _p_r_i_o_c_e_i_l_i_n_g is invalid.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__sseettpprroottooccooll,,
       pptthhrreeaadd__mmuutteexxaattttrr__ggeettpprroottooccooll - set and get protocol
       attribute of mutex attribute object (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutexattr_setprotocol(pthread_mutexattr_t
       *_a_t_t_r, int _p_r_o_t_o_c_o_l); int
       pthread_mutexattr_getprotocol(const pthread_mutexattr_t
       *_a_t_t_r, int *_p_r_o_t_o_c_o_l);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_o_t_o_c_o_l_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_o_t_o_c_o_l_(_) functions, respectively,
       set and get the protocol attribute of a mutex attribute
       object pointed to by _a_t_t_r which was previously created by
       the function _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_).

       The _p_r_o_t_o_c_o_l attribute defines the protocol to be followed
       in utilising mutexes.  The value of _p_r_o_t_o_c_o_l may be one of
       PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT or
       PTHREAD_PRIO_PROTECT, which are defined by the header
       _<_p_t_h_r_e_a_d_._h>.

       When a thread owns a mutex with the PTHREAD_PRIO_NONE
       protocol attribute, its priority and scheduling are not
       affected by its mutex ownership.

       When a thread is blocking higher priority threads because
       of owning one or more mutexes with the
       PTHREAD_PRIO_INHERIT protocol attribute, it executes at



08-Jun-2006               GNU Pth 2.0.7                        80





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       the higher of its priority or the priority of the highest
       priority thread waiting on any of the mutexes owned by
       this thread and initialised with this protocol.

       When a thread owns one or more mutexes initialised with
       the PTHREAD_PRIO_PROTECT protocol, it executes at the
       higher of its priority or the highest of the priority
       ceilings of all the mutexes owned by this thread and
       initialised with this attribute, regardless of whether
       other threads are blocked on any of these mutexes or not.

       While a thread is holding a mutex which has been
       initialised with the PRIO_INHERIT or PRIO_PROTECT protocol
       attributes, it will not be subject to being moved to the
       tail of the scheduling queue at its priority in the event
       that its original priority is changed, such as by a call
       to _s_c_h_e_d___s_e_t_p_a_r_a_m_(_).  Likewise, when a thread unlocks a
       mutex that has been initialised with the PRIO_INHERIT or
       PRIO_PROTECT protocol attributes, it will not be subject
       to being moved to the tail of the scheduling queue at its
       priority in the event that its original priority is
       changed.

       If a thread simultaneously owns several mutexes
       initialised with different protocols, it will execute at
       the highest of the priorities that it would have obtained
       by each of these protocols.

       When a thread makes a call to _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_), if the
       symbol _POSIX_THREAD_PRIO_INHERIT is defined and the mutex
       was initialised with the protocol attribute having the
       value PTHREAD_PRIO_INHERIT, when the calling thread is
       blocked because the mutex is owned by another thread, that
       owner thread will inherit the priority level of the
       calling thread as long as it continues to own the mutex.
       The implementation updates its execution priority to the
       maximum of its assigned priority and all its inherited
       priorities.  Furthermore, if this owner thread itself
       becomes blocked on another mutex, the same priority
       inheritance effect will be propagated to this other owner
       thread, in a recursive manner.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, the
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_o_t_o_c_o_l_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_o_t_o_c_o_l_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_o_t_o_c_o_l_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_o_t_o_c_o_l_(_) functions will fail if:





08-Jun-2006               GNU Pth 2.0.7                        81





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [ENOSYS]
           Neither one of the options _POSIX_THREAD_PRIO_PROTECT
           and _POSIX_THREAD_PRIO_INHERIT is defined and the
           implementation does not support the function.

       [ENOTSUP]
           The value specified by _p_r_o_t_o_c_o_l is an unsupported
           value.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_o_t_o_c_o_l_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_o_t_o_c_o_l_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r ro _p_r_o_t_o_c_o_l is invalid.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__ggeettppsshhaarreedd,, pptthhrreeaadd__mmuutteexxaattttrr__sseettppsshhaarreedd
       - set and get process-shared attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutexattr_getpshared(const pthread_mutexattr_t
       *_a_t_t_r, int *_p_s_h_a_r_e_d); int
       pthread_mutexattr_setpshared(pthread_mutexattr_t *_a_t_t_r,
       int _p_s_h_a_r_e_d);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) function obtains the
       value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute from the attributes
       object referenced by _a_t_t_r.  The
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function is used to set the
       _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute in an initialised attributes
       object referenced by _a_t_t_r.

       The _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is set to



08-Jun-2006               GNU Pth 2.0.7                        82





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       PTHREAD_PROCESS_SHARED to permit a mutex to be operated
       upon by any thread that has access to the memory where the
       mutex is allocated, even if the mutex is allocated in
       memory that is shared by multiple processes.  If the
       _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is PTHREAD_PROCESS_PRIVATE, the
       mutex will only be operated upon by threads created within
       the same process as the thread that initialised the mutex;
       if threads of differing processes attempt to operate on
       such a mutex, the behaviour is undefined.  The default
       value of the attribute is PTHREAD_PROCESS_PRIVATE.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_)
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       Upon successful completion, _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_)
       returns zero and stores the value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d
       attribute of _a_t_t_r into the object referenced by the
       _p_s_h_a_r_e_d parameter.  Otherwise, an error number is returned
       to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function may fail if:

       [EINVAL]
           The new value specified for the attribute is outside
           the range of legal values for that attribute.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__ggeettttyyppee,, pptthhrreeaadd__mmuutteexxaattttrr__sseettttyyppee - get



08-Jun-2006               GNU Pth 2.0.7                        83





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       or set a mutex type

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutexattr_gettype(const pthread_mutexattr_t
       _*_a_t_t_r, int _*_t_y_p_e); int
       pthread_mutexattr_settype(pthread_mutexattr_t _*_a_t_t_r, int
       _t_y_p_e);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_t_y_p_e_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_t_y_p_e_(_) functions respectively get and
       set the mutex _t_y_p_e attribute.  This attribute is set in
       the _t_y_p_e parameter to these functions. The default value
       of the _t_y_p_e attribute is PTHREAD_MUTEX_DEFAULT.

       The type of mutex is contained in the _t_y_p_e attribute of
       the mutex attributes. Valid mutex types include:

       PTHREAD_MUTEX_NORMAL
           This type of mutex does not detect deadlock. A thread
           attempting to relock this mutex without first
           unlocking it will deadlock.  Attempting to unlock a
           mutex locked by a different thread results in
           undefined behaviour.  Attempting to unlock an unlocked
           mutex results in undefined behaviour.

       PTHREAD_MUTEX_ERRORCHECK
           This type of mutex provides error checking.  A thread
           attempting to relock this mutex without first
           unlocking it will return with an error.  A thread
           attempting to unlock a mutex which another thread has
           locked will return with an error.  A thread attempting
           to unlock an unlocked mutex will return with an error.

       PTHREAD_MUTEX_RECURSIVE
           A thread attempting to relock this mutex without first
           unlocking it will succeed in locking the mutex. The
           relocking deadlock which can occur with mutexes of
           type PTHREAD_MUTEX_NORMAL cannot occur with this type
           of mutex. Multiple locks of this mutex require the
           same number of unlocks to release the mutex before
           another thread can acquire the mutex.  A thread
           attempting to unlock a mutex which another thread has
           locked will return with an error. A thread attempting
           to unlock an unlocked mutex will return with an error.

       PTHREAD_MUTEX_DEFAULT
           Attempting to recursively lock a mutex of this type
           results in undefined behaviour. Attempting to unlock a
           mutex of this type which was not locked by the calling
           thread results in undefined behaviour. Attempting to
           unlock a mutex of this type which is not locked



08-Jun-2006               GNU Pth 2.0.7                        84





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


           results in undefined behaviour.  An implementation is
           allowed to map this mutex to one of the other mutex
           types.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_t_y_p_e_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       Upon successful completion, the
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_t_y_p_e_(_) function returns zero and
       stores the value of the _t_y_p_e attribute of _a_t_t_r into the
       object referenced by the _t_y_p_e parameter.  Otherwise an
       error is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_t_y_p_e_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_t_y_p_e_(_) functions will fail if:

       [EINVAL]
           The value _t_y_p_e is invalid.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_t_y_p_e_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_t_y_p_e_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       It is advised that an application should not use a
       PTHREAD_MUTEX_RECURSIVE mutex with condition variables
       because the implicit unlock performed for a
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) may not
       actually release the mutex (if it had been locked multiple
       times). If this happens, no other thread can satisfy the
       condition of the predicate.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__iinniitt,, pptthhrreeaadd__mmuutteexxaattttrr__ddeessttrrooyy -
       initialise and destroy mutex attributes object

SSYYNNOOPPSSIISS
       #include <pthread.h>



08-Jun-2006               GNU Pth 2.0.7                        85





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       int pthread_mutexattr_init(pthread_mutexattr_t *_a_t_t_r); int
       pthread_mutexattr_destroy(pthread_mutexattr_t *_a_t_t_r);

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_) initialises a mutex
       attributes object _a_t_t_r with the default value for all of
       the attributes defined by the implementation.

       The effect of initialising an already initialised mutex
       attributes object is undefined.

       After a mutex attributes object has been used to
       initialise one or more mutexes, any function affecting the
       attributes object (including destruction) does not affect
       any previously initialised mutexes.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___d_e_s_t_r_o_y_(_) function destroys a mutex
       attributes object; the object becomes, in effect,
       uninitialised.  An implementation may cause
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___d_e_s_t_r_o_y_(_) to set the object referenced
       by _a_t_t_r to an invalid value.  A destroyed mutex attributes
       object can be re-initialised using
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_); the results of otherwise
       referencing the object after it has been destroyed are
       undefined.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___d_e_s_t_r_o_y_(_) return zero.  Otherwise, an
       error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_) function may fail if:

       [ENOMEM]
           Insufficient memory exists to initialise the mutex
           attributes object.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___d_e_s_t_r_o_y_(_) function may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.




08-Jun-2006               GNU Pth 2.0.7                        86





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_),
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__sseettpprriioocceeiilliinngg,,
       pptthhrreeaadd__mmuutteexxaattttrr__ggeettpprriioocceeiilliinngg - set and get prioceiling
       attribute of mutex attribute object (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutexattr_setprioceiling(pthread_mutexattr_t
       *_a_t_t_r, int _p_r_i_o_c_e_i_l_i_n_g); int
       pthread_mutexattr_getprioceiling(const pthread_mutexattr_t
       *_a_t_t_r, int *_p_r_i_o_c_e_i_l_i_n_g);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions,
       respectively, set and get the priority ceiling attribute
       of a mutex attribute object pointed to by _a_t_t_r which was
       previously created by the function
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_).

       The _p_r_i_o_c_e_i_l_i_n_g attribute contains the priority ceiling of
       initialised mutexes.  The values of _p_r_i_o_c_e_i_l_i_n_g will be
       within the maximum range of priorities defined by
       SCHED_FIFO.

       The _p_r_i_o_c_e_i_l_i_n_g attribute defines the priority ceiling of
       initialised mutexes, which is the minimum priority level
       at which the critical section guarded by the mutex is
       executed.  In order to avoid priority inversion, the
       priority ceiling of the mutex will be set to a priority
       higher than or equal to the highest priority of all the
       threads that may lock that mutex.  The values of
       _p_r_i_o_c_e_i_l_i_n_g will be within the maximum range of priorities
       defined under the SCHED_FIFO scheduling policy.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, the
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions will fail if:





08-Jun-2006               GNU Pth 2.0.7                        87





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [ENOSYS]
           The option _POSIX_THREAD_PRIO_PROTECT is not defined
           and the implementation does not support the function.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_i_o_c_e_i_l_i_n_g_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r or _p_r_i_o_c_e_i_l_i_n_g is invalid.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__sseettpprroottooccooll,,
       pptthhrreeaadd__mmuutteexxaattttrr__ggeettpprroottooccooll - set and get protocol
       attribute of mutex attribute object (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutexattr_setprotocol(pthread_mutexattr_t
       *_a_t_t_r, int _p_r_o_t_o_c_o_l); int
       pthread_mutexattr_getprotocol(const pthread_mutexattr_t
       *_a_t_t_r, int *_p_r_o_t_o_c_o_l);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_o_t_o_c_o_l_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_o_t_o_c_o_l_(_) functions, respectively,
       set and get the protocol attribute of a mutex attribute
       object pointed to by _a_t_t_r which was previously created by
       the function _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_).

       The _p_r_o_t_o_c_o_l attribute defines the protocol to be followed
       in utilising mutexes.  The value of _p_r_o_t_o_c_o_l may be one of
       PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT or
       PTHREAD_PRIO_PROTECT, which are defined by the header
       _<_p_t_h_r_e_a_d_._h>.




08-Jun-2006               GNU Pth 2.0.7                        88





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       When a thread owns a mutex with the PTHREAD_PRIO_NONE
       protocol attribute, its priority and scheduling are not
       affected by its mutex ownership.

       When a thread is blocking higher priority threads because
       of owning one or more mutexes with the
       PTHREAD_PRIO_INHERIT protocol attribute, it executes at
       the higher of its priority or the priority of the highest
       priority thread waiting on any of the mutexes owned by
       this thread and initialised with this protocol.

       When a thread owns one or more mutexes initialised with
       the PTHREAD_PRIO_PROTECT protocol, it executes at the
       higher of its priority or the highest of the priority
       ceilings of all the mutexes owned by this thread and
       initialised with this attribute, regardless of whether
       other threads are blocked on any of these mutexes or not.

       While a thread is holding a mutex which has been
       initialised with the PRIO_INHERIT or PRIO_PROTECT protocol
       attributes, it will not be subject to being moved to the
       tail of the scheduling queue at its priority in the event
       that its original priority is changed, such as by a call
       to _s_c_h_e_d___s_e_t_p_a_r_a_m_(_).  Likewise, when a thread unlocks a
       mutex that has been initialised with the PRIO_INHERIT or
       PRIO_PROTECT protocol attributes, it will not be subject
       to being moved to the tail of the scheduling queue at its
       priority in the event that its original priority is
       changed.

       If a thread simultaneously owns several mutexes
       initialised with different protocols, it will execute at
       the highest of the priorities that it would have obtained
       by each of these protocols.

       When a thread makes a call to _p_t_h_r_e_a_d___m_u_t_e_x___l_o_c_k_(_), if the
       symbol _POSIX_THREAD_PRIO_INHERIT is defined and the mutex
       was initialised with the protocol attribute having the
       value PTHREAD_PRIO_INHERIT, when the calling thread is
       blocked because the mutex is owned by another thread, that
       owner thread will inherit the priority level of the
       calling thread as long as it continues to own the mutex.
       The implementation updates its execution priority to the
       maximum of its assigned priority and all its inherited
       priorities.  Furthermore, if this owner thread itself
       becomes blocked on another mutex, the same priority
       inheritance effect will be propagated to this other owner
       thread, in a recursive manner.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, the
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_o_t_o_c_o_l_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_o_t_o_c_o_l_(_) functions return zero.
       Otherwise, an error number is returned to indicate the



08-Jun-2006               GNU Pth 2.0.7                        89





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_o_t_o_c_o_l_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_o_t_o_c_o_l_(_) functions will fail if:

       [ENOSYS]
           Neither one of the options _POSIX_THREAD_PRIO_PROTECT
           and _POSIX_THREAD_PRIO_INHERIT is defined and the
           implementation does not support the function.

       [ENOTSUP]
           The value specified by _p_r_o_t_o_c_o_l is an unsupported
           value.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_r_o_t_o_c_o_l_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_r_o_t_o_c_o_l_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r ro _p_r_o_t_o_c_o_l is invalid.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_),
       _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__ggeettppsshhaarreedd,, pptthhrreeaadd__mmuutteexxaattttrr__sseettppsshhaarreedd
       - set and get process-shared attribute

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutexattr_getpshared(const pthread_mutexattr_t
       *_a_t_t_r, int *_p_s_h_a_r_e_d); int
       pthread_mutexattr_setpshared(pthread_mutexattr_t *_a_t_t_r,
       int _p_s_h_a_r_e_d);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) function obtains the
       value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute from the attributes



08-Jun-2006               GNU Pth 2.0.7                        90





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       object referenced by _a_t_t_r.  The
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function is used to set the
       _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute in an initialised attributes
       object referenced by _a_t_t_r.

       The _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is set to
       PTHREAD_PROCESS_SHARED to permit a mutex to be operated
       upon by any thread that has access to the memory where the
       mutex is allocated, even if the mutex is allocated in
       memory that is shared by multiple processes.  If the
       _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is PTHREAD_PROCESS_PRIVATE, the
       mutex will only be operated upon by threads created within
       the same process as the thread that initialised the mutex;
       if threads of differing processes attempt to operate on
       such a mutex, the behaviour is undefined.  The default
       value of the attribute is PTHREAD_PROCESS_PRIVATE.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_)
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       Upon successful completion, _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_)
       returns zero and stores the value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d
       attribute of _a_t_t_r into the object referenced by the
       _p_s_h_a_r_e_d parameter.  Otherwise, an error number is returned
       to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function may fail if:

       [EINVAL]
           The new value specified for the attribute is outside
           the range of legal values for that attribute.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___m_u_t_e_x___i_n_i_t_(_),



08-Jun-2006               GNU Pth 2.0.7                        91





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___i_n_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___i_n_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__mmuutteexxaattttrr__ggeettttyyppee,, pptthhrreeaadd__mmuutteexxaattttrr__sseettttyyppee - get
       or set a mutex type

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_mutexattr_gettype(const pthread_mutexattr_t
       _*_a_t_t_r, int _*_t_y_p_e); int
       pthread_mutexattr_settype(pthread_mutexattr_t _*_a_t_t_r, int
       _t_y_p_e);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_t_y_p_e_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_t_y_p_e_(_) functions respectively get and
       set the mutex _t_y_p_e attribute.  This attribute is set in
       the _t_y_p_e parameter to these functions. The default value
       of the _t_y_p_e attribute is PTHREAD_MUTEX_DEFAULT.

       The type of mutex is contained in the _t_y_p_e attribute of
       the mutex attributes. Valid mutex types include:

       PTHREAD_MUTEX_NORMAL
           This type of mutex does not detect deadlock. A thread
           attempting to relock this mutex without first
           unlocking it will deadlock.  Attempting to unlock a
           mutex locked by a different thread results in
           undefined behaviour.  Attempting to unlock an unlocked
           mutex results in undefined behaviour.

       PTHREAD_MUTEX_ERRORCHECK
           This type of mutex provides error checking.  A thread
           attempting to relock this mutex without first
           unlocking it will return with an error.  A thread
           attempting to unlock a mutex which another thread has
           locked will return with an error.  A thread attempting
           to unlock an unlocked mutex will return with an error.

       PTHREAD_MUTEX_RECURSIVE
           A thread attempting to relock this mutex without first
           unlocking it will succeed in locking the mutex. The
           relocking deadlock which can occur with mutexes of
           type PTHREAD_MUTEX_NORMAL cannot occur with this type
           of mutex. Multiple locks of this mutex require the
           same number of unlocks to release the mutex before
           another thread can acquire the mutex.  A thread
           attempting to unlock a mutex which another thread has
           locked will return with an error. A thread attempting
           to unlock an unlocked mutex will return with an error.




08-Jun-2006               GNU Pth 2.0.7                        92





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       PTHREAD_MUTEX_DEFAULT
           Attempting to recursively lock a mutex of this type
           results in undefined behaviour. Attempting to unlock a
           mutex of this type which was not locked by the calling
           thread results in undefined behaviour. Attempting to
           unlock a mutex of this type which is not locked
           results in undefined behaviour.  An implementation is
           allowed to map this mutex to one of the other mutex
           types.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_t_y_p_e_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       Upon successful completion, the
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_t_y_p_e_(_) function returns zero and
       stores the value of the _t_y_p_e attribute of _a_t_t_r into the
       object referenced by the _t_y_p_e parameter.  Otherwise an
       error is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_t_y_p_e_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_t_y_p_e_(_) functions will fail if:

       [EINVAL]
           The value _t_y_p_e is invalid.

       The _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___g_e_t_t_y_p_e_(_) and
       _p_t_h_r_e_a_d___m_u_t_e_x_a_t_t_r___s_e_t_t_y_p_e_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       It is advised that an application should not use a
       PTHREAD_MUTEX_RECURSIVE mutex with condition variables
       because the implicit unlock performed for a
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_) or _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_) may not
       actually release the mutex (if it had been locked multiple
       times). If this happens, no other thread can satisfy the
       condition of the predicate.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_o_n_d___w_a_i_t_(_), _p_t_h_r_e_a_d___c_o_n_d___t_i_m_e_d_w_a_i_t_(_),
       _<_p_t_h_r_e_a_d_._h>.





08-Jun-2006               GNU Pth 2.0.7                        93





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__oonnccee - dynamic package initialisation

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_once(pthread_once_t *_o_n_c_e___c_o_n_t_r_o_l, void
       (*_i_n_i_t___r_o_u_t_i_n_e)(void)); pthread_once_t _o_n_c_e___c_o_n_t_r_o_l =
       PTHREAD_ONCE_INIT;

DDEESSCCRRIIPPTTIIOONN
       The first call to _p_t_h_r_e_a_d___o_n_c_e_(_) by any thread in a
       process, with a given _o_n_c_e___c_o_n_t_r_o_l, will call the
       _i_n_i_t___r_o_u_t_i_n_e_(_) with no arguments.  Subsequent calls of
       _p_t_h_r_e_a_d___o_n_c_e_(_) with the same _o_n_c_e___c_o_n_t_r_o_l will not call
       the _i_n_i_t___r_o_u_t_i_n_e_(_).  On return from _p_t_h_r_e_a_d___o_n_c_e_(_), it is
       guaranteed that _i_n_i_t___r_o_u_t_i_n_e_(_) has completed.  The
       _o_n_c_e___c_o_n_t_r_o_l parameter is used to determine whether the
       associated initialisation routine has been called.

       The function _p_t_h_r_e_a_d___o_n_c_e_(_) is not a cancellation point.
       However, if _i_n_i_t___r_o_u_t_i_n_e_(_) is a cancellation point and is
       canceled, the effect on _o_n_c_e___c_o_n_t_r_o_l is as if
       _p_t_h_r_e_a_d___o_n_c_e_(_) was never called.

       The constant PTHREAD_ONCE_INIT is defined by the header
       _<_p_t_h_r_e_a_d_._h>.

       The behaviour of _p_t_h_r_e_a_d___o_n_c_e_(_) is undefined if
       _o_n_c_e___c_o_n_t_r_o_l has automatic storage duration or is not
       initialised by PTHREAD_ONCE_INIT.

RREETTUURRNN VVAALLUUEE
       Upon successful completion, _p_t_h_r_e_a_d___o_n_c_e_(_) returns zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       No errors are defined.

       The _p_t_h_r_e_a_d___o_n_c_e_(_) function will not return an error code
       of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.





08-Jun-2006               GNU Pth 2.0.7                        94





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_,_h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckk__iinniitt,, pptthhrreeaadd__rrwwlloocckk__ddeessttrrooyy - initialise
       or destroy a read-write lock object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlock_init(pthread_rwlock_t *rwlock, const
       pthread_rwlockattr_t _*_a_t_t_r); int
       pthread_rwlock_destroy(pthread_rwlock_t _*_r_w_l_o_c_k);
       pthread_rwlock_t _r_w_l_o_c_k=PTHREAD_RWLOCK_INITIALIZER;

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) function initialises the read-
       write lock referenced by _r_w_l_o_c_k with the attributes
       referenced by _a_t_t_r.  If _a_t_t_r is NULL, the default read-
       write lock attributes are used; the effect is the same as
       passing the address of a default read-write lock
       attributes object.  Once initialised, the lock can be used
       any number of times without being re-initialised.  Upon
       successful initialisation, the state of the read-write
       lock becomes initialised and unlocked.  Results are
       undefined if _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) is called specifying an
       already initialised read-write lock.  Results are
       undefined if a read-write lock is used without first being
       initialised.

       If the _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) function fails, _r_w_l_o_c_k is not
       initialised and the contents of _r_w_l_o_c_k are undefined.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) function destroys the read-
       write lock object referenced by _r_w_l_o_c_k and releases any
       resources used by the lock.  The effect of subsequent use
       of the lock is undefined until the lock is re-initialised
       by another call to _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_).  An
       implementation may cause _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) to set
       the object referenced by _r_w_l_o_c_k to an invalid value.
       Results are undefined if _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) is
       called when any thread holds _r_w_l_o_c_k.  Attempting to
       destroy an uninitialised read-write lock results in
       undefined behaviour.  A destroyed read-write lock object
       can be re-initialised using _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_); the
       results of otherwise referencing the read-write lock
       object after it has been destroyed are undefined.

       In cases where default read-write lock attributes are
       appropriate, the macro PTHREAD_RWLOCK_INITIALIZER can be
       used to initialise read-write locks that are statically
       allocated.  The effect is equivalent to dynamic
       initialisation by a call to _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) with the



08-Jun-2006               GNU Pth 2.0.7                        95





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       parameter _a_t_t_r specified as NULL, except that no error
       checks are performed.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.  The [EBUSY] and [EINVAL] error checks, if
       implemented, will act as if they were performed
       immediately at the beginning of processing for the
       function and caused an error return prior to modifying the
       state of the read-write lock specified by _r_w_l_o_c_k.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) function will fail if:

       [EAGAIN]
           The system lacked the necessary resources (other than
           memory) to initialise another read-write lock.

       [ENOMEM]
           Insufficient memory exists to initialise the read-
           write lock.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to re-
           initialise the object referenced by _r_w_l_o_c_k, a
           previously initialised but not yet destroyed read-
           write lock.

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to destroy
           the object referenced by _r_w_l_o_c_k while it is locked.

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE



08-Jun-2006               GNU Pth 2.0.7                        96





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckk__iinniitt,, pptthhrreeaadd__rrwwlloocckk__ddeessttrrooyy - initialise
       or destroy a read-write lock object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlock_init(pthread_rwlock_t *rwlock, const
       pthread_rwlockattr_t _*_a_t_t_r); int
       pthread_rwlock_destroy(pthread_rwlock_t _*_r_w_l_o_c_k);
       pthread_rwlock_t _r_w_l_o_c_k=PTHREAD_RWLOCK_INITIALIZER;

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) function initialises the read-
       write lock referenced by _r_w_l_o_c_k with the attributes
       referenced by _a_t_t_r.  If _a_t_t_r is NULL, the default read-
       write lock attributes are used; the effect is the same as
       passing the address of a default read-write lock
       attributes object.  Once initialised, the lock can be used
       any number of times without being re-initialised.  Upon
       successful initialisation, the state of the read-write
       lock becomes initialised and unlocked.  Results are
       undefined if _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) is called specifying an
       already initialised read-write lock.  Results are
       undefined if a read-write lock is used without first being
       initialised.

       If the _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) function fails, _r_w_l_o_c_k is not
       initialised and the contents of _r_w_l_o_c_k are undefined.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) function destroys the read-
       write lock object referenced by _r_w_l_o_c_k and releases any
       resources used by the lock.  The effect of subsequent use
       of the lock is undefined until the lock is re-initialised
       by another call to _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_).  An
       implementation may cause _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) to set
       the object referenced by _r_w_l_o_c_k to an invalid value.
       Results are undefined if _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) is
       called when any thread holds _r_w_l_o_c_k.  Attempting to
       destroy an uninitialised read-write lock results in
       undefined behaviour.  A destroyed read-write lock object



08-Jun-2006               GNU Pth 2.0.7                        97





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       can be re-initialised using _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_); the
       results of otherwise referencing the read-write lock
       object after it has been destroyed are undefined.

       In cases where default read-write lock attributes are
       appropriate, the macro PTHREAD_RWLOCK_INITIALIZER can be
       used to initialise read-write locks that are statically
       allocated.  The effect is equivalent to dynamic
       initialisation by a call to _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) with the
       parameter _a_t_t_r specified as NULL, except that no error
       checks are performed.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.  The [EBUSY] and [EINVAL] error checks, if
       implemented, will act as if they were performed
       immediately at the beginning of processing for the
       function and caused an error return prior to modifying the
       state of the read-write lock specified by _r_w_l_o_c_k.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) function will fail if:

       [EAGAIN]
           The system lacked the necessary resources (other than
           memory) to initialise another read-write lock.

       [ENOMEM]
           Insufficient memory exists to initialise the read-
           write lock.

       [EPERM]
           The caller does not have the privilege to perform the
           operation.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to re-
           initialise the object referenced by _r_w_l_o_c_k, a
           previously initialised but not yet destroyed read-
           write lock.

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k___d_e_s_t_r_o_y_(_) function may fail if:

       [EBUSY]
           The implementation has detected an attempt to destroy
           the object referenced by _r_w_l_o_c_k while it is locked.




08-Jun-2006               GNU Pth 2.0.7                        98





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EINVAL]
           The value specified by _a_t_t_r is invalid.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckk__rrddlloocckk,, pptthhrreeaadd__rrwwlloocckk__ttrryyrrddlloocckk - lock a
       read-write lock object for reading

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlock_rdlock(pthread_rwlock_t _*_r_w_l_o_c_k); int
       pthread_rwlock_tryrdlock(pthread_rwlock_t _*_r_w_l_o_c_k);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_) function applies a read lock
       to the read-write lock referenced by _r_w_l_o_c_k.  The calling
       thread acquires the read lock if a writer does not hold
       the lock and there are no writers blocked on the lock.  It
       is unspecified whether the calling thread acquires the
       lock when a writer does not hold the lock and there are
       writers waiting for the lock.  If a writer holds the lock,
       the calling thread will not acquire the read lock.  If the
       read lock is not acquired, the calling thread blocks (that
       is, it does not return from the _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_)
       call) until it can acquire the lock.  Results are
       undefined if the calling thread holds a write lock on
       _r_w_l_o_c_k at the time the call is made.

       Implementations are allowed to favour writers over readers
       to avoid writer starvation.

       A thread may hold multiple concurrent read locks on _r_w_l_o_c_k
       (that is, successfully call the _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_)
       function _n times). If so, the thread must perform matching
       unlocks (that is, it must call the _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_)



08-Jun-2006               GNU Pth 2.0.7                        99





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       function _n times).

       The function _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_r_d_l_o_c_k_(_) applies a read
       lock as in the _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_) function with the
       exception that the function fails if any thread holds a
       write lock on _r_w_l_o_c_k or there are writers blocked on
       _r_w_l_o_c_k.

       Results are undefined if any of these functions are called
       with an uninitialised read-write lock.

       If a signal is delivered to a thread waiting for a read-
       write lock for reading, upon return from the signal
       handler the thread resumes waiting for the read-write lock
       for reading as if it was not interrupted.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       The function _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_r_d_l_o_c_k_(_) returns zero if
       the lock for reading on the read-write lock object
       referenced by _r_w_l_o_c_k is acquired.  Otherwise an error
       number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_r_d_l_o_c_k_(_) function will fail if:

       [EBUSY]
           The read-write lock could not be acquired for reading
           because a writer holds the lock or was blocked on it.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_) and _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_r_d_l_o_c_k_(_)
       functions may fail if:

       [EINVAL]
           The value specified by _r_w_l_o_c_k does not refer to an
           initialised read-write lock object.

       [EDEADLK]
           The current thread already owns the read-write lock
           for writing.

       [EAGAIN]
           The read lock could not be acquired because the
           maximum number of read locks for _r_w_l_o_c_k has been
           exceeded.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In



08-Jun-2006               GNU Pth 2.0.7                       100





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

       Realtime applications may encounter priority inversion
       when using read-write locks.  The problem occurs when a
       high priority thread &quot;locks&quot; a read-write lock
       that is about to be &quot;unlocked&quot; by a low priority
       thread, but the low priority thread is preempted by a
       medium priority thread.  This scenario leads to priority
       inversion; a high priority thread is blocked by lower
       priority threads for an unlimited period of time.  During
       system design, realtime programmers must take into account
       the possibility of this kind of priority inversion.  They
       can deal with it in a number of ways, such as by having
       critical sections that are guarded by read-write locks
       execute at a high priority, so that a thread cannot be
       preempted while executing in its critical section.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckk__rrddlloocckk,, pptthhrreeaadd__rrwwlloocckk__ttrryyrrddlloocckk - lock a
       read-write lock object for reading

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlock_rdlock(pthread_rwlock_t _*_r_w_l_o_c_k); int
       pthread_rwlock_tryrdlock(pthread_rwlock_t _*_r_w_l_o_c_k);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_) function applies a read lock
       to the read-write lock referenced by _r_w_l_o_c_k.  The calling
       thread acquires the read lock if a writer does not hold
       the lock and there are no writers blocked on the lock.  It
       is unspecified whether the calling thread acquires the
       lock when a writer does not hold the lock and there are
       writers waiting for the lock.  If a writer holds the lock,
       the calling thread will not acquire the read lock.  If the
       read lock is not acquired, the calling thread blocks (that
       is, it does not return from the _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_)
       call) until it can acquire the lock.  Results are
       undefined if the calling thread holds a write lock on
       _r_w_l_o_c_k at the time the call is made.




08-Jun-2006               GNU Pth 2.0.7                       101





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       Implementations are allowed to favour writers over readers
       to avoid writer starvation.

       A thread may hold multiple concurrent read locks on _r_w_l_o_c_k
       (that is, successfully call the _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_)
       function _n times). If so, the thread must perform matching
       unlocks (that is, it must call the _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_)
       function _n times).

       The function _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_r_d_l_o_c_k_(_) applies a read
       lock as in the _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_) function with the
       exception that the function fails if any thread holds a
       write lock on _r_w_l_o_c_k or there are writers blocked on
       _r_w_l_o_c_k.

       Results are undefined if any of these functions are called
       with an uninitialised read-write lock.

       If a signal is delivered to a thread waiting for a read-
       write lock for reading, upon return from the signal
       handler the thread resumes waiting for the read-write lock
       for reading as if it was not interrupted.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       The function _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_r_d_l_o_c_k_(_) returns zero if
       the lock for reading on the read-write lock object
       referenced by _r_w_l_o_c_k is acquired.  Otherwise an error
       number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_r_d_l_o_c_k_(_) function will fail if:

       [EBUSY]
           The read-write lock could not be acquired for reading
           because a writer holds the lock or was blocked on it.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_) and _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_r_d_l_o_c_k_(_)
       functions may fail if:

       [EINVAL]
           The value specified by _r_w_l_o_c_k does not refer to an
           initialised read-write lock object.

       [EDEADLK]
           The current thread already owns the read-write lock
           for writing.

       [EAGAIN]
           The read lock could not be acquired because the
           maximum number of read locks for _r_w_l_o_c_k has been



08-Jun-2006               GNU Pth 2.0.7                       102





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


           exceeded.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

       Realtime applications may encounter priority inversion
       when using read-write locks.  The problem occurs when a
       high priority thread &quot;locks&quot; a read-write lock
       that is about to be &quot;unlocked&quot; by a low priority
       thread, but the low priority thread is preempted by a
       medium priority thread.  This scenario leads to priority
       inversion; a high priority thread is blocked by lower
       priority threads for an unlimited period of time.  During
       system design, realtime programmers must take into account
       the possibility of this kind of priority inversion.  They
       can deal with it in a number of ways, such as by having
       critical sections that are guarded by read-write locks
       execute at a high priority, so that a thread cannot be
       preempted while executing in its critical section.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckk__wwrrlloocckk,, pptthhrreeaadd__rrwwlloocckk__ttrryywwrrlloocckk - lock a
       read-write lock object for writing

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlock_wrlock(pthread_rwlock_t _*_r_w_l_o_c_k); int
       pthread_rwlock_trywrlock(pthread_rwlock_t _*_r_w_l_o_c_k);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) function applies a write lock
       to the read-write lock referenced by _r_w_l_o_c_k. The calling
       thread acquires the write lock if no other thread (reader
       or writer) holds the read-write lock _r_w_l_o_c_k.  Otherwise,
       the thread blocks (that is, does not return from the
       _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) call) until it can acquire the
       lock. Results are undefined if the calling thread holds



08-Jun-2006               GNU Pth 2.0.7                       103





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       the read-write lock (whether a read or write lock) at the
       time the call is made.

       Implementations are allowed to favour writers over readers
       to avoid writer starvation.

       The function _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_w_r_l_o_c_k_(_) applies a write
       lock like the _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) function, with the
       exception that the function fails if any thread currently
       holds _r_w_l_o_c_k (for reading or writing).

       Results are undefined if any of these functions are called
       with an uninitialised read-write lock.

       If a signal is delivered to a thread waiting for a read-
       write lock for writing, upon return from the signal
       handler the thread resumes waiting for the read-write lock
       for writing as if it was not interrupted.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       The function _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_w_r_l_o_c_k_(_) returns zero if
       the lock for writing on the read-write lock object
       referenced by _r_w_l_o_c_k is acquired.  Otherwise an error
       number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_w_r_l_o_c_k_(_) function will fail if:

       [EBUSY]
           The read-write lock could not be acquired for writing
           because it was already locked for reading or writing.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) and _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_w_r_l_o_c_k_(_)
       functions may fail if:

       [EINVAL]
           The value specified by _r_w_l_o_c_k does not refer to an
           initialised read-write lock object.

       [EDEADLK]
           The current thread already owns the read-write lock
           for writing or reading.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,



08-Jun-2006               GNU Pth 2.0.7                       104





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

       Realtime applications may encounter priority inversion
       when using read-write locks.  The problem occurs when a
       high priority thread &quot;locks&quot; a read-write lock
       that is about to be &quot;unlocked&quot; by a low priority
       thread, but the low priority thread is preempted by a
       medium priority thread.  This scenario leads to priority
       inversion; a high priority thread is blocked by lower
       priority threads for an unlimited period of time.  During
       system design, realtime programmers must take into account
       the possibility of this kind of priority inversion.  They
       can deal with it in a number of ways, such as by having
       critical sections that are guarded by read-write locks
       execute at a high priority, so that a thread cannot be
       preempted while executing in its critical section.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckk__uunnlloocckk - unlock a read-write lock object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlock_unlock(pthread_rwlock_t _*_r_w_l_o_c_k);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_) function is called to release
       a lock held on the read-write lock object referenced by
       _r_w_l_o_c_k.  Results are undefined if the read-write lock
       _r_w_l_o_c_k is not held by the calling thread.

       If this function is called to release a read lock from the
       read-write lock object and there are other read locks
       currently held on this read-write lock object, the read-
       write lock object remains in the read locked state.  If
       this function releases the calling thread's last read lock
       on this read-write lock object, then the calling thread is
       no longer one of the owners of the object.  If this
       function releases the last read lock for this read-write
       lock object, the read-write lock object will be put in the
       unlocked state with no owners.

       If this function is called to release a write lock for
       this read-write lock object, the read-write lock object



08-Jun-2006               GNU Pth 2.0.7                       105





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       will be put in the unlocked state with no owners.

       If the call to the _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_) function
       results in the read-write lock object becoming unlocked
       and there are multiple threads waiting to acquire the
       read-write lock object for writing, the scheduling policy
       is used to determine which thread acquires the read-write
       lock object for writing. If there are multiple threads
       waiting to acquire the read-write lock object for reading,
       the scheduling policy is used to determine the order in
       which the waiting threads acquire the read-write lock
       object for reading.  If there are multiple threads blocked
       on _r_w_l_o_c_k for both read locks and write locks, it is
       unspecified whether the readers acquire the lock first or
       whether a writer acquires the lock first.

       Results are undefined if any of these functions are called
       with an uninitialised read-write lock.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_) function may fail if:

       [EINVAL]
           The value specified by _r_w_l_o_c_k does not refer to an
           initialised read-write lock object.

       [EPERM]
           The current thread does not own the read-write lock.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_).

____________________________________________________________________________________________________________________________________________




08-Jun-2006               GNU Pth 2.0.7                       106





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


NNAAMMEE
       pptthhrreeaadd__rrwwlloocckk__wwrrlloocckk,, pptthhrreeaadd__rrwwlloocckk__ttrryywwrrlloocckk - lock a
       read-write lock object for writing

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlock_wrlock(pthread_rwlock_t _*_r_w_l_o_c_k); int
       pthread_rwlock_trywrlock(pthread_rwlock_t _*_r_w_l_o_c_k);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) function applies a write lock
       to the read-write lock referenced by _r_w_l_o_c_k. The calling
       thread acquires the write lock if no other thread (reader
       or writer) holds the read-write lock _r_w_l_o_c_k.  Otherwise,
       the thread blocks (that is, does not return from the
       _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) call) until it can acquire the
       lock. Results are undefined if the calling thread holds
       the read-write lock (whether a read or write lock) at the
       time the call is made.

       Implementations are allowed to favour writers over readers
       to avoid writer starvation.

       The function _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_w_r_l_o_c_k_(_) applies a write
       lock like the _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) function, with the
       exception that the function fails if any thread currently
       holds _r_w_l_o_c_k (for reading or writing).

       Results are undefined if any of these functions are called
       with an uninitialised read-write lock.

       If a signal is delivered to a thread waiting for a read-
       write lock for writing, upon return from the signal
       handler the thread resumes waiting for the read-write lock
       for writing as if it was not interrupted.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) function
       returns zero.  Otherwise, an error number is returned to
       indicate the error.

       The function _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_w_r_l_o_c_k_(_) returns zero if
       the lock for writing on the read-write lock object
       referenced by _r_w_l_o_c_k is acquired.  Otherwise an error
       number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_w_r_l_o_c_k_(_) function will fail if:

       [EBUSY]
           The read-write lock could not be acquired for writing
           because it was already locked for reading or writing.




08-Jun-2006               GNU Pth 2.0.7                       107





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       The _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_) and _p_t_h_r_e_a_d___r_w_l_o_c_k___t_r_y_w_r_l_o_c_k_(_)
       functions may fail if:

       [EINVAL]
           The value specified by _r_w_l_o_c_k does not refer to an
           initialised read-write lock object.

       [EDEADLK]
           The current thread already owns the read-write lock
           for writing or reading.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

       Realtime applications may encounter priority inversion
       when using read-write locks.  The problem occurs when a
       high priority thread &quot;locks&quot; a read-write lock
       that is about to be &quot;unlocked&quot; by a low priority
       thread, but the low priority thread is preempted by a
       medium priority thread.  This scenario leads to priority
       inversion; a high priority thread is blocked by lower
       priority threads for an unlimited period of time.  During
       system design, realtime programmers must take into account
       the possibility of this kind of priority inversion.  They
       can deal with it in a number of ways, such as by having
       critical sections that are guarded by read-write locks
       execute at a high priority, so that a thread cannot be
       preempted while executing in its critical section.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckkaattttrr__iinniitt,, pptthhrreeaadd__rrwwlloocckkaattttrr__ddeessttrrooyy -
       initialise and destroy read-write lock attributes object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlockattr_init(pthread_rwlockattr_t _*_a_t_t_r);
       int pthread_rwlockattr_destroy(pthread_rwlockattr_t



08-Jun-2006               GNU Pth 2.0.7                       108





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _*_a_t_t_r);

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_) initialises a read-
       write lock attributes object _a_t_t_r with the default value
       for all of the attributes defined by the implementation.

       Results are undefined if _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_) is
       called specifying an already initialised read-write lock
       attributes object.

       After a read-write lock attributes object has been used to
       initialise one or more read-write locks, any function
       affecting the attributes object (including destruction)
       does not affect any previously initialised read-write
       locks.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___d_e_s_t_r_o_y_(_) function destroys a read-
       write lock attributes object. The effect of subsequent use
       of the object is undefined until the object is re-
       initialised by another call to _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_).
       An implementation may cause _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___d_e_s_t_r_o_y_(_)
       to set the object referenced by attr to an invalid value.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___d_e_s_t_r_o_y_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_) function will fail if:

       [ENOMEM]
           Insufficient memory exists to initialise the read-
           write lock attributes object.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___d_e_s_t_r_o_y_(_) function may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.



08-Jun-2006               GNU Pth 2.0.7                       109





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckkaattttrr__ggeettppsshhaarreedd,,
       pptthhrreeaadd__rrwwlloocckkaattttrr__sseettppsshhaarreedd - get and set process-shared
       attribute of read-write lock attributes object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlockattr_getpshared(const
       pthread_rwlockattr_t _*_a_t_t_r, int _*_p_s_h_a_r_e_d); int
       pthread_rwlockattr_setpshared(pthread_rwlockattr_t _*_a_t_t_r,
       int _p_s_h_a_r_e_d);

DDEESSCCRRIIPPTTIIOONN
       The _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is set to
       PTHREAD_PROCESS_SHARED to permit a read-write lock to be
       operated upon by any thread that has access to the memory
       where the read-write lock is allocated, even if the read-
       write lock is allocated in memory that is shared by
       multiple processes.  If the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is
       PTHREAD_PROCESS_PRIVATE, the read-write lock will only be
       operated upon by threads created within the same process
       as the thread that initialised the read-write lock; if
       threads of differing processes attempt to operate on such
       a read-write lock, the behaviour is undefined. The default
       value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is
       PTHREAD_PROCESS_PRIVATE.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) function obtains the
       value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute from the initialised
       attributes object referenced by _a_t_t_r.  The
       _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function is used to set
       the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute in an initialised attributes
       object referenced by attr.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_)
       function returns zero.  Otherwise, an error number is
       returned to indicate the error.

       Upon successful completion, the
       _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) returns zero and stores
       the value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute of _a_t_t_r into the
       object referenced by the _p_s_h_a_r_e_d parameter. Otherwise an
       error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) and



08-Jun-2006               GNU Pth 2.0.7                       110





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function may fail if:

       [EINVAL]
           The new value specified for the attribute is outside
           the range of legal values for that attribute.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckkaattttrr__iinniitt,, pptthhrreeaadd__rrwwlloocckkaattttrr__ddeessttrrooyy -
       initialise and destroy read-write lock attributes object

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_rwlockattr_init(pthread_rwlockattr_t _*_a_t_t_r);
       int pthread_rwlockattr_destroy(pthread_rwlockattr_t
       _*_a_t_t_r);

DDEESSCCRRIIPPTTIIOONN
       The function _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_) initialises a read-
       write lock attributes object _a_t_t_r with the default value
       for all of the attributes defined by the implementation.

       Results are undefined if _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_) is
       called specifying an already initialised read-write lock
       attributes object.

       After a read-write lock attributes object has been used to
       initialise one or more read-write locks, any function
       affecting the attributes object (including destruction)
       does not affect any previously initialised read-write



08-Jun-2006               GNU Pth 2.0.7                       111





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       locks.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___d_e_s_t_r_o_y_(_) function destroys a read-
       write lock attributes object. The effect of subsequent use
       of the object is undefined until the object is re-
       initialised by another call to _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_).
       An implementation may cause _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___d_e_s_t_r_o_y_(_)
       to set the object referenced by attr to an invalid value.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_) and
       _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___d_e_s_t_r_o_y_(_) functions return zero.
       Otherwise, an error number is returned to indicate the
       error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_) function will fail if:

       [ENOMEM]
           Insufficient memory exists to initialise the read-
           write lock attributes object.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___d_e_s_t_r_o_y_(_) function may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__rrwwlloocckkaattttrr__ggeettppsshhaarreedd,,
       pptthhrreeaadd__rrwwlloocckkaattttrr__sseettppsshhaarreedd - get and set process-shared
       attribute of read-write lock attributes object

SSYYNNOOPPSSIISS
       #include <pthread.h>




08-Jun-2006               GNU Pth 2.0.7                       112





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       int pthread_rwlockattr_getpshared(const
       pthread_rwlockattr_t _*_a_t_t_r, int _*_p_s_h_a_r_e_d); int
       pthread_rwlockattr_setpshared(pthread_rwlockattr_t _*_a_t_t_r,
       int _p_s_h_a_r_e_d);

DDEESSCCRRIIPPTTIIOONN
       The _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is set to
       PTHREAD_PROCESS_SHARED to permit a read-write lock to be
       operated upon by any thread that has access to the memory
       where the read-write lock is allocated, even if the read-
       write lock is allocated in memory that is shared by
       multiple processes.  If the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is
       PTHREAD_PROCESS_PRIVATE, the read-write lock will only be
       operated upon by threads created within the same process
       as the thread that initialised the read-write lock; if
       threads of differing processes attempt to operate on such
       a read-write lock, the behaviour is undefined. The default
       value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute is
       PTHREAD_PROCESS_PRIVATE.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) function obtains the
       value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute from the initialised
       attributes object referenced by _a_t_t_r.  The
       _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function is used to set
       the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute in an initialised attributes
       object referenced by attr.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_)
       function returns zero.  Otherwise, an error number is
       returned to indicate the error.

       Upon successful completion, the
       _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) returns zero and stores
       the value of the _p_r_o_c_e_s_s_-_s_h_a_r_e_d attribute of _a_t_t_r into the
       object referenced by the _p_s_h_a_r_e_d parameter. Otherwise an
       error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___g_e_t_p_s_h_a_r_e_d_(_) and
       _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) functions may fail if:

       [EINVAL]
           The value specified by _a_t_t_r is invalid.

       The _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___s_e_t_p_s_h_a_r_e_d_(_) function may fail if:

       [EINVAL]
           The new value specified for the attribute is outside
           the range of legal values for that attribute.

EEXXAAMMPPLLEESS
       None.




08-Jun-2006               GNU Pth 2.0.7                       113





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       Similar functions are being developed by IEEE PASC.  In
       keeping with its objective of ensuring that CAE
       Specifications are fully aligned with formal standards,
       The Open Group intends to add any new interfaces adopted
       by an official IEEE standard in this area.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _<_p_t_h_r_e_a_d_._h>, _p_t_h_r_e_a_d___r_w_l_o_c_k___i_n_i_t_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___u_n_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k___w_r_l_o_c_k_(_),
       _p_t_h_r_e_a_d___r_w_l_o_c_k___r_d_l_o_c_k_(_), _p_t_h_r_e_a_d___r_w_l_o_c_k_a_t_t_r___i_n_i_t_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__sseellff - get calling thread's ID

SSYYNNOOPPSSIISS
       #include <pthread.h>

       pthread_t pthread_self(void);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___s_e_l_f_(_) function returns the thread ID of the
       calling thread.

RREETTUURRNN VVAALLUUEE
       See DESCRIPTION above.

EERRRROORRSS
       No errors are defined.

       The _p_t_h_r_e_a_d___s_e_l_f_(_) function will not return an error code
       of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_), _p_t_h_r_e_a_d___e_q_u_a_l_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__sseettccaanncceellssttaattee,, pptthhrreeaadd__sseettccaanncceellttyyppee,,
       pptthhrreeaadd__tteessttccaanncceell - set cancelability state




08-Jun-2006               GNU Pth 2.0.7                       114





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_setcancelstate(int _s_t_a_t_e, int *_o_l_d_s_t_a_t_e); int
       pthread_setcanceltype(int _t_y_p_e, int *_o_l_d_t_y_p_e); void
       pthread_testcancel(void);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_) function atomically both sets
       the calling thread's cancelability state to the indicated
       _s_t_a_t_e and returns the previous cancelability state at the
       location referenced by _o_l_d_s_t_a_t_e.  Legal values for _s_t_a_t_e
       are PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DISABLE.

       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_t_y_p_e_(_) function atomically both sets
       the calling thread's cancelability type to the indicated
       _t_y_p_e and returns the previous cancelability type at the
       location referenced by _o_l_d_t_y_p_e.  Legal values for _t_y_p_e are
       PTHREAD_CANCEL_DEFERRED and PTHREAD_CANCEL_ASYNCHRONOUS.

       The cancelability state and type of any newly created
       threads, including the thread in which _m_a_i_n_(_) was first
       invoked, are PTHREAD_CANCEL_ENABLE and
       PTHREAD_CANCEL_DEFERRED respectively.

       The _p_t_h_r_e_a_d___t_e_s_t_c_a_n_c_e_l_(_) function creates a cancellation
       point in the calling thread.  The _p_t_h_r_e_a_d___t_e_s_t_c_a_n_c_e_l_(_)
       function has no effect if cancelability is disabled.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_) and
       _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_t_y_p_e_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_) function may fail if:

       [EINVAL]
           The specified state is not PTHREAD_CANCEL_ENABLE or
           PTHREAD_CANCEL_DISABLE.

       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_t_y_p_e_(_) function may fail if:

       [EINVAL]
           The specified type is not PTHREAD_CANCEL_DEFERRED or
           PTHREAD_CANCEL_ASYNCHRONOUS.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.



08-Jun-2006               GNU Pth 2.0.7                       115





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_a_n_c_e_l_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__sseettccaanncceellssttaattee,, pptthhrreeaadd__sseettccaanncceellttyyppee,,
       pptthhrreeaadd__tteessttccaanncceell - set cancelability state

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_setcancelstate(int _s_t_a_t_e, int *_o_l_d_s_t_a_t_e); int
       pthread_setcanceltype(int _t_y_p_e, int *_o_l_d_t_y_p_e); void
       pthread_testcancel(void);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_) function atomically both sets
       the calling thread's cancelability state to the indicated
       _s_t_a_t_e and returns the previous cancelability state at the
       location referenced by _o_l_d_s_t_a_t_e.  Legal values for _s_t_a_t_e
       are PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DISABLE.

       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_t_y_p_e_(_) function atomically both sets
       the calling thread's cancelability type to the indicated
       _t_y_p_e and returns the previous cancelability type at the
       location referenced by _o_l_d_t_y_p_e.  Legal values for _t_y_p_e are
       PTHREAD_CANCEL_DEFERRED and PTHREAD_CANCEL_ASYNCHRONOUS.

       The cancelability state and type of any newly created
       threads, including the thread in which _m_a_i_n_(_) was first
       invoked, are PTHREAD_CANCEL_ENABLE and
       PTHREAD_CANCEL_DEFERRED respectively.

       The _p_t_h_r_e_a_d___t_e_s_t_c_a_n_c_e_l_(_) function creates a cancellation
       point in the calling thread.  The _p_t_h_r_e_a_d___t_e_s_t_c_a_n_c_e_l_(_)
       function has no effect if cancelability is disabled.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_) and
       _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_t_y_p_e_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_) function may fail if:

       [EINVAL]
           The specified state is not PTHREAD_CANCEL_ENABLE or
           PTHREAD_CANCEL_DISABLE.

       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_t_y_p_e_(_) function may fail if:




08-Jun-2006               GNU Pth 2.0.7                       116





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EINVAL]
           The specified type is not PTHREAD_CANCEL_DEFERRED or
           PTHREAD_CANCEL_ASYNCHRONOUS.

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_a_n_c_e_l_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__sseettccoonnccuurrrreennccyy - get or set level of concurrency

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_setconcurrency(int _n_e_w___l_e_v_e_l);

DDEESSCCRRIIPPTTIIOONN
       Refer to _p_t_h_r_e_a_d___g_e_t_c_o_n_c_u_r_r_e_n_c_y_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ggeettsscchheeddppaarraamm,, pptthhrreeaadd__sseettsscchheeddppaarraamm - dynamic
       thread scheduling parameters access (RREEAALLTTIIMMEE TTHHRREEAADDSS)

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_getschedparam(pthread_t _t_h_r_e_a_d, int *_p_o_l_i_c_y,
       struct sched_param *_p_a_r_a_m); int
       pthread_setschedparam(pthread_t _t_h_r_e_a_d, int _p_o_l_i_c_y, const
       struct sched_param *_p_a_r_a_m);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) and _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_)
       allow the scheduling policy and scheduling parameters of
       individual threads within a multi-threaded process to be
       retrieved and set.  For SCHED_FIFO and SCHED_RR, the only
       required member of the sscchheedd__ppaarraamm structure is the
       priority _s_c_h_e_d___p_r_i_o_r_i_t_y.  For SCHED_OTHER, the affected
       scheduling parameters are implementation-dependent.

       The _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) function retrieves the
       scheduling policy and scheduling parameters for the thread



08-Jun-2006               GNU Pth 2.0.7                       117





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       whose thread ID is given by _t_h_r_e_a_d and stores those values
       in _p_o_l_i_c_y and _p_a_r_a_m, respectively.  The priority value
       returned from _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) is the value
       specified by the most recent _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) or
       _p_t_h_r_e_a_d___c_r_e_a_t_e_(_) call affecting the target thread, and
       reflects any temporary adjustments to its priority as a
       result of any priority inheritance or ceiling functions.
       The _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) function sets the scheduling
       policy and associated scheduling parameters for the thread
       whose thread ID is given by _t_h_r_e_a_d to the policy and
       associated parameters provided in _p_o_l_i_c_y and _p_a_r_a_m,
       respectively.

       The _p_o_l_i_c_y parameter may have the value SCHED_OTHER, that
       has implementation-dependent scheduling parameters,
       SCHED_FIFO or SCHED_RR, that have the single scheduling
       parameter, _p_r_i_o_r_i_t_y_.

       If the _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) function fails, no
       scheduling parameters will be changed for the target
       thread.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) and
       _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) and _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_)
       functions will fail if:

       [ENOSYS]
           The option _POSIX_THREAD_PRIORITY_SCHEDULING is not
           defined and the implementation does not support the
           function.

       The _p_t_h_r_e_a_d___g_e_t_s_c_h_e_d_p_a_r_a_m_(_) function may fail if:

       [ESRCH]
           The value specified by _t_h_r_e_a_d does not refer to a
           existing thread.

       The _p_t_h_r_e_a_d___s_e_t_s_c_h_e_d_p_a_r_a_m_(_) function may fail if:

       [EINVAL]
           The value specified by _p_o_l_i_c_y or one of the scheduling
           parameters associated with the scheduling policy
           _p_o_l_i_c_y is invalid.

       [ENOTSUP]
           An attempt was made to set the policy or scheduling
           parameters to an unsupported value.





08-Jun-2006               GNU Pth 2.0.7                       118





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       [EPERM]
           The caller does not have the appropriate permission to
           set either the scheduling parameters or the scheduling
           policy of the specified thread.

       [EPERM]
           The implementation does not allow the application to
           modify one of the parameters to the value specified.

       [ESRCH]
           The value specified by _t_h_r_e_a_d does not refer to a
           existing thread.

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _s_c_h_e_d___s_e_t_p_a_r_a_m_(_), _s_c_h_e_d___g_e_t_p_a_r_a_m_(_), _s_c_h_e_d___s_e_t_s_c_h_e_d_u_l_e_r_(_),
       _s_c_h_e_d___g_e_t_s_c_h_e_d_u_l_e_r_(_), _<_p_t_h_r_e_a_d_._h>, _<_s_c_h_e_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__sseettssppeecciiffiicc,, pptthhrreeaadd__ggeettssppeecciiffiicc - thread-specific
       data management

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_setspecific(pthread_key_t _k_e_y, const void
       *_v_a_l_u_e); void *pthread_getspecific(pthread_key_t _k_e_y);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) function associates a thread-
       specific _v_a_l_u_e with a _k_e_y obtained via a previous call to
       _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_).  Different threads may bind
       different values to the same key.  These values are
       typically pointers to blocks of dynamically allocated
       memory that have been reserved for use by the calling
       thread.

       The _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_) function returns the value
       currently bound to the specified _k_e_y on behalf of the
       calling thread.

       The effect of calling _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) or
       _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_) with a _k_e_y value not obtained from
       _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_) or after _k_e_y has been deleted with
       _p_t_h_r_e_a_d___k_e_y___d_e_l_e_t_e_(_) is undefined.



08-Jun-2006               GNU Pth 2.0.7                       119





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       Both _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) and _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_) may
       be called from a thread-specific data destructor function.
       However, calling _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) from a destructor
       may result in lost storage or infinite loops.

       Both functions may be implemented as macros.

RREETTUURRNN VVAALLUUEE
       The function _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_) returns the thread-
       specific data value associated with the given _k_e_y.  If no
       thread-specific data value is associated with _k_e_y, then
       the value NULL is returned.

       If successful, the _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) function returns
       zero.  Otherwise, an error number is returned to indicate
       the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) function will fail if:

       [ENOMEM]
           Insufficient memory exists to associate the value with
           the key.

       The _p_t_h_r_e_a_d___s_e_t_s_p_e_c_i_f_i_c_(_) function may fail if:

       [EINVAL]
           The key value is invalid.

       No errors are returned from _p_t_h_r_e_a_d___g_e_t_s_p_e_c_i_f_i_c_(_).

       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___k_e_y___c_r_e_a_t_e_(_), _<_p_t_h_r_e_a_d_._h>.

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__ssiiggmmaasskk - examine and change blocked signals

SSYYNNOOPPSSIISS
       #include <signal.h>

       int pthread_sigmask(int _h_o_w, const sigset_t *_s_e_t, sigset_t
       *_o_s_e_t);



08-Jun-2006               GNU Pth 2.0.7                       120





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


DDEESSCCRRIIPPTTIIOONN
       Refer to _s_i_g_p_r_o_c_m_a_s_k_(_).

____________________________________________________________________________________________________________________________________________
NNAAMMEE
       pptthhrreeaadd__sseettccaanncceellssttaattee,, pptthhrreeaadd__sseettccaanncceellttyyppee,,
       pptthhrreeaadd__tteessttccaanncceell - set cancelability state

SSYYNNOOPPSSIISS
       #include <pthread.h>

       int pthread_setcancelstate(int _s_t_a_t_e, int *_o_l_d_s_t_a_t_e); int
       pthread_setcanceltype(int _t_y_p_e, int *_o_l_d_t_y_p_e); void
       pthread_testcancel(void);

DDEESSCCRRIIPPTTIIOONN
       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_) function atomically both sets
       the calling thread's cancelability state to the indicated
       _s_t_a_t_e and returns the previous cancelability state at the
       location referenced by _o_l_d_s_t_a_t_e.  Legal values for _s_t_a_t_e
       are PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DISABLE.

       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_t_y_p_e_(_) function atomically both sets
       the calling thread's cancelability type to the indicated
       _t_y_p_e and returns the previous cancelability type at the
       location referenced by _o_l_d_t_y_p_e.  Legal values for _t_y_p_e are
       PTHREAD_CANCEL_DEFERRED and PTHREAD_CANCEL_ASYNCHRONOUS.

       The cancelability state and type of any newly created
       threads, including the thread in which _m_a_i_n_(_) was first
       invoked, are PTHREAD_CANCEL_ENABLE and
       PTHREAD_CANCEL_DEFERRED respectively.

       The _p_t_h_r_e_a_d___t_e_s_t_c_a_n_c_e_l_(_) function creates a cancellation
       point in the calling thread.  The _p_t_h_r_e_a_d___t_e_s_t_c_a_n_c_e_l_(_)
       function has no effect if cancelability is disabled.

RREETTUURRNN VVAALLUUEE
       If successful, the _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_) and
       _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_t_y_p_e_(_) functions return zero.  Otherwise,
       an error number is returned to indicate the error.

EERRRROORRSS
       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_s_t_a_t_e_(_) function may fail if:

       [EINVAL]
           The specified state is not PTHREAD_CANCEL_ENABLE or
           PTHREAD_CANCEL_DISABLE.

       The _p_t_h_r_e_a_d___s_e_t_c_a_n_c_e_l_t_y_p_e_(_) function may fail if:

       [EINVAL]
           The specified type is not PTHREAD_CANCEL_DEFERRED or
           PTHREAD_CANCEL_ASYNCHRONOUS.



08-Jun-2006               GNU Pth 2.0.7                       121





pthread(3)        POSIX Threading API of GNU Pth       pthread(3)


       These functions will not return an error code of [EINTR].

EEXXAAMMPPLLEESS
       None.

AAPPPPLLIICCAATTIIOONN UUSSAAGGEE
       None.

FFUUTTUURREE DDIIRREECCTTIIOONNSS
       None.

SSEEEE AALLSSOO
       _p_t_h_r_e_a_d___c_a_n_c_e_l_(_), _<_p_t_h_r_e_a_d_._h>.












































08-Jun-2006               GNU Pth 2.0.7                       122


