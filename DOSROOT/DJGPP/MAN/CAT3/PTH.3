


pth(3)                 GNU Portable Threads                pth(3)


NNAAMMEE
       pptthh - GNU Portable Threads

VVEERRSSIIOONN
       pth 2.0.7 (08-Jun-2006) based on GNU Pth

SSYYNNOOPPSSIISS
       GGlloobbaall LLiibbrraarryy MMaannaaggeemmeenntt
           pth_init, pth_kill, pth_ctrl, pth_version.

       TThhrreeaadd AAttttrriibbuuttee HHaannddlliinngg
           pth_attr_of, pth_attr_new, pth_attr_init,
           pth_attr_set, pth_attr_get, pth_attr_destroy.

       TThhrreeaadd CCoonnttrrooll
           pth_spawn, pth_once, pth_self, pth_suspend,
           pth_resume, pth_yield, pth_nap, pth_wait, pth_cancel,
           pth_abort, pth_raise, pth_join, pth_exit.

       UUttiilliittiieess
           pth_fdmode, pth_time, pth_timeout, pth_sfiodisc.

       CCaanncceellllaattiioonn MMaannaaggeemmeenntt
           pth_cancel_point, pth_cancel_state.

       EEvveenntt HHaannddlliinngg
           pth_event, pth_event_typeof, pth_event_extract,
           pth_event_concat, pth_event_isolate, pth_event_walk,
           pth_event_status, pth_event_free.

       KKeeyy--BBaasseedd SSttoorraaggee
           pth_key_create, pth_key_delete, pth_key_setdata,
           pth_key_getdata.

       MMeessssaaggee PPoorrtt CCoommmmuunniiccaattiioonn
           pth_msgport_create, pth_msgport_destroy,
           pth_msgport_find, pth_msgport_pending,
           pth_msgport_put, pth_msgport_get, pth_msgport_reply.

       TThhrreeaadd CClleeaannuuppss
           pth_cleanup_push, pth_cleanup_pop.

       PPrroocceessss FFoorrkkiinngg
           pth_atfork_push, pth_atfork_pop, pth_fork.

       SSyynncchhrroonniizzaattiioonn
           pth_mutex_init, pth_mutex_acquire, pth_mutex_release,
           pth_rwlock_init, pth_rwlock_acquire,
           pth_rwlock_release, pth_cond_init, pth_cond_await,
           pth_cond_notify, pth_barrier_init, pth_barrier_reach.

       SSeemmaapphhoorree ssuuppppoorrtt
           pth_sem_init, pth_sem_dec, pth_sem_dec_value,
           pth_sem_inc, pth_sem_inc_value, pth_sem_set_value,



08-Jun-2006               GNU Pth 2.0.7                         1





pth(3)                 GNU Portable Threads                pth(3)


           pth_sem_get_value.

       UUsseerr--SSppaaccee CCoonntteexxtt
           pth_uctx_create, pth_uctx_make, pth_uctx_switch,
           pth_uctx_destroy.

       GGeenneerraalliizzeedd PPOOSSIIXX RReeppllaacceemmeenntt AAPPII
           pth_sigwait_ev, pth_accept_ev, pth_connect_ev,
           pth_select_ev, pth_poll_ev, pth_read_ev, pth_readv_ev,
           pth_write_ev, pth_writev_ev, pth_recv_ev,
           pth_recvfrom_ev, pth_send_ev, pth_sendto_ev.

       SSttaannddaarrdd PPOOSSIIXX RReeppllaacceemmeenntt AAPPII
           pth_nanosleep, pth_usleep, pth_sleep, pth_waitpid,
           pth_system, pth_sigmask, pth_sigwait, pth_accept,
           pth_connect, pth_select, pth_pselect, pth_poll,
           pth_read, pth_readv, pth_write, pth_writev, pth_pread,
           pth_pwrite, pth_recv, pth_recvfrom, pth_send,
           pth_sendto.

DDEESSCCRRIIPPTTIIOONN
         ____  _   _
        |  _ \| |_| |__
        | |_) | __| '_ \         ``Only those who attempt
        |  __/| |_| | | |          the absurd can achieve
        |_|    \__|_| |_|          the impossible.''

       PPtthh is a very portable POSIX/ANSI-C based library for Unix
       platforms which provides non-preemptive priority-based
       scheduling for multiple threads of execution (aka
       `multithreading') inside event-driven applications. All
       threads run in the same address space of the application
       process, but each thread has its own individual program
       counter, run-time stack, signal mask and "errno" variable.

       The thread scheduling itself is done in a cooperative way,
       i.e., the threads are managed and dispatched by a
       priority- and event-driven non-preemptive scheduler. The
       intention is that this way both better portability and
       run-time performance is achieved than with preemptive
       scheduling. The event facility allows threads to wait
       until various types of internal and external events occur,
       including pending I/O on file descriptors, asynchronous
       signals, elapsed timers, pending I/O on message ports,
       thread and process termination, and even results of
       customized callback functions.

       PPtthh also provides an optional emulation API for POSIX.1c
       threads (`Pthreads') which can be used for backward
       compatibility to existing multithreaded applications. See
       PPtthh's _p_t_h_r_e_a_d(3) manual page for details.






08-Jun-2006               GNU Pth 2.0.7                         2





pth(3)                 GNU Portable Threads                pth(3)


       TThhrreeaaddiinngg BBaacckkggrroouunndd

       When programming event-driven applications, usually
       servers, lots of regular jobs and one-shot requests have
       to be processed in parallel.  To efficiently simulate this
       parallel processing on uniprocessor machines, we use
       `multitasking' -- that is, we have the application ask the
       operating system to spawn multiple instances of itself. On
       Unix, typically the kernel implements multitasking in a
       preemptive and priority-based way through heavy-weight
       processes spawned with _f_o_r_k(2).  These processes usually
       do _n_o_t share a common address space. Instead they are
       clearly separated from each other, and are created by
       direct cloning a process address space (although modern
       kernels use memory segment mapping and copy-on-write
       semantics to avoid unnecessary copying of physical
       memory).

       The drawbacks are obvious: Sharing data between the
       processes is complicated, and can usually only be done
       efficiently through shared memory (but which itself is not
       very portable). Synchronization is complicated because of
       the preemptive nature of the Unix scheduler (one has to
       use _a_t_o_m_i_c locks, etc). The machine's resources can be
       exhausted very quickly when the server application has to
       serve too many long-running requests (heavy-weight
       processes cost memory). And when each request spawns a
       sub-process to handle it, the server performance and
       responsiveness is horrible (heavy-weight processes cost
       time to spawn). Finally, the server application doesn't
       scale very well with the load because of these resource
       problems. In practice, lots of tricks are usually used to
       overcome these problems - ranging from pre-forked sub-
       process pools to semi-serialized processing, etc.

       One of the most elegant ways to solve these resource- and
       data-sharing problems is to have multiple _l_i_g_h_t_-_w_e_i_g_h_t
       threads of execution inside a single (heavy-weight)
       process, i.e., to use _m_u_l_t_i_t_h_r_e_a_d_i_n_g.  Those _t_h_r_e_a_d_s
       usually improve responsiveness and performance of the
       application, often improve and simplify the internal
       program structure, and most important, require less system
       resources than heavy-weight processes. Threads are neither
       the optimal run-time facility for all types of
       applications, nor can all applications benefit from them.
       But at least event-driven server applications usually
       benefit greatly from using threads.

       TThhee WWoorrlldd ooff TThhrreeaaddiinngg

       Even though lots of documents exists which describe and
       define the world of threading, to understand PPtthh, you need
       only basic knowledge about threading. The following
       definitions of thread-related terms should at least help



08-Jun-2006               GNU Pth 2.0.7                         3





pth(3)                 GNU Portable Threads                pth(3)


       you understand thread programming enough to allow you to
       use PPtthh.

       oo pprroocceessss vs. tthhrreeaadd
         A process on Unix systems consists of at least the
         following fundamental ingredients: _v_i_r_t_u_a_l _m_e_m_o_r_y _t_a_b_l_e,
         _p_r_o_g_r_a_m _c_o_d_e, _p_r_o_g_r_a_m _c_o_u_n_t_e_r, _h_e_a_p _m_e_m_o_r_y, _s_t_a_c_k
         _m_e_m_o_r_y, _s_t_a_c_k _p_o_i_n_t_e_r, _f_i_l_e _d_e_s_c_r_i_p_t_o_r _s_e_t, _s_i_g_n_a_l
         _t_a_b_l_e. On every process switch, the kernel saves and
         restores these ingredients for the individual processes.
         On the other hand, a thread consists of only a private
         program counter, stack memory, stack pointer and signal
         table. All other ingredients, in particular the virtual
         memory, it shares with the other threads of the same
         process.

       oo kkeerrnneell--ssppaaccee vs. uusseerr--ssppaaccee threading
         Threads on a Unix platform traditionally can be
         implemented either inside kernel-space or user-space.
         When threads are implemented by the kernel, the thread
         context switches are performed by the kernel without the
         application's knowledge. Similarly, when threads are
         implemented in user-space, the thread context switches
         are performed by an application library, without the
         kernel's knowledge. There also are hybrid threading
         approaches where, typically, a user-space library binds
         one or more user-space threads to one or more kernel-
         space threads (there usually called light-weight
         processes - or in short LWPs).

         User-space threads are usually more portable and can
         perform faster and cheaper context switches (for
         instance via _s_w_a_p_c_o_n_t_e_x_t(2) or _s_e_t_j_m_p(3)/_l_o_n_g_j_m_p(3))
         than kernel based threads. On the other hand, kernel-
         space threads can take advantage of multiprocessor
         machines and don't have any inherent I/O blocking
         problems. Kernel-space threads are usually scheduled in
         preemptive way side-by-side with the underlying
         processes. User-space threads on the other hand use
         either preemptive or non-preemptive scheduling.

       oo pprreeeemmppttiivvee vs. nnoonn--pprreeeemmppttiivvee thread scheduling
         In preemptive scheduling, the scheduler lets a thread
         execute until a blocking situation occurs (usually a
         function call which would block) or the assigned
         timeslice elapses. Then it detracts control from the
         thread without a chance for the thread to object. This
         is usually realized by interrupting the thread through a
         hardware interrupt signal (for kernel-space threads) or
         a software interrupt signal (for user-space threads),
         like "SIGALRM" or "SIGVTALRM". In non-preemptive
         scheduling, once a thread received control from the
         scheduler it keeps it until either a blocking situation
         occurs (again a function call which would block and



08-Jun-2006               GNU Pth 2.0.7                         4





pth(3)                 GNU Portable Threads                pth(3)


         instead switches back to the scheduler) or the thread
         explicitly yields control back to the scheduler in a
         cooperative way.

       oo ccoonnccuurrrreennccyy vs. ppaarraalllleelliissmm
         Concurrency exists when at least two threads are _i_n
         _p_r_o_g_r_e_s_s at the same time. Parallelism arises when at
         least two threads are _e_x_e_c_u_t_i_n_g simultaneously. Real
         parallelism can be only achieved on multiprocessor
         machines, of course. But one also usually speaks of
         parallelism or _h_i_g_h _c_o_n_c_u_r_r_e_n_c_y in the context of
         preemptive thread scheduling and of _l_o_w _c_o_n_c_u_r_r_e_n_c_y in
         the context of non-preemptive thread scheduling.

       oo rreessppoonnssiivveenneessss
         The responsiveness of a system can be described by the
         user visible delay until the system responses to an
         external request. When this delay is small enough and
         the user doesn't recognize a noticeable delay, the
         responsiveness of the system is considered good. When
         the user recognizes or is even annoyed by the delay, the
         responsiveness of the system is considered bad.

       oo rreeeennttrraanntt, tthhrreeaadd--ssaaffee and aassyynncchhrroonnoouuss--ssaaffee functions
         A reentrant function is one that behaves correctly if it
         is called simultaneously by several threads and then
         also executes simultaneously.  Functions that access
         global state, such as memory or files, of course, need
         to be carefully designed in order to be reentrant. Two
         traditional approaches to solve these problems are
         caller-supplied states and thread-specific data.

         Thread-safety is the avoidance of _d_a_t_a _r_a_c_e_s, i.e.,
         situations in which data is set to either correct or
         incorrect value depending upon the (unpredictable) order
         in which multiple threads access and modify the data. So
         a function is thread-safe when it still behaves
         semantically correct when called simultaneously by
         several threads (it is not required that the functions
         also execute simultaneously). The traditional approach
         to achieve thread-safety is to wrap a function body with
         an internal mutual exclusion lock (aka `mutex'). As you
         should recognize, reentrant is a stronger attribute than
         thread-safe, because it is harder to achieve and results
         especially in no run-time contention between threads.
         So, a reentrant function is always thread-safe, but not
         vice versa.

         Additionally there is a related attribute for functions
         named asynchronous-safe, which comes into play in
         conjunction with signal handlers. This is very related
         to the problem of reentrant functions. An asynchronous-
         safe function is one that can be called safe and without
         side-effects from within a signal handler context.



08-Jun-2006               GNU Pth 2.0.7                         5





pth(3)                 GNU Portable Threads                pth(3)


         Usually very few functions are of this type, because an
         application is very restricted in what it can perform
         from within a signal handler (especially what system
         functions it is allowed to call). The reason mainly is,
         because only a few system functions are officially
         declared by POSIX as guaranteed to be asynchronous-safe.
         Asynchronous-safe functions usually have to be already
         reentrant.

       UUsseerr--SSppaaccee TThhrreeaaddss

       User-space threads can be implemented in various way. The
       two traditional approaches are:

       11.. MMaattrriixx--bbaasseedd eexxpplliicciitt ddiissppaattcchhiinngg bbeettwweeeenn ssmmaallll uunniittss
          ooff eexxeeccuuttiioonn::

          Here the global procedures of the application are split
          into small execution units (each is required to not run
          for more than a few milliseconds) and those units are
          implemented by separate functions.  Then a global
          matrix is defined which describes the execution (and
          perhaps even dependency) order of these functions. The
          main server procedure then just dispatches between
          these units by calling one function after each other
          controlled by this matrix. The threads are created by
          more than one jump-trail through this matrix and by
          switching between these jump-trails controlled by
          corresponding occurred events.

          This approach gives the best possible performance,
          because one can fine-tune the threads of execution by
          adjusting the matrix, and the scheduling is done
          explicitly by the application itself. It is also very
          portable, because the matrix is just an ordinary data
          structure, and functions are a standard feature of ANSI
          C.

          The disadvantage of this approach is that it is
          complicated to write large applications with this
          approach, because in those applications one quickly
          gets hundreds(!) of execution units and the control
          flow inside such an application is very hard to
          understand (because it is interrupted by function
          borders and one always has to remember the global
          dispatching matrix to follow it). Additionally, all
          threads operate on the same execution stack. Although
          this saves memory, it is often nasty, because one
          cannot switch between threads in the middle of a
          function. Thus the scheduling borders are the function
          borders.

       22.. CCoonntteexxtt--bbaasseedd iimmpplliicciitt sscchheedduulliinngg bbeettwweeeenn tthhrreeaaddss ooff
          eexxeeccuuttiioonn::



08-Jun-2006               GNU Pth 2.0.7                         6





pth(3)                 GNU Portable Threads                pth(3)


          Here the idea is that one programs the application as
          with forked processes, i.e., one spawns a thread of
          execution and this runs from the begin to the end
          without an interrupted control flow. But the control
          flow can be still interrupted - even in the middle of a
          function.  Actually in a preemptive way, similar to
          what the kernel does for the heavy-weight processes,
          i.e., every few milliseconds the user-space scheduler
          switches between the threads of execution. But the
          thread itself doesn't recognize this and usually
          (except for synchronization issues) doesn't have to
          care about this.

          The advantage of this approach is that it's very easy
          to program, because the control flow and context of a
          thread directly follows a procedure without forced
          interrupts through function borders.  Additionally, the
          programming is very similar to a traditional and well
          understood _f_o_r_k(2) based approach.

          The disadvantage is that although the general
          performance is increased, compared to using approaches
          based on heavy-weight processes, it is decreased
          compared to the matrix-approach above. Because the
          implicit preemptive scheduling does usually a lot more
          context switches (every user-space context switch costs
          some overhead even when it is a lot cheaper than a
          kernel-level context switch) than the explicit
          cooperative/non-preemptive scheduling.  Finally, there
          is no really portable POSIX/ANSI-C based way to
          implement user-space preemptive threading. Either the
          platform already has threads, or one has to hope that
          some semi-portable package exists for it. And even
          those semi-portable packages usually have to deal with
          assembler code and other nasty internals and are not
          easy to port to forthcoming platforms.

       So, in short: the matrix-dispatching approach is portable
       and fast, but nasty to program. The thread scheduling
       approach is easy to program, but suffers from
       synchronization and portability problems caused by its
       preemptive nature.

       TThhee CCoommpprroommiissee ooff PPtthh

       But why not combine the good aspects of both approaches
       while avoiding their bad aspects? That's the goal of PPtthh.
       PPtthh implements easy-to-program threads of execution, but
       avoids the problems of preemptive scheduling by using non-
       preemptive scheduling instead.

       This sounds like, and is, a useful approach. Nevertheless,
       one has to keep the implications of non-preemptive thread
       scheduling in mind when working with PPtthh. The following



08-Jun-2006               GNU Pth 2.0.7                         7





pth(3)                 GNU Portable Threads                pth(3)


       list summarizes a few essential points:

       oo PPtthh pprroovviiddeess mmaaxxiimmuumm ppoorrttaabbiilliittyy,, bbuutt NNOOTT tthhee ffaanncciieesstt
         ffeeaattuurreess.

         This is, because it uses a nifty and portable
         POSIX/ANSI-C approach for thread creation (and this way
         doesn't require any platform dependent assembler hacks)
         and schedules the threads in non-preemptive way (which
         doesn't require unportable facilities like "SIGVTALRM").
         On the other hand, this way not all fancy threading
         features can be implemented.  Nevertheless the available
         facilities are enough to provide a robust and full-
         featured threading system.

       oo PPtthh iinnccrreeaasseess tthhee rreessppoonnssiivveenneessss aanndd ccoonnccuurrrreennccyy ooff aann
         eevveenntt--ddrriivveenn aapppplliiccaattiioonn,, bbuutt NNOOTT tthhee ccoonnccuurrrreennccyy ooff
         nnuummbbeerr--ccrruunncchhiinngg aapppplliiccaattiioonnss.

         The reason is the non-preemptive scheduling. Number-
         crunching applications usually require preemptive
         scheduling to achieve concurrency because of their long
         CPU bursts. For them, non-preemptive scheduling (even
         together with explicit yielding) provides only the old
         concept of `coroutines'. On the other hand, event driven
         applications benefit greatly from non-preemptive
         scheduling. They have only short CPU bursts and lots of
         events to wait on, and this way run faster under non-
         preemptive scheduling because no unnecessary context
         switching occurs, as it is the case for preemptive
         scheduling. That's why PPtthh is mainly intended for server
         type applications, although there is no technical
         restriction.

       oo PPtthh rreeqquuiirreess tthhrreeaadd--ssaaffee ffuunnccttiioonnss,, bbuutt NNOOTT rreeeennttrraanntt
         ffuunnccttiioonnss.

         This nice fact exists again because of the nature of
         non-preemptive scheduling, where a function isn't
         interrupted and this way cannot be reentered before it
         returned. This is a great portability benefit, because
         thread-safety can be achieved more easily than
         reentrance possibility. Especially this means that under
         PPtthh more existing third-party libraries can be used
         without side-effects than it's the case for other
         threading systems.

       oo PPtthh ddooeessnn''tt rreeqquuiirree aannyy kkeerrnneell ssuuppppoorrtt,, bbuutt ccaann NNOOTT
         bbeenneeffiitt ffrroomm mmuullttiipprroocceessssoorr mmaacchhiinneess.

         This means that PPtthh runs on almost all Unix kernels,
         because the kernel does not need to be aware of the PPtthh
         threads (because they are implemented entirely in
         user-space). On the other hand, it cannot benefit from



08-Jun-2006               GNU Pth 2.0.7                         8





pth(3)                 GNU Portable Threads                pth(3)


         the existence of multiprocessors, because for this,
         kernel support would be needed. In practice, this is no
         problem, because multiprocessor systems are rare, and
         portability is almost more important than highest
         concurrency.

       TThhee lliiffee ccyyccllee ooff aa tthhrreeaadd

       To understand the PPtthh Application Programming Interface
       (API), it helps to first understand the life cycle of a
       thread in the PPtthh threading system. It can be illustrated
       with the following directed graph:

                    NEW
                     |
                     V
             +---> READY ---+
             |       ^      |
             |       |      V
          WAITING <--+-- RUNNING
                            |
             :              V
          SUSPENDED       DEAD

       When a new thread is created, it is moved into the NNEEWW
       queue of the scheduler. On the next dispatching for this
       thread, the scheduler picks it up from there and moves it
       to the RREEAADDYY queue. This is a queue containing all threads
       which want to perform a CPU burst. There they are queued
       in priority order. On each dispatching step, the scheduler
       always removes the thread with the highest priority only.
       It then increases the priority of all remaining threads by
       1, to prevent them from `starving'.

       The thread which was removed from the RREEAADDYY queue is the
       new RRUUNNNNIINNGG thread (there is always just one RRUUNNNNIINNGG
       thread, of course). The RRUUNNNNIINNGG thread is assigned
       execution control. After this thread yields execution
       (either explicitly by yielding execution or implicitly by
       calling a function which would block) there are three
       possibilities: Either it has terminated, then it is moved
       to the DDEEAADD queue, or it has events on which it wants to
       wait, then it is moved into the WWAAIITTIINNGG queue. Else it is
       assumed it wants to perform more CPU bursts and
       immediately enters the RREEAADDYY queue again.

       Before the next thread is taken out of the RREEAADDYY queue,
       the WWAAIITTIINNGG queue is checked for pending events. If one or
       more events occurred, the threads that are waiting on them
       are immediately moved to the RREEAADDYY queue.

       The purpose of the NNEEWW queue has to do with the fact that
       in PPtthh a thread never directly switches to another thread.
       A thread always yields execution to the scheduler and the



08-Jun-2006               GNU Pth 2.0.7                         9





pth(3)                 GNU Portable Threads                pth(3)


       scheduler dispatches to the next thread. So a freshly
       spawned thread has to be kept somewhere until the
       scheduler gets a chance to pick it up for scheduling. That
       is what the NNEEWW queue is for.

       The purpose of the DDEEAADD queue is to support thread
       joining. When a thread is marked to be unjoinable, it is
       directly kicked out of the system after it terminated. But
       when it is joinable, it enters the DDEEAADD queue. There it
       remains until another thread joins it.

       Finally, there is a special separated queue named
       SSUUSSPPEENNDDEEDD, to where threads can be manually moved from the
       NNEEWW, RREEAADDYY or WWAAIITTIINNGG queues by the application. The
       purpose of this special queue is to temporarily absorb
       suspended threads until they are again resumed by the
       application. Suspended threads do not cost scheduling or
       event handling resources, because they are temporarily
       completely out of the scheduler's scope. If a thread is
       resumed, it is moved back to the queue from where it
       originally came and this way again enters the schedulers
       scope.

AAPPPPLLIICCAATTIIOONN PPRROOGGRRAAMMMMIINNGG IINNTTEERRFFAACCEE ((AAPPII))
       In the following the PPtthh _A_p_p_l_i_c_a_t_i_o_n _P_r_o_g_r_a_m_m_i_n_g _I_n_t_e_r_f_a_c_e
       (API) is discussed in detail. With the knowledge given
       above, it should now be easy to understand how to program
       threads with this API. In good Unix tradition, PPtthh
       functions use special return values ("NULL" in pointer
       context, "FALSE" in boolean context and "-1" in integer
       context) to indicate an error condition and set (or pass
       through) the "errno" system variable to pass more details
       about the error to the caller.

       GGlloobbaall LLiibbrraarryy MMaannaaggeemmeenntt

       The following functions act on the library as a whole.
       They are used to initialize and shutdown the scheduler and
       fetch information from it.

       int pptthh__iinniitt(void);
           This initializes the PPtthh library. It has to be the
           first PPtthh API function call in an application, and is
           mandatory. It's usually done at the begin of the
           _m_a_i_n_(_) function of the application. This implicitly
           spawns the internal scheduler thread and transforms
           the single execution unit of the current process into
           a thread (the `main' thread). It returns "TRUE" on
           success and "FALSE" on error.

       int pptthh__kkiillll(void);
           This kills the PPtthh library. It should be the last PPtthh
           API function call in an application, but is not really
           required. It's usually done at the end of the main



08-Jun-2006               GNU Pth 2.0.7                        10





pth(3)                 GNU Portable Threads                pth(3)


           function of the application. At least, it has to be
           called from within the main thread. It implicitly
           kills all threads and transforms back the calling
           thread into the single execution unit of the
           underlying process.  The usual way to terminate a PPtthh
           application is either a simple `"pth_exit(0);"' in the
           main thread (which waits for all other threads to
           terminate, kills the threading system and then
           terminates the process) or a `"pth_kill(); exit(0)"'
           (which immediately kills the threading system and
           terminates the process). The _p_t_h___k_i_l_l_(_) return
           immediately with a return code of "FALSE" if it is not
           called from within the main thread. Else it kills the
           threading system and returns "TRUE".

       long pptthh__ccttrrll(unsigned long _q_u_e_r_y, ...);
           This is a generalized query/control function for the
           PPtthh library.  The argument _q_u_e_r_y is a bitmask formed
           out of one or more "PTH_CTRL_"_X_X_X_X queries. Currently
           the following queries are supported:

           "PTH_CTRL_GETTHREADS"
               This returns the total number of threads currently
               in existence.  This query actually is formed out
               of the combination of queries for threads in a
               particular state, i.e., the "PTH_CTRL_GETTHREADS"
               query is equal to the OR-combination of all the
               following specialized queries:

               "PTH_CTRL_GETTHREADS_NEW" for the number of
               threads in the new queue (threads created via
               _p_t_h___s_p_a_w_n(3) but still not scheduled once),
               "PTH_CTRL_GETTHREADS_READY" for the number of
               threads in the ready queue (threads who want to do
               CPU bursts), "PTH_CTRL_GETTHREADS_RUNNING" for the
               number of running threads (always just one
               thread!), "PTH_CTRL_GETTHREADS_WAITING" for the
               number of threads in the waiting queue (threads
               waiting for events),
               "PTH_CTRL_GETTHREADS_SUSPENDED" for the number of
               threads in the suspended queue (threads waiting to
               be resumed) and "PTH_CTRL_GETTHREADS_DEAD" for the
               number of threads in the new queue (terminated
               threads waiting for a join).

           "PTH_CTRL_GETAVLOAD"
               This requires a second argument of type `"float
               *"' (pointer to a floating point variable).  It
               stores a floating point value describing the
               exponential averaged load of the scheduler in this
               variable. The load is a function from the number
               of threads in the ready queue of the schedulers
               dispatching unit.  So a load around 1.0 means
               there is only one ready thread (the standard



08-Jun-2006               GNU Pth 2.0.7                        11





pth(3)                 GNU Portable Threads                pth(3)


               situation when the application has no high load).
               A higher load value means there a more threads
               ready who want to do CPU bursts. The average load
               value updates once per second only. The return
               value for this query is always 0.

           "PTH_CTRL_GETPRIO"
               This requires a second argument of type `"pth_t"'
               which identifies a thread.  It returns the
               priority (ranging from "PTH_PRIO_MIN" to
               "PTH_PRIO_MAX") of the given thread.

           "PTH_CTRL_GETNAME"
               This requires a second argument of type `"pth_t"'
               which identifies a thread. It returns the name of
               the given thread, i.e., the return value of
               _p_t_h___c_t_r_l(3) should be casted to a `"char *"'.

           "PTH_CTRL_DUMPSTATE"
               This requires a second argument of type `"FILE *"'
               to which a summary of the internal PPtthh library
               state is written to. The main information which is
               currently written out is the current state of the
               thread pool.

           "PTH_CTRL_FAVOURNEW"
               This requires a second argument of type `"int"'
               which specified whether the GGNNUU PPtthh scheduler
               favours new threads on startup, i.e., whether they
               are moved from the new queue to the top (argument
               is "TRUE") or middle (argument is "FALSE") of the
               ready queue. The default is to favour new threads
               to make sure they do not starve already at
               startup, although this slightly violates the
               strict priority based scheduling.

           The function returns "-1" on error.

       long pptthh__vveerrssiioonn(void);
           This function returns a hex-value `0x_V_R_R_T_L_L' which
           describes the current PPtthh library version. _V is the
           version, _R_R the revisions, _L_L the level and _T the type
           of the level (alphalevel=0, betalevel=1, patchlevel=2,
           etc). For instance PPtthh version 1.0b1 is encoded as
           0x100101.  The reason for this unusual mapping is that
           this way the version number is steadily _i_n_c_r_e_a_s_i_n_g.
           The same value is also available under compile time as
           "PTH_VERSION".

       TThhrreeaadd AAttttrriibbuuttee HHaannddlliinngg

       Attribute objects are used in PPtthh for two things: First
       stand-alone/unbound attribute objects are used to store
       attributes for to be spawned threads.  Bounded attribute



08-Jun-2006               GNU Pth 2.0.7                        12





pth(3)                 GNU Portable Threads                pth(3)


       objects are used to modify attributes of already existing
       threads. The following attribute fields exists in
       attribute objects:

       "PTH_ATTR_PRIO" (read-write) ["int"]
           Thread Priority between "PTH_PRIO_MIN" and
           "PTH_PRIO_MAX".  The default is "PTH_PRIO_STD".

       "PTH_ATTR_NAME" (read-write) ["char *"]
           Name of thread (up to 40 characters are stored only),
           mainly for debugging purposes.

       "PTH_ATTR_DISPATCHES" (read-write) ["int"]
           In bounded attribute objects, this field is
           incremented every time the context is switched to the
           associated thread.

       "PTH_ATTR_JOINABLE" (read-write> ["int"]
           The thread detachment type, "TRUE" indicates a
           joinable thread, "FALSE" indicates a detached thread.
           When a thread is detached, after termination it is
           immediately kicked out of the system instead of
           inserted into the dead queue.

       "PTH_ATTR_CANCEL_STATE" (read-write) ["unsigned int"]
           The thread cancellation state, i.e., a combination of
           "PTH_CANCEL_ENABLE" or "PTH_CANCEL_DISABLE" and
           "PTH_CANCEL_DEFERRED" or "PTH_CANCEL_ASYNCHRONOUS".

       "PTH_ATTR_STACK_SIZE" (read-write) ["unsigned int"]
           The thread stack size in bytes. Use lower values than
           64 KB with great care!

       "PTH_ATTR_STACK_ADDR" (read-write) ["char *"]
           A pointer to the lower address of a chunk of
           _m_a_l_l_o_c(3)'ed memory for the stack.

       "PTH_ATTR_TIME_SPAWN" (read-only) ["pth_time_t"]
           The time when the thread was spawned.  This can be
           queried only when the attribute object is bound to a
           thread.

       "PTH_ATTR_TIME_LAST" (read-only) ["pth_time_t"]
           The time when the thread was last dispatched.  This
           can be queried only when the attribute object is bound
           to a thread.

       "PTH_ATTR_TIME_RAN" (read-only) ["pth_time_t"]
           The total time the thread was running.  This can be
           queried only when the attribute object is bound to a
           thread.

       "PTH_ATTR_START_FUNC" (read-only) ["void *(*)(void *)"]
           The thread start function.  This can be queried only



08-Jun-2006               GNU Pth 2.0.7                        13





pth(3)                 GNU Portable Threads                pth(3)


           when the attribute object is bound to a thread.

       "PTH_ATTR_START_ARG" (read-only) ["void *"]
           The thread start argument.  This can be queried only
           when the attribute object is bound to a thread.

       "PTH_ATTR_STATE" (read-only) ["pth_state_t"]
           The scheduling state of the thread, i.e., either
           "PTH_STATE_NEW", "PTH_STATE_READY",
           "PTH_STATE_WAITING", or "PTH_STATE_DEAD" This can be
           queried only when the attribute object is bound to a
           thread.

       "PTH_ATTR_EVENTS" (read-only) ["pth_event_t"]
           The event ring the thread is waiting for.  This can be
           queried only when the attribute object is bound to a
           thread.

       "PTH_ATTR_BOUND" (read-only) ["int"]
           Whether the attribute object is bound ("TRUE") to a
           thread or not ("FALSE").

       The following API functions can be used to handle the
       attribute objects:

       pth_attr_t pptthh__aattttrr__ooff(pth_t _t_i_d);
           This returns a new attribute object _b_o_u_n_d to thread
           _t_i_d.  Any queries on this object directly fetch
           attributes from _t_i_d. And attribute modifications
           directly change _t_i_d. Use such attribute objects to
           modify existing threads.

       pth_attr_t pptthh__aattttrr__nneeww(void);
           This returns a new _u_n_b_o_u_n_d attribute object. An
           implicit _p_t_h___a_t_t_r___i_n_i_t_(_) is done on it. Any queries on
           this object just fetch stored attributes from it.  And
           attribute modifications just change the stored
           attributes.  Use such attribute objects to pre-
           configure attributes for to be spawned threads.

       int pptthh__aattttrr__iinniitt(pth_attr_t _a_t_t_r);
           This initializes an attribute object _a_t_t_r to the
           default values: "PTH_ATTR_PRIO" := "PTH_PRIO_STD",
           "PTH_ATTR_NAME" := `"unknown"', "PTH_ATTR_DISPATCHES"
           := 0, "PTH_ATTR_JOINABLE" := "TRUE",
           "PTH_ATTR_CANCELSTATE" := "PTH_CANCEL_DEFAULT",
           "PTH_ATTR_STACK_SIZE" := 64*1024 and
           "PTH_ATTR_STACK_ADDR" := "NULL". All other
           "PTH_ATTR_*" attributes are read-only attributes and
           don't receive default values in _a_t_t_r, because they
           exists only for bounded attribute objects.

       int pptthh__aattttrr__sseett(pth_attr_t _a_t_t_r, int _f_i_e_l_d, ...);
           This sets the attribute field _f_i_e_l_d in _a_t_t_r to a value



08-Jun-2006               GNU Pth 2.0.7                        14





pth(3)                 GNU Portable Threads                pth(3)


           specified as an additional argument on the variable
           argument list. The following attribute _f_i_e_l_d_s and
           argument pairs can be used:

            PTH_ATTR_PRIO           int
            PTH_ATTR_NAME           char *
            PTH_ATTR_DISPATCHES     int
            PTH_ATTR_JOINABLE       int
            PTH_ATTR_CANCEL_STATE   unsigned int
            PTH_ATTR_STACK_SIZE     unsigned int
            PTH_ATTR_STACK_ADDR     char *

       int pptthh__aattttrr__ggeett(pth_attr_t _a_t_t_r, int _f_i_e_l_d, ...);
           This retrieves the attribute field _f_i_e_l_d in _a_t_t_r and
           stores its value in the variable specified through a
           pointer in an additional argument on the variable
           argument list. The following _f_i_e_l_d_s and argument pairs
           can be used:

            PTH_ATTR_PRIO           int *
            PTH_ATTR_NAME           char **
            PTH_ATTR_DISPATCHES     int *
            PTH_ATTR_JOINABLE       int *
            PTH_ATTR_CANCEL_STATE   unsigned int *
            PTH_ATTR_STACK_SIZE     unsigned int *
            PTH_ATTR_STACK_ADDR     char **
            PTH_ATTR_TIME_SPAWN     pth_time_t *
            PTH_ATTR_TIME_LAST      pth_time_t *
            PTH_ATTR_TIME_RAN       pth_time_t *
            PTH_ATTR_START_FUNC     void *(**)(void *)
            PTH_ATTR_START_ARG      void **
            PTH_ATTR_STATE          pth_state_t *
            PTH_ATTR_EVENTS         pth_event_t *
            PTH_ATTR_BOUND          int *

       int pptthh__aattttrr__ddeessttrrooyy(pth_attr_t _a_t_t_r);
           This destroys a attribute object _a_t_t_r. After this _a_t_t_r
           is no longer a valid attribute object.

       TThhrreeaadd CCoonnttrrooll

       The following functions control the threading itself and
       make up the main API of the PPtthh library.

       pth_t pptthh__ssppaawwnn(pth_attr_t _a_t_t_r, void *(*_e_n_t_r_y)(void *),
       void *_a_r_g);
           This spawns a new thread with the attributes given in
           _a_t_t_r (or "PTH_ATTR_DEFAULT" for default attributes -
           which means that thread priority, joinability and
           cancel state are inherited from the current thread)
           with the starting point at routine _e_n_t_r_y; the dispatch
           count is not inherited from the current thread if _a_t_t_r
           is not specified - rather, it is initialized to zero.
           This entry routine is called as `pth_exit(_e_n_t_r_y(_a_r_g))'



08-Jun-2006               GNU Pth 2.0.7                        15





pth(3)                 GNU Portable Threads                pth(3)


           inside the new thread unit, i.e., _e_n_t_r_y's return value
           is fed to an implicit _p_t_h___e_x_i_t(3). So the thread can
           also exit by just returning. Nevertheless the thread
           can also exit explicitly at any time by calling
           _p_t_h___e_x_i_t(3). But keep in mind that calling the POSIX
           function _e_x_i_t(3) still terminates the complete process
           and not just the current thread.

           There is no PPtthh-internal limit on the number of
           threads one can spawn, except the limit implied by the
           available virtual memory. PPtthh internally keeps track
           of thread in dynamic data structures. The function
           returns "NULL" on error.

       int pptthh__oonnccee(pth_once_t *_c_t_r_l_v_a_r, void (*_f_u_n_c)(void *),
       void *_a_r_g);
           This is a convenience function which uses a control
           variable of type "pth_once_t" to make sure a
           constructor function _f_u_n_c is called only once as
           `_f_u_n_c(_a_r_g)' in the system. In other words: Only the
           first call to _p_t_h___o_n_c_e(3) by any thread in the system
           succeeds. The variable referenced via _c_t_r_l_v_a_r should
           be declared as `"pth_once_t" _v_a_r_i_a_b_l_e_-_n_a_m_e =
           "PTH_ONCE_INIT";' before calling this function.

       pth_t pptthh__sseellff(void);
           This just returns the unique thread handle of the
           currently running thread.  This handle itself has to
           be treated as an opaque entity by the application.
           It's usually used as an argument to other functions
           who require an argument of type "pth_t".

       int pptthh__ssuussppeenndd(pth_t _t_i_d);
           This suspends a thread _t_i_d until it is manually
           resumed again via _p_t_h___r_e_s_u_m_e(3). For this, the thread
           is moved to the SSUUSSPPEENNDDEEDD queue and this way is
           completely out of the scheduler's event handling and
           thread dispatching scope. Suspending the current
           thread is not allowed.  The function returns "TRUE" on
           success and "FALSE" on errors.

       int pptthh__rreessuummee(pth_t _t_i_d);
           This function resumes a previously suspended thread
           _t_i_d, i.e. _t_i_d has to stay on the SSUUSSPPEENNDDEEDD queue. The
           thread is moved to the NNEEWW, RREEAADDYY or WWAAIITTIINNGG queue
           (dependent on what its state was when the
           _p_t_h___s_u_s_p_e_n_d(3) call were made) and this way again
           enters the event handling and thread dispatching scope
           of the scheduler. The function returns "TRUE" on
           success and "FALSE" on errors.

       int pptthh__rraaiissee(pth_t _t_i_d, int _s_i_g)
           This function raises a signal for delivery to thread
           _t_i_d only.  When one just raises a signal via _r_a_i_s_e(3)



08-Jun-2006               GNU Pth 2.0.7                        16





pth(3)                 GNU Portable Threads                pth(3)


           or _k_i_l_l(2), its delivered to an arbitrary thread which
           has this signal not blocked.  With _p_t_h___r_a_i_s_e(3) one
           can send a signal to a thread and its guarantees that
           only this thread gets the signal delivered. But keep
           in mind that nevertheless the signals _a_c_t_i_o_n is still
           configured _p_r_o_c_e_s_s-wide.  When _s_i_g is 0 plain thread
           checking is performed, i.e., `"pth_raise(tid, 0)"'
           returns "TRUE" when thread _t_i_d still exists in the PPTTHH
           system but doesn't send any signal to it.

       int pptthh__yyiieelldd(pth_t _t_i_d);
           This explicitly yields back the execution control to
           the scheduler thread.  Usually the execution is
           implicitly transferred back to the scheduler when a
           thread waits for an event. But when a thread has to do
           larger CPU bursts, it can be reasonable to interrupt
           it explicitly by doing a few _p_t_h___y_i_e_l_d(3) calls to
           give other threads a chance to execute, too.  This
           obviously is the cooperating part of PPtthh.  A thread
           _h_a_s _n_o_t to yield execution, of course. But when you
           want to program a server application with good
           response times the threads should be cooperative,
           i.e., when they should split their CPU bursts into
           smaller units with this call.

           Usually one specifies _t_i_d as "NULL" to indicate to the
           scheduler that it can freely decide which thread to
           dispatch next.  But if one wants to indicate to the
           scheduler that a particular thread should be favored
           on the next dispatching step, one can specify this
           thread explicitly. This allows the usage of the old
           concept of _c_o_r_o_u_t_i_n_e_s where a thread/routine switches
           to a particular cooperating thread. If _t_i_d is not
           "NULL" and points to a _n_e_w or _r_e_a_d_y thread, it is
           guaranteed that this thread receives execution control
           on the next dispatching step. If _t_i_d is in a different
           state (that is, not in "PTH_STATE_NEW" or
           "PTH_STATE_READY") an error is reported.

           The function usually returns "TRUE" for success and
           only "FALSE" (with "errno" set to "EINVAL") if _t_i_d
           specified an invalid or still not new or ready thread.

       int pptthh__nnaapp(pth_time_t _n_a_p_t_i_m_e);
           This functions suspends the execution of the current
           thread until _n_a_p_t_i_m_e is elapsed. _n_a_p_t_i_m_e is of type
           "pth_time_t" and this way has theoretically a
           resolution of one microsecond. In practice you should
           neither rely on this nor that the thread is awakened
           exactly after _n_a_p_t_i_m_e has elapsed. It's only
           guarantees that the thread will sleep at least
           _n_a_p_t_i_m_e. But because of the non-preemptive nature of
           PPtthh it can last longer (when another thread kept the
           CPU for a long time). Additionally the resolution is



08-Jun-2006               GNU Pth 2.0.7                        17





pth(3)                 GNU Portable Threads                pth(3)


           dependent of the implementation of timers by the
           operating system and these usually have only a
           resolution of 10 microseconds or larger. But usually
           this isn't important for an application unless it
           tries to use this facility for real time tasks.

       int pptthh__wwaaiitt(pth_event_t _e_v);
           This is the link between the scheduler and the event
           facility (see below for the various _p_t_h___e_v_e_n_t___x_x_x_(_)
           functions). It's modeled like _s_e_l_e_c_t(2), i.e., one
           gives this function one or more events (in the event
           ring specified by _e_v) on which the current thread
           wants to wait. The scheduler awakes the thread when
           one ore more of them occurred or failed after tagging
           them as such. The _e_v argument is a _p_o_i_n_t_e_r to an event
           ring which isn't changed except for the tagging.
           _p_t_h___w_a_i_t(3) returns the number of occurred or failed
           events and the application can use _p_t_h___e_v_e_n_t___s_t_a_t_u_s(3)
           to test which events occurred or failed.

       int pptthh__ccaanncceell(pth_t _t_i_d);
           This cancels a thread _t_i_d. How the cancellation is
           done depends on the cancellation state of _t_i_d which
           the thread can configure itself. When its state is
           "PTH_CANCEL_DISABLE" a cancellation request is just
           made pending.  When it is "PTH_CANCEL_ENABLE" it
           depends on the cancellation type what is performed.
           When its "PTH_CANCEL_DEFERRED" again the cancellation
           request is just made pending. But when its
           "PTH_CANCEL_ASYNCHRONOUS" the thread is immediately
           canceled before _p_t_h___c_a_n_c_e_l(3) returns. The effect of a
           thread cancellation is equal to implicitly forcing the
           thread to call `"pth_exit(PTH_CANCELED)"' at one of
           his cancellation points.  In PPtthh thread enter a
           cancellation point either explicitly via
           _p_t_h___c_a_n_c_e_l___p_o_i_n_t(3) or implicitly by waiting for an
           event.

       int pptthh__aabboorrtt(pth_t _t_i_d);
           This is the cruel way to cancel a thread _t_i_d. When
           it's already dead and waits to be joined it just joins
           it (via `"pth_join("_t_i_d", NULL)"') and this way kicks
           it out of the system.  Else it forces the thread to be
           not joinable and to allow asynchronous cancellation
           and then cancels it via `"pth_cancel("_t_i_d")"'.

       int pptthh__jjooiinn(pth_t _t_i_d, void **_v_a_l_u_e);
           This joins the current thread with the thread
           specified via _t_i_d.  It first suspends the current
           thread until the _t_i_d thread has terminated. Then it is
           awakened and stores the value of _t_i_d's _p_t_h___e_x_i_t(3)
           call into *_v_a_l_u_e (if _v_a_l_u_e and not "NULL") and returns
           to the caller. A thread can be joined only when it has
           the attribute "PTH_ATTR_JOINABLE" set to "TRUE" (the



08-Jun-2006               GNU Pth 2.0.7                        18





pth(3)                 GNU Portable Threads                pth(3)


           default). A thread can only be joined once, i.e.,
           after the _p_t_h___j_o_i_n(3) call the thread _t_i_d is
           completely removed from the system.

       void pptthh__eexxiitt(void *_v_a_l_u_e);
           This terminates the current thread. Whether it's
           immediately removed from the system or inserted into
           the dead queue of the scheduler depends on its join
           type which was specified at spawning time. If it has
           the attribute "PTH_ATTR_JOINABLE" set to "FALSE", it's
           immediately removed and _v_a_l_u_e is ignored. Else the
           thread is inserted into the dead queue and _v_a_l_u_e
           remembered for a subsequent _p_t_h___j_o_i_n(3) call by
           another thread.

       UUttiilliittiieess

       Utility functions.

       int pptthh__ffddmmooddee(int _f_d, int _m_o_d_e);
           This switches the non-blocking mode flag on file
           descriptor _f_d.  The argument _m_o_d_e can be
           "PTH_FDMODE_BLOCK" for switching _f_d into blocking I/O
           mode, "PTH_FDMODE_NONBLOCK" for switching _f_d into non-
           blocking I/O mode or "PTH_FDMODE_POLL" for just
           polling the current mode. The current mode is returned
           (either "PTH_FDMODE_BLOCK" or "PTH_FDMODE_NONBLOCK")
           or "PTH_FDMODE_ERROR" on error. Keep in mind that
           since PPtthh 1.1 there is no longer a requirement to
           manually switch a file descriptor into non-blocking
           mode in order to use it. This is automatically done
           temporarily inside PPtthh.  Instead when you now switch a
           file descriptor explicitly into non-blocking mode,
           _p_t_h___r_e_a_d(3) or _p_t_h___w_r_i_t_e(3) will never block the
           current thread.

       pth_time_t pptthh__ttiimmee(long _s_e_c, long _u_s_e_c);
           This is a constructor for a "pth_time_t" structure
           which is a convenient function to avoid temporary
           structure values. It returns a _p_t_h___t_i_m_e___t structure
           which holds the absolute time value specified by _s_e_c
           and _u_s_e_c.

       pth_time_t pptthh__ttiimmeeoouutt(long _s_e_c, long _u_s_e_c);
           This is a constructor for a "pth_time_t" structure
           which is a convenient function to avoid temporary
           structure values.  It returns a _p_t_h___t_i_m_e___t structure
           which holds the absolute time value calculated by
           adding _s_e_c and _u_s_e_c to the current time.

       Sfdisc_t *pptthh__ssffiiooddiisscc(void);
           This functions is always available, but only
           reasonably usable when PPtthh was built with SSffiioo support
           ("--with-sfio" option) and "PTH_EXT_SFIO" is then



08-Jun-2006               GNU Pth 2.0.7                        19





pth(3)                 GNU Portable Threads                pth(3)


           defined by "pth.h". It is useful for applications
           which want to use the comprehensive SSffiioo I/O library
           with the PPtthh threading library. Then this function can
           be used to get an SSffiioo discipline structure
           ("Sfdisc_t") which can be pushed onto SSffiioo streams
           ("Sfio_t") in order to let this stream use
           _p_t_h___r_e_a_d(3)/_p_t_h___w_r_i_t_e(2) instead of _r_e_a_d(2)/_w_r_i_t_e(2).
           The benefit is that this way I/O on the SSffiioo stream
           does only block the current thread instead of the
           whole process. The application has to _f_r_e_e(3) the
           "Sfdisc_t" structure when it is no longer needed. The
           Sfio package can be found at
           http://www.research.att.com/sw/tools/sfio/.

       CCaanncceellllaattiioonn MMaannaaggeemmeenntt

       PPtthh supports POSIX style thread cancellation via
       _p_t_h___c_a_n_c_e_l(3) and the following two related functions:

       void pptthh__ccaanncceell__ssttaattee(int _n_e_w_s_t_a_t_e, int *_o_l_d_s_t_a_t_e);
           This manages the cancellation state of the current
           thread.  When _o_l_d_s_t_a_t_e is not "NULL" the function
           stores the old cancellation state under the variable
           pointed to by _o_l_d_s_t_a_t_e. When _n_e_w_s_t_a_t_e is not 0 it sets
           the new cancellation state. _o_l_d_s_t_a_t_e is created before
           _n_e_w_s_t_a_t_e is set.  A state is a combination of
           "PTH_CANCEL_ENABLE" or "PTH_CANCEL_DISABLE" and
           "PTH_CANCEL_DEFERRED" or "PTH_CANCEL_ASYNCHRONOUS".
           "PTH_CANCEL_ENABLE|PTH_CANCEL_DEFERRED" (or
           "PTH_CANCEL_DEFAULT") is the default state where
           cancellation is possible but only at cancellation
           points.  Use "PTH_CANCEL_DISABLE" to complete disable
           cancellation for a thread and
           "PTH_CANCEL_ASYNCHRONOUS" for allowing asynchronous
           cancellations, i.e., cancellations which can happen at
           any time.

       void pptthh__ccaanncceell__ppooiinntt(void);
           This explicitly enter a cancellation point. When the
           current cancellation state is "PTH_CANCEL_DISABLE" or
           no cancellation request is pending, this has no side-
           effect and returns immediately. Else it calls
           `"pth_exit(PTH_CANCELED)"'.

       EEvveenntt HHaannddlliinngg

       PPtthh has a very flexible event facility which is linked
       into the scheduler through the _p_t_h___w_a_i_t(3) function. The
       following functions provide the handling of event rings.

       pth_event_t pptthh__eevveenntt(unsigned long _s_p_e_c, ...);
           This creates a new event ring consisting of a single
           initial event.  The type of the generated event is
           specified by _s_p_e_c. The following types are available:



08-Jun-2006               GNU Pth 2.0.7                        20





pth(3)                 GNU Portable Threads                pth(3)


           "PTH_EVENT_FD"
               This is a file descriptor event. One or more of
               "PTH_UNTIL_FD_READABLE", "PTH_UNTIL_FD_WRITEABLE"
               or "PTH_UNTIL_FD_EXCEPTION" have to be OR-ed into
               _s_p_e_c to specify on which state of the file
               descriptor you want to wait.  The file descriptor
               itself has to be given as an additional argument.
               Example:
               `"pth_event(PTH_EVENT_FD|PTH_UNTIL_FD_READABLE,
               fd)"'.

           "PTH_EVENT_SELECT"
               This is a multiple file descriptor event modeled
               directly after the _s_e_l_e_c_t(2) call (actually it is
               also used to implement _p_t_h___s_e_l_e_c_t(3) internally).
               It's a convenient way to wait for a large set of
               file descriptors at once and at each file
               descriptor for a different type of state.
               Additionally as a nice side-effect one receives
               the number of file descriptors which causes the
               event to be occurred (using BSD semantics, i.e.,
               when a file descriptor occurred in two sets it's
               counted twice). The arguments correspond directly
               to the _s_e_l_e_c_t(2) function arguments except that
               there is no timeout argument (because timeouts
               already can be handled via "PTH_EVENT_TIME"
               events).

               Example: `"pth_event(PTH_EVENT_SELECT, &rc, nfd,
               rfds, wfds, efds)"' where "rc" has to be of type
               `"int *"', "nfd" has to be of type `"int"' and
               "rfds", "wfds" and "efds" have to be of type
               `"fd_set *"' (see _s_e_l_e_c_t(2)). The number of
               occurred file descriptors are stored in "rc".

           "PTH_EVENT_SIGS"
               This is a signal set event. The two additional
               arguments have to be a pointer to a signal set
               (type `"sigset_t *"') and a pointer to a signal
               number variable (type `"int *"').  This event
               waits until one of the signals in the signal set
               occurred.  As a result the occurred signal number
               is stored in the second additional argument. Keep
               in mind that the PPtthh scheduler doesn't block
               signals automatically.  So when you want to wait
               for a signal with this event you've to block it
               via _s_i_g_p_r_o_c_m_a_s_k(2) or it will be delivered without
               your notice. Example: `"sigemptyset(&set);
               sigaddset(&set, SIGINT); pth_event(PTH_EVENT_SIG,
               &set, &sig);"'.

           "PTH_EVENT_TIME"
               This is a time point event. The additional
               argument has to be of type "pth_time_t" (usually



08-Jun-2006               GNU Pth 2.0.7                        21





pth(3)                 GNU Portable Threads                pth(3)


               on-the-fly generated via _p_t_h___t_i_m_e(3)). This events
               waits until the specified time point has elapsed.
               Keep in mind that the value is an absolute time
               point and not an offset. When you want to wait for
               a specified amount of time, you've to add the
               current time to the offset (usually on-the-fly
               achieved via _p_t_h___t_i_m_e_o_u_t(3)).  Example:
               `"pth_event(PTH_EVENT_TIME, pth_timeout(2,0))"'.

           "PTH_EVENT_MSG"
               This is a message port event. The additional
               argument has to be of type "pth_msgport_t". This
               events waits until one or more messages were
               received on the specified message port.  Example:
               `"pth_event(PTH_EVENT_MSG, mp)"'.

           "PTH_EVENT_TID"
               This is a thread event. The additional argument
               has to be of type "pth_t".  One of
               "PTH_UNTIL_TID_NEW", "PTH_UNTIL_TID_READY",
               "PTH_UNTIL_TID_WAITING" or "PTH_UNTIL_TID_DEAD"
               has to be OR-ed into _s_p_e_c to specify on which
               state of the thread you want to wait.  Example:
               `"pth_event(PTH_EVENT_TID|PTH_UNTIL_TID_DEAD,
               tid)"'.

           "PTH_EVENT_FUNC"
               This is a custom callback function event. Three
               additional arguments have to be given with the
               following types: `"int (*)(void *)"', `"void *"'
               and `"pth_time_t"'. The first is a function
               pointer to a check function and the second
               argument is a user-supplied context value which is
               passed to this function. The scheduler calls this
               function on a regular basis (on his own scheduler
               stack, so be very careful!) and the thread is kept
               sleeping while the function returns "FALSE". Once
               it returned "TRUE" the thread will be awakened.
               The check interval is defined by the third
               argument, i.e., the check function is polled again
               not until this amount of time elapsed. Example:
               `"pth_event(PTH_EVENT_FUNC, func, arg,
               pth_time(0,500000))"'.

           "PTH_EVENT_SEM"
               This is a semaphore event. It waits for a
               semaphore, until it can be decremented. By default
               1 is used for this, with the flag
               "PTH_UNTIL_COUNT" other values can be used. If the
               flag "PTH_UNTIL_DECREMENT" is used, the semaphore
               value is decremented (so the lock is obtained),
               else the event is signaled, if it would be
               possible. Examples:




08-Jun-2006               GNU Pth 2.0.7                        22





pth(3)                 GNU Portable Threads                pth(3)


               *
               pth_event(PTH_EVENT_SEM|PTH_UNTIL_DECREMENT|PTH_UNTIL_COUNT,
               &sem,2): event waits, utils the value of the
               semaphore is >= 2 and subtracts then two from it

               * pth_event(PTH_EVENT_SEM|PTH_UNTIL_COUNT,
               &sem,2): event waits, util the value of the
               semaphore is >= 2

               * pth_event(PTH_EVENT_SEM|PTH_UNTIL_DECREMENT,
               &sem): event waits, util the value of the
               semaphore is >= 1 and subtracts then 1 from it

               * pth_event(PTH_EVENT_SEM, &sem): event waits,
               util the value of the semaphore is >= 1

       unsigned long pptthh__eevveenntt__ttyyppeeooff(pth_event_t _e_v);
           This returns the type of event _e_v. It's a combination
           of the describing "PTH_EVENT_XX" and "PTH_UNTIL_XX"
           value. This is especially useful to know which
           arguments have to be supplied to the
           _p_t_h___e_v_e_n_t___e_x_t_r_a_c_t(3) function.

       int pptthh__eevveenntt__eexxttrraacctt(pth_event_t _e_v, ...);
           When _p_t_h___e_v_e_n_t(3) is treated like _s_p_r_i_n_t_f(3), then
           this function is _s_s_c_a_n_f(3), i.e., it is the inverse
           operation of _p_t_h___e_v_e_n_t(3). This means that it can be
           used to extract the ingredients of an event.  The
           ingredients are stored into variables which are given
           as pointers on the variable argument list.  Which
           pointers have to be present depends on the event type
           and has to be determined by the caller before via
           _p_t_h___e_v_e_n_t___t_y_p_e_o_f(3).

           To make it clear, when you constructed _e_v via `"ev =
           pth_event(PTH_EVENT_FD, fd);"' you have to extract it
           via `"pth_event_extract(ev, &fd)"', etc. For multiple
           arguments of an event the order of the pointer
           arguments is the same as for _p_t_h___e_v_e_n_t(3). But always
           keep in mind that you have to always supply _p_o_i_n_t_e_r_s
           to _v_a_r_i_a_b_l_e_s and these variables have to be of the
           same type as the argument of _p_t_h___e_v_e_n_t(3) required.

       pth_event_t pptthh__eevveenntt__ccoonnccaatt(pth_event_t _e_v, ...);
           This concatenates one or more additional event rings
           to the event ring _e_v and returns _e_v. The end of the
           argument list has to be marked with a "NULL" argument.
           Use this function to create real events rings out of
           the single-event rings created by _p_t_h___e_v_e_n_t(3).

       pth_event_t pptthh__eevveenntt__iissoollaattee(pth_event_t _e_v);
           This isolates the event _e_v from possibly appended
           events in the event ring.  When in _e_v only one event
           exists, this returns "NULL". When remaining events



08-Jun-2006               GNU Pth 2.0.7                        23





pth(3)                 GNU Portable Threads                pth(3)


           exists, they form a new event ring which is returned.

       pth_event_t pptthh__eevveenntt__wwaallkk(pth_event_t _e_v, int _d_i_r_e_c_t_i_o_n);
           This walks to the next (when _d_i_r_e_c_t_i_o_n is
           "PTH_WALK_NEXT") or previews (when _d_i_r_e_c_t_i_o_n is
           "PTH_WALK_PREV") event in the event ring _e_v and
           returns this new reached event. Additionally
           "PTH_UNTIL_OCCURRED" can be OR-ed into _d_i_r_e_c_t_i_o_n to
           walk to the next/previous occurred event in the ring
           _e_v.

       pth_status_t pptthh__eevveenntt__ssttaattuuss(pth_event_t _e_v);
           This returns the status of event _e_v. This is a fast
           operation because only a tag on _e_v is checked which
           was either set or still not set by the scheduler. In
           other words: This doesn't check the event itself, it
           just checks the last knowledge of the scheduler. The
           possible returned status codes are:
           "PTH_STATUS_PENDING" (event is still pending),
           "PTH_STATUS_OCCURRED" (event successfully occurred),
           "PTH_STATUS_FAILED" (event failed).

       int pptthh__eevveenntt__ffrreeee(pth_event_t _e_v, int _m_o_d_e);
           This deallocates the event _e_v (when _m_o_d_e is
           "PTH_FREE_THIS") or all events appended to the event
           ring under _e_v (when _m_o_d_e is "PTH_FREE_ALL").

       KKeeyy--BBaasseedd SSttoorraaggee

       The following functions provide thread-local storage
       through unique keys similar to the POSIX PPtthhrreeaadd API. Use
       this for thread specific global data.

       int pptthh__kkeeyy__ccrreeaattee(pth_key_t *_k_e_y, void (*_f_u_n_c)(void *));
           This created a new unique key and stores it in _k_e_y.
           Additionally _f_u_n_c can specify a destructor function
           which is called on the current threads termination
           with the _k_e_y.

       int pptthh__kkeeyy__ddeelleettee(pth_key_t _k_e_y);
           This explicitly destroys a key _k_e_y.

       int pptthh__kkeeyy__sseettddaattaa(pth_key_t _k_e_y, const void *_v_a_l_u_e);
           This stores _v_a_l_u_e under _k_e_y.

       void *pptthh__kkeeyy__ggeettddaattaa(pth_key_t _k_e_y);
           This retrieves the value under _k_e_y.

       MMeessssaaggee PPoorrtt CCoommmmuunniiccaattiioonn

       The following functions provide message ports which can be
       used for efficient and flexible inter-thread
       communication.




08-Jun-2006               GNU Pth 2.0.7                        24





pth(3)                 GNU Portable Threads                pth(3)


       pth_msgport_t pptthh__mmssggppoorrtt__ccrreeaattee(const char *_n_a_m_e);
           This returns a pointer to a new message port. If name
           _n_a_m_e is not "NULL", the _n_a_m_e can be used by other
           threads via _p_t_h___m_s_g_p_o_r_t___f_i_n_d(3) to find the message
           port in case they do not know directly the pointer to
           the message port.

       void pptthh__mmssggppoorrtt__ddeessttrrooyy(pth_msgport_t _m_p);
           This destroys a message port _m_p. Before all pending
           messages on it are replied to their origin message
           port.

       pth_msgport_t pptthh__mmssggppoorrtt__ffiinndd(const char *_n_a_m_e);
           This finds a message port in the system by _n_a_m_e and
           returns the pointer to it.

       int pptthh__mmssggppoorrtt__ppeennddiinngg(pth_msgport_t _m_p);
           This returns the number of pending messages on message
           port _m_p.

       int pptthh__mmssggppoorrtt__ppuutt(pth_msgport_t _m_p, pth_message_t *_m);
           This puts (or sends) a message _m to message port _m_p.

       pth_message_t *pptthh__mmssggppoorrtt__ggeett(pth_msgport_t _m_p);
           This gets (or receives) the top message from message
           port _m_p.  Incoming messages are always kept in a
           queue, so there can be more pending messages, of
           course.

       int pptthh__mmssggppoorrtt__rreeppllyy(pth_message_t *_m);
           This replies a message _m to the message port of the
           sender.

       TThhrreeaadd CClleeaannuuppss

       Per-thread cleanup functions.

       int pptthh__cclleeaannuupp__ppuusshh(void (*_h_a_n_d_l_e_r)(void *), void *_a_r_g);
           This pushes the routine _h_a_n_d_l_e_r onto the stack of
           cleanup routines for the current thread.  These
           routines are called in LIFO order when the thread
           terminates.

       int pptthh__cclleeaannuupp__ppoopp(int _e_x_e_c_u_t_e);
           This pops the top-most routine from the stack of
           cleanup routines for the current thread. When _e_x_e_c_u_t_e
           is "TRUE" the routine is additionally called.

       PPrroocceessss FFoorrkkiinngg

       The following functions provide some special support for
       process forking situations inside the threading
       environment.




08-Jun-2006               GNU Pth 2.0.7                        25





pth(3)                 GNU Portable Threads                pth(3)


       int pptthh__aattffoorrkk__ppuusshh(void (*_p_r_e_p_a_r_e)(void *), void (*)(void
       *_p_a_r_e_n_t), void (*)(void *_c_h_i_l_d), void *_a_r_g);
           This function declares forking handlers to be called
           before and after _p_t_h___f_o_r_k(3), in the context of the
           thread that called _p_t_h___f_o_r_k(3). The _p_r_e_p_a_r_e handler is
           called before _f_o_r_k(2) processing commences. The _p_a_r_e_n_t
           handler is called   after _f_o_r_k(2) processing completes
           in the parent process.  The _c_h_i_l_d handler is called
           after _f_o_r_k(2) processing completed in the child
           process. If no handling is desired at one or more of
           these three points, the corresponding handler can be
           given as "NULL".  Each handler is called with _a_r_g as
           the argument.

           The order of calls to _p_t_h___a_t_f_o_r_k___p_u_s_h(3) is
           significant. The _p_a_r_e_n_t and _c_h_i_l_d handlers are called
           in the order in which they were established by calls
           to _p_t_h___a_t_f_o_r_k___p_u_s_h(3), i.e., FIFO. The _p_r_e_p_a_r_e fork
           handlers are called in the opposite order, i.e., LIFO.

       int pptthh__aattffoorrkk__ppoopp(void);
           This removes the top-most handlers on the forking
           handler stack which were established with the last
           _p_t_h___a_t_f_o_r_k___p_u_s_h(3) call. It returns "FALSE" when no
           more handlers couldn't be removed from the stack.

       pid_t pptthh__ffoorrkk(void);
           This is a variant of _f_o_r_k(2) with the difference that
           the current thread only is forked into a separate
           process, i.e., in the parent process nothing changes
           while in the child process all threads are gone except
           for the scheduler and the calling thread. When you
           really want to duplicate all threads in the current
           process you should use _f_o_r_k(2) directly. But this is
           usually not reasonable. Additionally this function
           takes care of forking handlers as established by
           _p_t_h___f_o_r_k___p_u_s_h(3).

       SSyynncchhrroonniizzaattiioonn

       The following functions provide synchronization support
       via mutual exclusion locks (mmuutteexx), read-write locks
       (rrwwlloocckk), condition variables (ccoonndd) and barriers
       (bbaarrrriieerr). Keep in mind that in a non-preemptive threading
       system like PPtthh this might sound unnecessary at the first
       look, because a thread isn't interrupted by the system.
       Actually when you have a critical code section which
       doesn't contain any _p_t_h___x_x_x_(_) functions, you don't need
       any mutex to protect it, of course.

       But when your critical code section contains any _p_t_h___x_x_x_(_)
       function the chance is high that these temporarily switch
       to the scheduler. And this way other threads can make
       progress and enter your critical code section, too.  This



08-Jun-2006               GNU Pth 2.0.7                        26





pth(3)                 GNU Portable Threads                pth(3)


       is especially true for critical code sections which
       implicitly or explicitly use the event mechanism.

       int pptthh__mmuutteexx__iinniitt(pth_mutex_t *_m_u_t_e_x);
           This dynamically initializes a mutex variable of type
           `"pth_mutex_t"'.  Alternatively one can also use
           static initialization via `"pth_mutex_t mutex =
           PTH_MUTEX_INIT"'.

       int pptthh__mmuutteexx__aaccqquuiirree(pth_mutex_t *_m_u_t_e_x, int _t_r_y,
       pth_event_t _e_v);
           This acquires a mutex _m_u_t_e_x.  If the mutex is already
           locked by another thread, the current threads
           execution is suspended until the mutex is unlocked
           again or additionally the extra events in _e_v occurred
           (when _e_v is not "NULL").  Recursive locking is
           explicitly supported, i.e., a thread is allowed to
           acquire a mutex more than once before its released.
           But it then also has be released the same number of
           times until the mutex is again lockable by others.
           When _t_r_y is "TRUE" this function never suspends
           execution. Instead it returns "FALSE" with "errno" set
           to "EBUSY".

       int pptthh__mmuutteexx__rreelleeaassee(pth_mutex_t *_m_u_t_e_x);
           This decrements the recursion locking count on _m_u_t_e_x
           and when it is zero it releases the mutex _m_u_t_e_x.

       int pptthh__rrwwlloocckk__iinniitt(pth_rwlock_t *_r_w_l_o_c_k);
           This dynamically initializes a read-write lock
           variable of type `"pth_rwlock_t"'.  Alternatively one
           can also use static initialization via `"pth_rwlock_t
           rwlock = PTH_RWLOCK_INIT"'.

       int pptthh__rrwwlloocckk__aaccqquuiirree(pth_rwlock_t *_r_w_l_o_c_k, int _o_p, int
       _t_r_y, pth_event_t _e_v);
           This acquires a read-only (when _o_p is "PTH_RWLOCK_RD")
           or a read-write (when _o_p is "PTH_RWLOCK_RW") lock
           _r_w_l_o_c_k. When the lock is only locked by other threads
           in read-only mode, the lock succeeds.  But when one
           thread holds a read-write lock, all locking attempts
           suspend the current thread until this lock is released
           again. Additionally in _e_v events can be given to let
           the locking timeout, etc. When _t_r_y is "TRUE" this
           function never suspends execution. Instead it returns
           "FALSE" with "errno" set to "EBUSY".

       int pptthh__rrwwlloocckk__rreelleeaassee(pth_rwlock_t *_r_w_l_o_c_k);
           This releases a previously acquired (read-only or
           read-write) lock.

       int pptthh__ccoonndd__iinniitt(pth_cond_t *_c_o_n_d);
           This dynamically initializes a condition variable
           variable of type `"pth_cond_t"'.  Alternatively one



08-Jun-2006               GNU Pth 2.0.7                        27





pth(3)                 GNU Portable Threads                pth(3)


           can also use static initialization via `"pth_cond_t
           cond = PTH_COND_INIT"'.

       int pptthh__ccoonndd__aawwaaiitt(pth_cond_t *_c_o_n_d, pth_mutex_t *_m_u_t_e_x,
       pth_event_t _e_v);
           This awaits a condition situation. The caller has to
           follow the semantics of the POSIX condition variables:
           _m_u_t_e_x has to be acquired before this function is
           called. The execution of the current thread is then
           suspended either until the events in _e_v occurred (when
           _e_v is not "NULL") or _c_o_n_d was notified by another
           thread via _p_t_h___c_o_n_d___n_o_t_i_f_y(3).  While the thread is
           waiting, _m_u_t_e_x is released. Before it returns _m_u_t_e_x is
           reacquired.

       int pptthh__ccoonndd__nnoottiiffyy(pth_cond_t *_c_o_n_d, int _b_r_o_a_d_c_a_s_t);
           This notified one or all threads which are waiting on
           _c_o_n_d.  When _b_r_o_a_d_c_a_s_t is "TRUE" all thread are
           notified, else only a single (unspecified) one.

       int pptthh__bbaarrrriieerr__iinniitt(pth_barrier_t *_b_a_r_r_i_e_r, int
       _t_h_r_e_s_h_o_l_d);
           This dynamically initializes a barrier variable of
           type `"pth_barrier_t"'.  Alternatively one can also
           use static initialization via `"pth_barrier_t barrier
           = PTH_BARRIER_INIT("_t_h_r_e_a_d_h_o_l_d")"'.

       int pptthh__bbaarrrriieerr__rreeaacchh(pth_barrier_t *_b_a_r_r_i_e_r);
           This function reaches a barrier _b_a_r_r_i_e_r. If this is
           the last thread (as specified by _t_h_r_e_s_h_o_l_d on init of
           _b_a_r_r_i_e_r) all threads are awakened.  Else the current
           thread is suspended until the last thread reached the
           barrier and this way awakes all threads. The function
           returns (beside "FALSE" on error) the value "TRUE" for
           any thread which neither reached the barrier as the
           first nor the last thread; "PTH_BARRIER_HEADLIGHT" for
           the thread which reached the barrier as the first
           thread and "PTH_BARRIER_TAILLIGHT" for the thread
           which reached the barrier as the last thread.

       SSeemmaapphhoorree ssuuppppoorrtt

       The interface provides functions to set/get the value of a
       semaphore, increment it with arbitrary values, wait, until
       the value becomes bigger than a given value (without or
       with decrementing, if the condition becomes true.

       The data-type for the semaphore is names "pth_sem_t" and
       it has an initializer like "pth_cond_t".

       int pptthh__sseemm__iinniitt(pth_sem_t *sem);
           This dynamically initializes a semaphore variable of
           type `"pth_sem_t"'.  Alternatively one can also use
           static initialization via `"pth_sem_t semaphore =



08-Jun-2006               GNU Pth 2.0.7                        28





pth(3)                 GNU Portable Threads                pth(3)


           PTH_SEM_INIT"'.

       int pptthh__sseemm__ddeecc(pth_sem_t *sem);
           waits, until the value of "sem" is >= 1 and decrement
           it.

       int pptthh__sseemm__ddeecc__vvaalluuee(pth_sem_t *sem, unsigned value);
           waits, until the value of "sem" is >= "value" and
           subtracts "value".

       int pptthh__sseemm__iinncc(pth_sem_t *sem, int notify);
           increments "sem". The scheduler is started, if
           "notify" is not null.

       int pptthh__sseemm__iinncc__vvaalluuee(pth_sem_t *sem, unsigned value, int
       notify);
           adds value to "sem". The scheduler is started, if
           "notify" is not null.

       int pptthh__sseemm__sseett__vvaalluuee(pth_sem_t *sem, unsigned value);
           sets the value of "sem" to "value".

       int pptthh__sseemm__ggeett__vvaalluuee(pth_sem_t *sem, unsigned *value);
           stores the value of "sem" in *"value".

       UUsseerr--SSppaaccee CCoonntteexxtt

       The following functions provide a stand-alone sub-API for
       user-space context switching. It internally is based on
       the same underlying machine context switching mechanism
       the threads in GGNNUU PPtthh are based on.  Hence these
       functions you can use for implementing your own simple
       user-space threads. The "pth_uctx_t" context is somewhat
       modeled after POSIX _u_c_o_n_t_e_x_t(3).

       The time required to create (via _p_t_h___u_c_t_x___m_a_k_e(3)) a user-
       space context can range from just a few microseconds up to
       a more dramatical time (depending on the machine context
       switching method which is available on the platform). On
       the other hand, the raw performance in switching the user-
       space contexts is always very good (nearly independent of
       the used machine context switching method). For instance,
       on an Intel Pentium-III CPU with 800Mhz running under
       FreeBSD 4 one usually achieves about 260,000 user-space
       context switches (via _p_t_h___u_c_t_x___s_w_i_t_c_h(3)) per second.

       int pptthh__uuccttxx__ccrreeaattee(pth_uctx_t *_u_c_t_x);
           This function creates a user-space context and stores
           it into _u_c_t_x.  There is still no underlying user-space
           context configured. You still have to do this with
           _p_t_h___u_c_t_x___m_a_k_e(3). On success, this function returns
           "TRUE", else "FALSE".





08-Jun-2006               GNU Pth 2.0.7                        29





pth(3)                 GNU Portable Threads                pth(3)


       int pptthh__uuccttxx__mmaakkee(pth_uctx_t _u_c_t_x, char *_s_k___a_d_d_r, size_t
       _s_k___s_i_z_e, const sigset_t *_s_i_g_m_a_s_k, void (*_s_t_a_r_t___f_u_n_c)(void
       *), void *_s_t_a_r_t___a_r_g, pth_uctx_t _u_c_t_x___a_f_t_e_r);
           This function makes a new user-space context in _u_c_t_x
           which will operate on the run-time stack _s_k___a_d_d_r
           (which is of maximum size _s_k___s_i_z_e), with the signals
           in _s_i_g_m_a_s_k blocked (if _s_i_g_m_a_s_k is not "NULL") and
           starting to execute with the call
           _s_t_a_r_t___f_u_n_c(_s_t_a_r_t___a_r_g). If _s_k___a_d_d_r is "NULL", a stack
           is dynamically allocated. The stack size _s_k___s_i_z_e has
           to be at least 16384 (16KB). If the start function
           _s_t_a_r_t___f_u_n_c returns and _u_c_t_x___a_f_t_e_r is not "NULL", an
           implicit user-space context switch to this context is
           performed. Else (if _u_c_t_x___a_f_t_e_r is "NULL") the process
           is terminated with _e_x_i_t(3). This function is somewhat
           modeled after POSIX _m_a_k_e_c_o_n_t_e_x_t(3). On success, this
           function returns "TRUE", else "FALSE".

       int pptthh__uuccttxx__sswwiittcchh(pth_uctx_t _u_c_t_x___f_r_o_m, pth_uctx_t
       _u_c_t_x___t_o);
           This function saves the current user-space context in
           _u_c_t_x___f_r_o_m for later restoring by another call to
           _p_t_h___u_c_t_x___s_w_i_t_c_h(3) and restores the new user-space
           context from _u_c_t_x___t_o, which previously had to be set
           with either a previous call to _p_t_h___u_c_t_x___s_w_i_t_c_h(3) or
           initially by _p_t_h___u_c_t_x___m_a_k_e(3). This function is
           somewhat modeled after POSIX _s_w_a_p_c_o_n_t_e_x_t(3). If
           _u_c_t_x___f_r_o_m or _u_c_t_x___t_o are "NULL" or if _u_c_t_x___t_o contains
           no valid user-space context, "FALSE" is returned
           instead of "TRUE". These are the only errors possible.

       int pptthh__uuccttxx__ddeessttrrooyy(pth_uctx_t _u_c_t_x);
           This function destroys the user-space context in _u_c_t_x.
           The run-time stack associated with the user-space
           context is deallocated only if it was not given by the
           application (see _s_k___a_d_d_r of _p_t_h___u_c_t_x___c_r_e_a_t_e(3)).  If
           _u_c_t_x is "NULL", "FALSE" is returned instead of "TRUE".
           This is the only error possible.

       GGeenneerraalliizzeedd PPOOSSIIXX RReeppllaacceemmeenntt AAPPII

       The following functions are generalized replacements
       functions for the POSIX API, i.e., they are similar to the
       functions under `SSttaannddaarrdd PPOOSSIIXX RReeppllaacceemmeenntt AAPPII' but all
       have an additional event argument which can be used for
       timeouts, etc.

       int pptthh__ssiiggwwaaiitt__eevv(const sigset_t *_s_e_t, int *_s_i_g,
       pth_event_t _e_v);
           This is equal to _p_t_h___s_i_g_w_a_i_t(3) (see below), but has
           an additional event argument _e_v. When _p_t_h___s_i_g_w_a_i_t(3)
           suspends the current threads execution it usually only
           uses the signal event on _s_e_t to awake. With this
           function any number of extra events can be used to



08-Jun-2006               GNU Pth 2.0.7                        30





pth(3)                 GNU Portable Threads                pth(3)


           awake the current thread (remember that _e_v actually is
           an event _r_i_n_g).

       int pptthh__ccoonnnneecctt__eevv(int _s, const struct sockaddr *_a_d_d_r,
       socklen_t _a_d_d_r_l_e_n, pth_event_t _e_v);
           This is equal to _p_t_h___c_o_n_n_e_c_t(3) (see below), but has
           an additional event argument _e_v. When _p_t_h___c_o_n_n_e_c_t(3)
           suspends the current threads execution it usually only
           uses the I/O event on _s to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       int pptthh__aacccceepptt__eevv(int _s, struct sockaddr *_a_d_d_r, socklen_t
       *_a_d_d_r_l_e_n, pth_event_t _e_v);
           This is equal to _p_t_h___a_c_c_e_p_t(3) (see below), but has an
           additional event argument _e_v. When _p_t_h___a_c_c_e_p_t(3)
           suspends the current threads execution it usually only
           uses the I/O event on _s to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       int pptthh__sseelleecctt__eevv(int _n_f_d, fd_set *_r_f_d_s, fd_set *_w_f_d_s,
       fd_set *_e_f_d_s, struct timeval *_t_i_m_e_o_u_t, pth_event_t _e_v);
           This is equal to _p_t_h___s_e_l_e_c_t(3) (see below), but has an
           additional event argument _e_v. When _p_t_h___s_e_l_e_c_t(3)
           suspends the current threads execution it usually only
           uses the I/O event on _r_f_d_s, _w_f_d_s and _e_f_d_s to awake.
           With this function any number of extra events can be
           used to awake the current thread (remember that _e_v
           actually is an event _r_i_n_g).

       int pptthh__ppoollll__eevv(struct pollfd *_f_d_s, unsigned int _n_f_d, int
       _t_i_m_e_o_u_t, pth_event_t _e_v);
           This is equal to _p_t_h___p_o_l_l(3) (see below), but has an
           additional event argument _e_v. When _p_t_h___p_o_l_l(3)
           suspends the current threads execution it usually only
           uses the I/O event on _f_d_s to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       ssize_t pptthh__rreeaadd__eevv(int _f_d, void *_b_u_f, size_t _n_b_y_t_e_s,
       pth_event_t _e_v);
           This is equal to _p_t_h___r_e_a_d(3) (see below), but has an
           additional event argument _e_v. When _p_t_h___r_e_a_d(3)
           suspends the current threads execution it usually only
           uses the I/O event on _f_d to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).





08-Jun-2006               GNU Pth 2.0.7                        31





pth(3)                 GNU Portable Threads                pth(3)


       ssize_t pptthh__rreeaaddvv__eevv(int _f_d, const struct iovec *_i_o_v_e_c,
       int _i_o_v_c_n_t, pth_event_t _e_v);
           This is equal to _p_t_h___r_e_a_d_v(3) (see below), but has an
           additional event argument _e_v. When _p_t_h___r_e_a_d_v(3)
           suspends the current threads execution it usually only
           uses the I/O event on _f_d to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       ssize_t pptthh__wwrriittee__eevv(int _f_d, const void *_b_u_f, size_t
       _n_b_y_t_e_s, pth_event_t _e_v);
           This is equal to _p_t_h___w_r_i_t_e(3) (see below), but has an
           additional event argument _e_v. When _p_t_h___w_r_i_t_e(3)
           suspends the current threads execution it usually only
           uses the I/O event on _f_d to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       ssize_t pptthh__wwrriitteevv__eevv(int _f_d, const struct iovec *_i_o_v_e_c,
       int _i_o_v_c_n_t, pth_event_t _e_v);
           This is equal to _p_t_h___w_r_i_t_e_v(3) (see below), but has an
           additional event argument _e_v. When _p_t_h___w_r_i_t_e_v(3)
           suspends the current threads execution it usually only
           uses the I/O event on _f_d to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       ssize_t pptthh__rreeccvv__eevv(int _f_d, void *_b_u_f, size_t _n_b_y_t_e_s, int
       _f_l_a_g_s, pth_event_t _e_v);
           This is equal to _p_t_h___r_e_c_v(3) (see below), but has an
           additional event argument _e_v. When _p_t_h___r_e_c_v(3)
           suspends the current threads execution it usually only
           uses the I/O event on _f_d to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       ssize_t pptthh__rreeccvvffrroomm__eevv(int _f_d, void *_b_u_f, size_t _n_b_y_t_e_s,
       int _f_l_a_g_s, struct sockaddr *_f_r_o_m, socklen_t *_f_r_o_m_l_e_n,
       pth_event_t _e_v);
           This is equal to _p_t_h___r_e_c_v_f_r_o_m(3) (see below), but has
           an additional event argument _e_v. When _p_t_h___r_e_c_v_f_r_o_m(3)
           suspends the current threads execution it usually only
           uses the I/O event on _f_d to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       ssize_t pptthh__sseenndd__eevv(int _f_d, const void *_b_u_f, size_t
       _n_b_y_t_e_s, int _f_l_a_g_s, pth_event_t _e_v);
           This is equal to _p_t_h___s_e_n_d(3) (see below), but has an



08-Jun-2006               GNU Pth 2.0.7                        32





pth(3)                 GNU Portable Threads                pth(3)


           additional event argument _e_v. When _p_t_h___s_e_n_d(3)
           suspends the current threads execution it usually only
           uses the I/O event on _f_d to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       ssize_t pptthh__sseennddttoo__eevv(int _f_d, const void *_b_u_f, size_t
       _n_b_y_t_e_s, int _f_l_a_g_s, const struct sockaddr *_t_o, socklen_t
       _t_o_l_e_n, pth_event_t _e_v);
           This is equal to _p_t_h___s_e_n_d_t_o(3) (see below), but has an
           additional event argument _e_v. When _p_t_h___s_e_n_d_t_o(3)
           suspends the current threads execution it usually only
           uses the I/O event on _f_d to awake. With this function
           any number of extra events can be used to awake the
           current thread (remember that _e_v actually is an event
           _r_i_n_g).

       SSttaannddaarrdd PPOOSSIIXX RReeppllaacceemmeenntt AAPPII

       The following functions are standard replacements
       functions for the POSIX API.  The difference is mainly
       that they suspend the current thread only instead of the
       whole process in case the file descriptors will block.

       int pptthh__nnaannoosslleeeepp(const struct timespec *_r_q_t_p, struct
       timespec *_r_m_t_p);
           This is a variant of the POSIX _n_a_n_o_s_l_e_e_p(3) function.
           It suspends the current threads execution until the
           amount of time in _r_q_t_p elapsed.  The thread is
           guaranteed to not wake up before this time, but
           because of the non-preemptive scheduling nature of
           PPtthh, it can be awakened later, of course. If _r_m_t_p is
           not "NULL", the "timespec" structure it references is
           updated to contain the unslept amount (the request
           time minus the time actually slept time). The
           difference between _n_a_n_o_s_l_e_e_p(3) and _p_t_h___n_a_n_o_s_l_e_e_p(3)
           is that that _p_t_h___n_a_n_o_s_l_e_e_p(3) suspends only the
           execution of the current thread and not the whole
           process.

       int pptthh__uusslleeeepp(unsigned int _u_s_e_c);
           This is a variant of the 4.3BSD _u_s_l_e_e_p(3) function. It
           suspends the current threads execution until _u_s_e_c
           microseconds (= _u_s_e_c*1/1000000 sec) elapsed.  The
           thread is guaranteed to not wake up before this time,
           but because of the non-preemptive scheduling nature of
           PPtthh, it can be awakened later, of course.  The
           difference between _u_s_l_e_e_p(3) and _p_t_h___u_s_l_e_e_p(3) is that
           that _p_t_h___u_s_l_e_e_p(3) suspends only the execution of the
           current thread and not the whole process.

       unsigned int pptthh__sslleeeepp(unsigned int _s_e_c);
           This is a variant of the POSIX _s_l_e_e_p(3) function. It



08-Jun-2006               GNU Pth 2.0.7                        33





pth(3)                 GNU Portable Threads                pth(3)


           suspends the current threads execution until _s_e_c
           seconds elapsed.  The thread is guaranteed to not wake
           up before this time, but because of the non-preemptive
           scheduling nature of PPtthh, it can be awakened later, of
           course.  The difference between _s_l_e_e_p(3) and
           _p_t_h___s_l_e_e_p(3) is that _p_t_h___s_l_e_e_p(3) suspends only the
           execution of the current thread and not the whole
           process.

       pid_t pptthh__wwaaiittppiidd(pid_t _p_i_d, int *_s_t_a_t_u_s, int _o_p_t_i_o_n_s);
           This is a variant of the POSIX _w_a_i_t_p_i_d(2) function. It
           suspends the current threads execution until _s_t_a_t_u_s
           information is available for a terminated child
           process _p_i_d.  The difference between _w_a_i_t_p_i_d(2) and
           _p_t_h___w_a_i_t_p_i_d(3) is that _p_t_h___w_a_i_t_p_i_d(3) suspends only
           the execution of the current thread and not the whole
           process.  For more details about the arguments and
           return code semantics see _w_a_i_t_p_i_d(2).

       int pptthh__ssyysstteemm(const char *_c_m_d);
           This is a variant of the POSIX _s_y_s_t_e_m(3) function. It
           executes the shell command _c_m_d with Bourne Shell
           ("sh") and suspends the current threads execution
           until this command terminates. The difference between
           _s_y_s_t_e_m(3) and _p_t_h___s_y_s_t_e_m(3) is that _p_t_h___s_y_s_t_e_m(3)
           suspends only the execution of the current thread and
           not the whole process. For more details about the
           arguments and return code semantics see _s_y_s_t_e_m(3).

       int pptthh__ssiiggmmaasskk(int _h_o_w, const sigset_t *_s_e_t, sigset_t
       *_o_s_e_t)
           This is the PPtthh thread-related equivalent of POSIX
           _s_i_g_p_r_o_c_m_a_s_k(2) respectively _p_t_h_r_e_a_d___s_i_g_m_a_s_k(3). The
           arguments _h_o_w, _s_e_t and _o_s_e_t directly relate to
           _s_i_g_p_r_o_c_m_a_s_k(2), because PPtthh internally just uses
           _s_i_g_p_r_o_c_m_a_s_k(2) here. So alternatively you can also
           directly call _s_i_g_p_r_o_c_m_a_s_k(2), but for consistency
           reasons you should use this function _p_t_h___s_i_g_m_a_s_k(3).

       int pptthh__ssiiggwwaaiitt(const sigset_t *_s_e_t, int *_s_i_g);
           This is a variant of the POSIX.1c _s_i_g_w_a_i_t(3) function.
           It suspends the current threads execution until a
           signal in _s_e_t occurred and stores the signal number in
           _s_i_g. The important point is that the signal is not
           delivered to a signal handler. Instead it's caught by
           the scheduler only in order to awake the _p_t_h___s_i_g_w_a_i_t_(_)
           call. The trick and noticeable point here is that this
           way you get an asynchronous aware application that is
           written completely synchronously. When you think about
           the problem of _a_s_y_n_c_h_r_o_n_o_u_s _s_a_f_e functions you should
           recognize that this is a great benefit.

       int pptthh__ccoonnnneecctt(int _s, const struct sockaddr *_a_d_d_r,
       socklen_t _a_d_d_r_l_e_n);



08-Jun-2006               GNU Pth 2.0.7                        34





pth(3)                 GNU Portable Threads                pth(3)


           This is a variant of the 4.2BSD _c_o_n_n_e_c_t(2) function.
           It establishes a connection on a socket _s to target
           specified in _a_d_d_r and _a_d_d_r_l_e_n.  The difference between
           _c_o_n_n_e_c_t(2) and _p_t_h___c_o_n_n_e_c_t(3) is that _p_t_h___c_o_n_n_e_c_t(3)
           suspends only the execution of the current thread and
           not the whole process.  For more details about the
           arguments and return code semantics see _c_o_n_n_e_c_t(2).

       int pptthh__aacccceepptt(int _s, struct sockaddr *_a_d_d_r, socklen_t
       *_a_d_d_r_l_e_n);
           This is a variant of the 4.2BSD _a_c_c_e_p_t(2) function. It
           accepts a connection on a socket by extracting the
           first connection request on the queue of pending
           connections, creating a new socket with the same
           properties of _s and allocates a new file descriptor
           for the socket (which is returned).  The difference
           between _a_c_c_e_p_t(2) and _p_t_h___a_c_c_e_p_t(3) is that
           _p_t_h___a_c_c_e_p_t(3) suspends only the execution of the
           current thread and not the whole process.  For more
           details about the arguments and return code semantics
           see _a_c_c_e_p_t(2).

       int pptthh__sseelleecctt(int _n_f_d, fd_set *_r_f_d_s, fd_set *_w_f_d_s, fd_set
       *_e_f_d_s, struct timeval *_t_i_m_e_o_u_t);
           This is a variant of the 4.2BSD _s_e_l_e_c_t(2) function.
           It examines the I/O descriptor sets whose addresses
           are passed in _r_f_d_s, _w_f_d_s, and _e_f_d_s to see if some of
           their descriptors are ready for reading, are ready for
           writing, or have an exceptional condition pending,
           respectively.  For more details about the arguments
           and return code semantics see _s_e_l_e_c_t(2).

       int pptthh__ppsseelleecctt(int _n_f_d, fd_set *_r_f_d_s, fd_set *_w_f_d_s,
       fd_set *_e_f_d_s, const struct timespec *_t_i_m_e_o_u_t, const
       sigset_t *_s_i_g_m_a_s_k);
           This is a variant of the POSIX _p_s_e_l_e_c_t(2) function,
           which in turn is a stronger variant of 4.2BSD
           _s_e_l_e_c_t(2). The difference is that the higher-
           resolution "struct timespec" is passed instead of the
           lower-resolution "struct timeval" and that a signal
           mask is specified which is temporarily set while
           waiting for input. For more details about the
           arguments and return code semantics see _p_s_e_l_e_c_t(2) and
           _s_e_l_e_c_t(2).

       int pptthh__ppoollll(struct pollfd *_f_d_s, unsigned int _n_f_d, int
       _t_i_m_e_o_u_t);
           This is a variant of the SysV _p_o_l_l(2) function. It
           examines the I/O descriptors which are passed in the
           array _f_d_s to see if some of them are ready for
           reading, are ready for writing, or have an exceptional
           condition pending, respectively. For more details
           about the arguments and return code semantics see
           _p_o_l_l(2).



08-Jun-2006               GNU Pth 2.0.7                        35





pth(3)                 GNU Portable Threads                pth(3)


       ssize_t pptthh__rreeaadd(int _f_d, void *_b_u_f, size_t _n_b_y_t_e_s);
           This is a variant of the POSIX _r_e_a_d(2) function. It
           reads up to _n_b_y_t_e_s bytes into _b_u_f from file descriptor
           _f_d.  The difference between _r_e_a_d(2) and _p_t_h___r_e_a_d(2) is
           that _p_t_h___r_e_a_d(2) suspends execution of the current
           thread until the file descriptor is ready for reading.
           For more details about the arguments and return code
           semantics see _r_e_a_d(2).

       ssize_t pptthh__rreeaaddvv(int _f_d, const struct iovec *_i_o_v_e_c, int
       _i_o_v_c_n_t);
           This is a variant of the POSIX _r_e_a_d_v(2) function. It
           reads data from file descriptor _f_d into the first
           _i_o_v_c_n_t rows of the _i_o_v vector.  The difference between
           _r_e_a_d_v(2) and _p_t_h___r_e_a_d_v(2) is that _p_t_h___r_e_a_d_v(2)
           suspends execution of the current thread until the
           file descriptor is ready for reading. For more details
           about the arguments and return code semantics see
           _r_e_a_d_v(2).

       ssize_t pptthh__wwrriittee(int _f_d, const void *_b_u_f, size_t _n_b_y_t_e_s);
           This is a variant of the POSIX _w_r_i_t_e(2) function. It
           writes _n_b_y_t_e_s bytes from _b_u_f to file descriptor _f_d.
           The difference between _w_r_i_t_e(2) and _p_t_h___w_r_i_t_e(2) is
           that _p_t_h___w_r_i_t_e(2) suspends execution of the current
           thread until the file descriptor is ready for writing.
           For more details about the arguments and return code
           semantics see _w_r_i_t_e(2).

       ssize_t pptthh__wwrriitteevv(int _f_d, const struct iovec *_i_o_v_e_c, int
       _i_o_v_c_n_t);
           This is a variant of the POSIX _w_r_i_t_e_v(2) function. It
           writes data to file descriptor _f_d from the first
           _i_o_v_c_n_t rows of the _i_o_v vector.  The difference between
           _w_r_i_t_e_v(2) and _p_t_h___w_r_i_t_e_v(2) is that _p_t_h___w_r_i_t_e_v(2)
           suspends execution of the current thread until the
           file descriptor is ready for reading. For more details
           about the arguments and return code semantics see
           _w_r_i_t_e_v(2).

       ssize_t pptthh__pprreeaadd(int _f_d, void *_b_u_f, size_t _n_b_y_t_e_s, off_t
       _o_f_f_s_e_t);
           This is a variant of the POSIX _p_r_e_a_d(3) function.  It
           performs the same action as a regular _r_e_a_d(2), except
           that it reads from a given position in the file
           without changing the file pointer.  The first three
           arguments are the same as for _p_t_h___r_e_a_d(3) with the
           addition of a fourth argument _o_f_f_s_e_t for the desired
           position inside the file.

       ssize_t pptthh__ppwwrriittee(int _f_d, const void *_b_u_f, size_t _n_b_y_t_e_s,
       off_t _o_f_f_s_e_t);
           This is a variant of the POSIX _p_w_r_i_t_e(3) function.  It
           performs the same action as a regular _w_r_i_t_e(2), except



08-Jun-2006               GNU Pth 2.0.7                        36





pth(3)                 GNU Portable Threads                pth(3)


           that it writes to a given position in the file without
           changing the file pointer. The first three arguments
           are the same as for _p_t_h___w_r_i_t_e(3) with the addition of
           a fourth argument _o_f_f_s_e_t for the desired position
           inside the file.

       ssize_t pptthh__rreeccvv(int _f_d, void *_b_u_f, size_t _n_b_y_t_e_s, int
       _f_l_a_g_s);
           This is a variant of the SUSv2 _r_e_c_v(2) function and
           equal to ``pth_recvfrom(fd, buf, nbytes, flags, NULL,
           0)''.

       ssize_t pptthh__rreeccvvffrroomm(int _f_d, void *_b_u_f, size_t _n_b_y_t_e_s, int
       _f_l_a_g_s, struct sockaddr *_f_r_o_m, socklen_t *_f_r_o_m_l_e_n);
           This is a variant of the SUSv2 _r_e_c_v_f_r_o_m(2) function.
           It reads up to _n_b_y_t_e_s bytes into _b_u_f from file
           descriptor _f_d while using _f_l_a_g_s and _f_r_o_m/_f_r_o_m_l_e_n. The
           difference between _r_e_c_v_f_r_o_m(2) and _p_t_h___r_e_c_v_f_r_o_m(2) is
           that _p_t_h___r_e_c_v_f_r_o_m(2) suspends execution of the current
           thread until the file descriptor is ready for reading.
           For more details about the arguments and return code
           semantics see _r_e_c_v_f_r_o_m(2).

       ssize_t pptthh__sseenndd(int _f_d, const void *_b_u_f, size_t _n_b_y_t_e_s,
       int _f_l_a_g_s);
           This is a variant of the SUSv2 _s_e_n_d(2) function and
           equal to ``pth_sendto(fd, buf, nbytes, flags, NULL,
           0)''.

       ssize_t pptthh__sseennddttoo(int _f_d, const void *_b_u_f, size_t _n_b_y_t_e_s,
       int _f_l_a_g_s, const struct sockaddr *_t_o, socklen_t _t_o_l_e_n);
           This is a variant of the SUSv2 _s_e_n_d_t_o(2) function. It
           writes _n_b_y_t_e_s bytes from _b_u_f to file descriptor _f_d
           while using _f_l_a_g_s and _t_o/_t_o_l_e_n. The difference between
           _s_e_n_d_t_o(2) and _p_t_h___s_e_n_d_t_o(2) is that _p_t_h___s_e_n_d_t_o(2)
           suspends execution of the current thread until the
           file descriptor is ready for writing. For more details
           about the arguments and return code semantics see
           _s_e_n_d_t_o(2).

EEXXAAMMPPLLEE
       The following example is a useless server which does
       nothing more than listening on TCP port 12345 and
       displaying the current time to the socket when a
       connection was established. For each incoming connection a
       thread is spawned. Additionally, to see more
       multithreading, a useless ticker thread runs
       simultaneously which outputs the current time to "stderr"
       every 5 seconds. The example contains _n_o error checking
       and is _o_n_l_y intended to show you the look and feel of PPtthh.







08-Jun-2006               GNU Pth 2.0.7                        37





pth(3)                 GNU Portable Threads                pth(3)


        #include <stdio.h>
        #include <stdlib.h>
        #include <errno.h>
        #include <sys/types.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <signal.h>
        #include <netdb.h>
        #include <unistd.h>
        #include "pth.h"

        #define PORT 12345

        /* the socket connection handler thread */
        static void *handler(void *_arg)
        {
            int fd = (int)_arg;
            time_t now;
            char *ct;

            now = time(NULL);
            ct = ctime(&now);
            pth_write(fd, ct, strlen(ct));
            close(fd);
            return NULL;
        }

        /* the stderr time ticker thread */
        static void *ticker(void *_arg)
        {
            time_t now;
            char *ct;
            float load;

            for (;;) {
                pth_sleep(5);
                now = time(NULL);
                ct = ctime(&now);
                ct[strlen(ct)-1] = '\0';
                pth_ctrl(PTH_CTRL_GETAVLOAD, &load);
                printf("ticker: time: %s, average load: %.2f\n", ct, load);
            }
        }













08-Jun-2006               GNU Pth 2.0.7                        38





pth(3)                 GNU Portable Threads                pth(3)


        /* the main thread/procedure */
        int main(int argc, char *argv[])
        {
            pth_attr_t attr;
            struct sockaddr_in sar;
            struct protoent *pe;
            struct sockaddr_in peer_addr;
            int peer_len;
            int sa, sw;
            int port;

            pth_init();
            signal(SIGPIPE, SIG_IGN);

            attr = pth_attr_new();
            pth_attr_set(attr, PTH_ATTR_NAME, "ticker");
            pth_attr_set(attr, PTH_ATTR_STACK_SIZE, 64*1024);
            pth_attr_set(attr, PTH_ATTR_JOINABLE, FALSE);
            pth_spawn(attr, ticker, NULL);

            pe = getprotobyname("tcp");
            sa = socket(AF_INET, SOCK_STREAM, pe->p_proto);
            sar.sin_family = AF_INET;
            sar.sin_addr.s_addr = INADDR_ANY;
            sar.sin_port = htons(PORT);
            bind(sa, (struct sockaddr *)&sar, sizeof(struct sockaddr_in));
            listen(sa, 10);

            pth_attr_set(attr, PTH_ATTR_NAME, "handler");
            for (;;) {
                peer_len = sizeof(peer_addr);
                sw = pth_accept(sa, (struct sockaddr *)&peer_addr, &peer_len);
                pth_spawn(attr, handler, (void *)sw);
            }
        }

BBUUIILLDD EENNVVIIRROONNMMEENNTTSS
       In this section we will discuss the canonical ways to
       establish the build environment for a PPtthh based program.
       The possibilities supported by PPtthh range from very simple
       environments to rather complex ones.

       MMaannuuaall BBuuiilldd EEnnvviirroonnmmeenntt ((NNoovviiccee))

       As a first example, assume we have the above test program
       staying in the source file "foo.c". Then we can create a
       very simple build environment by just adding the following
       "Makefile":









08-Jun-2006               GNU Pth 2.0.7                        39





pth(3)                 GNU Portable Threads                pth(3)


        $ vi Makefile
        | CC      = cc
        | CFLAGS  = `pth-config --cflags`
        | LDFLAGS = `pth-config --ldflags`
        | LIBS    = `pth-config --libs`
        |
        | all: foo
        | foo: foo.o
        |     $(CC) $(LDFLAGS) -o foo foo.o $(LIBS)
        | foo.o: foo.c
        |     $(CC) $(CFLAGS) -c foo.c
        | clean:
        |     rm -f foo foo.o

       This imports the necessary compiler and linker flags on-
       the-fly from the PPtthh installation via its "pth-config"
       program. This approach is straight-forward and works fine
       for small projects.

       AAuuttooccoonnff BBuuiilldd EEnnvviirroonnmmeenntt ((AAddvvaanncceedd))

       The previous approach is simple but inflexible. First, to
       speed up building, it would be nice to not expand the
       compiler and linker flags every time the compiler is
       started. Second, it would be useful to also be able to
       build against uninstalled PPtthh, that is, against a PPtthh
       source tree which was just configured and built, but not
       installed. Third, it would be also useful to allow
       checking of the PPtthh version to make sure it is at least a
       minimum required version.  And finally, it would be also
       great to make sure PPtthh works correctly by first performing
       some sanity compile and run-time checks. All this can be
       done if we use GNU aauuttooccoonnff and the "AC_CHECK_PTH" macro
       provided by PPtthh. For this, we establish the following
       three files:

       First we again need the "Makefile", but this time it
       contains aauuttooccoonnff placeholders and additional cleanup
       targets. And we create it under the name "Makefile.in",
       because it is now an input file for aauuttooccoonnff:

















08-Jun-2006               GNU Pth 2.0.7                        40





pth(3)                 GNU Portable Threads                pth(3)


        $ vi Makefile.in
        | CC      = @CC@
        | CFLAGS  = @CFLAGS@
        | LDFLAGS = @LDFLAGS@
        | LIBS    = @LIBS@
        |
        | all: foo
        | foo: foo.o
        |     $(CC) $(LDFLAGS) -o foo foo.o $(LIBS)
        | foo.o: foo.c
        |     $(CC) $(CFLAGS) -c foo.c
        | clean:
        |     rm -f foo foo.o
        | distclean:
        |     rm -f foo foo.o
        |     rm -f config.log config.status config.cache
        |     rm -f Makefile

       Because aauuttooccoonnff generates additional files, we added a
       canonical "distclean" target which cleans this up.
       Secondly, we wrote "configure.ac", a (minimal) aauuttooccoonnff
       script specification:

        $ vi configure.ac
        | AC_INIT(Makefile.in)
        | AC_CHECK_PTH(1.3.0)
        | AC_OUTPUT(Makefile)

       Then we let aauuttooccoonnff's "aclocal" program generate for us
       an "aclocal.m4" file containing PPtthh's "AC_CHECK_PTH"
       macro. Then we generate the final "configure" script out
       of this "aclocal.m4" file and the "configure.ac" file:

        $ aclocal --acdir=`pth-config --acdir`
        $ autoconf

       After these steps, the working directory should look
       similar to this:

        $ ls -l
        -rw-r--r--  1 rse  users    176 Nov  3 11:11 Makefile.in
        -rw-r--r--  1 rse  users  15314 Nov  3 11:16 aclocal.m4
        -rwxr-xr-x  1 rse  users  52045 Nov  3 11:16 configure
        -rw-r--r--  1 rse  users     63 Nov  3 11:11 configure.ac
        -rw-r--r--  1 rse  users   4227 Nov  3 11:11 foo.c

       If we now run "configure" we get a correct "Makefile"
       which immediately can be used to build "foo" (assuming
       that PPtthh is already installed somewhere, so that
       "pth-config" is in $PATH):







08-Jun-2006               GNU Pth 2.0.7                        41





pth(3)                 GNU Portable Threads                pth(3)


        $ ./configure
        creating cache ./config.cache
        checking for gcc... gcc
        checking whether the C compiler (gcc   ) works... yes
        checking whether the C compiler (gcc   ) is a cross-compiler... no
        checking whether we are using GNU C... yes
        checking whether gcc accepts -g... yes
        checking how to run the C preprocessor... gcc -E
        checking for GNU Pth... version 1.3.0, installed under /usr/local
        updating cache ./config.cache
        creating ./config.status
        creating Makefile
        rse@en1:/e/gnu/pth/ac
        $ make
        gcc -g -O2 -I/usr/local/include -c foo.c
        gcc -L/usr/local/lib -o foo foo.o -lpth

       If PPtthh is installed in non-standard locations or
       "pth-config" is not in $PATH, one just has to drop the
       "configure" script a note about the location by running
       "configure" with the option "--with-pth="_d_i_r (where _d_i_r is
       the argument which was used with the "--prefix" option
       when PPtthh was installed).

       AAuuttooccoonnff BBuuiilldd EEnnvviirroonnmmeenntt wwiitthh LLooccaall CCooppyy ooff PPtthh ((EExxppeerrtt))

       Finally let us assume the "foo" program stays under either
       a _G_P_L or _L_G_P_L distribution license and we want to make it
       a stand-alone package for easier distribution and
       installation.  That is, we don't want to oblige the end-
       user to install PPtthh just to allow our "foo" package to
       compile. For this, it is a convenient practice to include
       the required libraries (here PPtthh) into the source tree of
       the package (here "foo").  PPtthh ships with all necessary
       support to allow us to easily achieve this approach. Say,
       we want PPtthh in a subdirectory named "pth/" and this
       directory should be seamlessly integrated into the
       configuration and build process of "foo".

       First we again start with the "Makefile.in", but this time
       it is a more advanced version which supports subdirectory
       movement:















08-Jun-2006               GNU Pth 2.0.7                        42





pth(3)                 GNU Portable Threads                pth(3)


        $ vi Makefile.in
        | CC      = @CC@
        | CFLAGS  = @CFLAGS@
        | LDFLAGS = @LDFLAGS@
        | LIBS    = @LIBS@
        |
        | SUBDIRS = pth
        |
        | all: subdirs_all foo
        |
        | subdirs_all:
        |     @$(MAKE) $(MFLAGS) subdirs TARGET=all
        | subdirs_clean:
        |     @$(MAKE) $(MFLAGS) subdirs TARGET=clean
        | subdirs_distclean:
        |     @$(MAKE) $(MFLAGS) subdirs TARGET=distclean
        | subdirs:
        |     @for subdir in $(SUBDIRS); do \
        |         echo "===> $$subdir ($(TARGET))"; \
        |         (cd $$subdir; $(MAKE) $(MFLAGS) $(TARGET) || exit 1) || exit 1; \
        |         echo "<=== $$subdir"; \
        |     done
        |
        | foo: foo.o
        |     $(CC) $(LDFLAGS) -o foo foo.o $(LIBS)
        | foo.o: foo.c
        |     $(CC) $(CFLAGS) -c foo.c
        |
        | clean: subdirs_clean
        |     rm -f foo foo.o
        | distclean: subdirs_distclean
        |     rm -f foo foo.o
        |     rm -f config.log config.status config.cache
        |     rm -f Makefile

       Then we create a slightly different aauuttooccoonnff script
       "configure.ac":

        $ vi configure.ac
        | AC_INIT(Makefile.in)
        | AC_CONFIG_AUX_DIR(pth)
        | AC_CHECK_PTH(1.3.0, subdir:pth --disable-tests)
        | AC_CONFIG_SUBDIRS(pth)
        | AC_OUTPUT(Makefile)

       Here we provided a default value for "foo"'s "--with-pth"
       option as the second argument to "AC_CHECK_PTH" which
       indicates that PPtthh can be found in the subdirectory named
       "pth/". Additionally we specified that the
       "--disable-tests" option of PPtthh should be passed to the
       "pth/" subdirectory, because we need only to build the PPtthh
       library itself. And we added a "AC_CONFIG_SUBDIR" call
       which indicates to aauuttooccoonnff that it should configure the
       "pth/" subdirectory, too. The "AC_CONFIG_AUX_DIR"



08-Jun-2006               GNU Pth 2.0.7                        43





pth(3)                 GNU Portable Threads                pth(3)


       directive was added just to make aauuttooccoonnff happy, because
       it wants to find a "install.sh" or "shtool" script if
       "AC_CONFIG_SUBDIRS" is used.

       Now we let aauuttooccoonnff's "aclocal" program again generate for
       us an "aclocal.m4" file with the contents of PPtthh's
       "AC_CHECK_PTH" macro.  Finally we generate the "configure"
       script out of this "aclocal.m4" file and the
       "configure.ac" file.

        $ aclocal --acdir=`pth-config --acdir`
        $ autoconf

       Now we have to create the "pth/" subdirectory itself. For
       this, we extract the PPtthh distribution to the "foo" source
       tree and just rename it to "pth/":

        $ gunzip <pth-X.Y.Z.tar.gz | tar xvf -
        $ mv pth-X.Y.Z pth

       Optionally to reduce the size of the "pth/" subdirectory,
       we can strip down the PPtthh sources to a minimum with the
       _s_t_r_i_p_t_e_a_s_e feature:

        $ cd pth
        $ ./configure
        $ make striptease
        $ cd ..

       After this the source tree of "foo" should look similar to
       this:


























08-Jun-2006               GNU Pth 2.0.7                        44





pth(3)                 GNU Portable Threads                pth(3)


        $ ls -l
        -rw-r--r--  1 rse  users    709 Nov  3 11:51 Makefile.in
        -rw-r--r--  1 rse  users  16431 Nov  3 12:20 aclocal.m4
        -rwxr-xr-x  1 rse  users  57403 Nov  3 12:21 configure
        -rw-r--r--  1 rse  users    129 Nov  3 12:21 configure.ac
        -rw-r--r--  1 rse  users   4227 Nov  3 11:11 foo.c
        drwxr-xr-x  2 rse  users   3584 Nov  3 12:36 pth
        $ ls -l pth/
        -rw-rw-r--  1 rse  users   26344 Nov  1 20:12 COPYING
        -rw-rw-r--  1 rse  users    2042 Nov  3 12:36 Makefile.in
        -rw-rw-r--  1 rse  users    3967 Nov  1 19:48 README
        -rw-rw-r--  1 rse  users     340 Nov  3 12:36 README.1st
        -rw-rw-r--  1 rse  users   28719 Oct 31 17:06 config.guess
        -rw-rw-r--  1 rse  users   24274 Aug 18 13:31 config.sub
        -rwxrwxr-x  1 rse  users  155141 Nov  3 12:36 configure
        -rw-rw-r--  1 rse  users  162021 Nov  3 12:36 pth.c
        -rw-rw-r--  1 rse  users   18687 Nov  2 15:19 pth.h.in
        -rw-rw-r--  1 rse  users    5251 Oct 31 12:46 pth_acdef.h.in
        -rw-rw-r--  1 rse  users    2120 Nov  1 11:27 pth_acmac.h.in
        -rw-rw-r--  1 rse  users    2323 Nov  1 11:27 pth_p.h.in
        -rw-rw-r--  1 rse  users     946 Nov  1 11:27 pth_vers.c
        -rw-rw-r--  1 rse  users   26848 Nov  1 11:27 pthread.c
        -rw-rw-r--  1 rse  users   18772 Nov  1 11:27 pthread.h.in
        -rwxrwxr-x  1 rse  users   26188 Nov  3 12:36 shtool

       Now when we configure and build the "foo" package it looks
       similar to this:






























08-Jun-2006               GNU Pth 2.0.7                        45





pth(3)                 GNU Portable Threads                pth(3)


        $ ./configure
        creating cache ./config.cache
        checking for gcc... gcc
        checking whether the C compiler (gcc   ) works... yes
        checking whether the C compiler (gcc   ) is a cross-compiler... no
        checking whether we are using GNU C... yes
        checking whether gcc accepts -g... yes
        checking how to run the C preprocessor... gcc -E
        checking for GNU Pth... version 1.3.0, local under pth
        updating cache ./config.cache
        creating ./config.status
        creating Makefile
        configuring in pth
        running /bin/sh ./configure  --enable-subdir --enable-batch
        --disable-tests --cache-file=.././config.cache --srcdir=.
        loading cache .././config.cache
        checking for gcc... (cached) gcc
        checking whether the C compiler (gcc   ) works... yes
        checking whether the C compiler (gcc   ) is a cross-compiler... no
        [...]
        $ make
        ===> pth (all)
        ./shtool scpp -o pth_p.h -t pth_p.h.in -Dcpp -Cintern -M '==#==' pth.c
        pth_vers.c
        gcc -c -I. -O2 -pipe pth.c
        gcc -c -I. -O2 -pipe pth_vers.c
        ar rc libpth.a pth.o pth_vers.o
        ranlib libpth.a
        <=== pth
        gcc -g -O2 -Ipth -c foo.c
        gcc -Lpth -o foo foo.o -lpth

       As you can see, aauuttooccoonnff now automatically configures the
       local (stripped down) copy of PPtthh in the subdirectory
       "pth/" and the "Makefile" automatically builds the
       subdirectory, too.

SSYYSSTTEEMM CCAALLLL WWRRAAPPPPEERR FFAACCIILLIITTYY
       PPtthh per default uses an explicit API, including the system
       calls. For instance you've to explicitly use _p_t_h___r_e_a_d(3)
       when you need a thread-aware _r_e_a_d(3) and cannot expect
       that by just calling _r_e_a_d(3) only the current thread is
       blocked. Instead with the standard _r_e_a_d(3) call the whole
       process will be blocked. But because for some applications
       (mainly those consisting of lots of third-party stuff)
       this can be inconvenient.  Here it's required that a call
       to _r_e_a_d(3) `magically' means _p_t_h___r_e_a_d(3). The problem here
       is that such magic PPtthh cannot provide per default because
       it's not really portable.  Nevertheless PPtthh provides a two
       step approach to solve this problem:







08-Jun-2006               GNU Pth 2.0.7                        46





pth(3)                 GNU Portable Threads                pth(3)


       SSoofftt SSyysstteemm CCaallll MMaappppiinngg

       This variant is available on all platforms and can _a_l_w_a_y_s
       be enabled by building PPtthh with "--enable-syscall-soft".
       This then triggers some "#define"'s in the "pth.h" header
       which map for instance _r_e_a_d(3) to _p_t_h___r_e_a_d(3), etc.
       Currently the following functions are mapped: _f_o_r_k(2),
       _n_a_n_o_s_l_e_e_p(3), _u_s_l_e_e_p(3), _s_l_e_e_p(3), _s_i_g_w_a_i_t(3), _w_a_i_t_p_i_d(2),
       _s_y_s_t_e_m(3), _s_e_l_e_c_t(2), _p_o_l_l(2), _c_o_n_n_e_c_t(2), _a_c_c_e_p_t(2),
       _r_e_a_d(2), _w_r_i_t_e(2), _r_e_c_v(2), _s_e_n_d(2), _r_e_c_v_f_r_o_m(2),
       _s_e_n_d_t_o(2).

       The drawback of this approach is just that really all
       source files of the application where these function calls
       occur have to include "pth.h", of course. And this also
       means that existing libraries, including the vendor's
       ssttddiioo, usually will still block the whole process if one
       of its I/O functions block.

       HHaarrdd SSyysstteemm CCaallll MMaappppiinngg

       This variant is available only on those platforms where
       the _s_y_s_c_a_l_l(2) function exists and there it can be enabled
       by building PPtthh with "--enable-syscall-hard". This then
       builds wrapper functions (for instances _r_e_a_d(3)) into the
       PPtthh library which internally call the real PPtthh replacement
       functions (_p_t_h___r_e_a_d(3)). Currently the following functions
       are mapped: _f_o_r_k(2), _n_a_n_o_s_l_e_e_p(3), _u_s_l_e_e_p(3), _s_l_e_e_p(3),
       _w_a_i_t_p_i_d(2), _s_y_s_t_e_m(3), _s_e_l_e_c_t(2), _p_o_l_l(2), _c_o_n_n_e_c_t(2),
       _a_c_c_e_p_t(2), _r_e_a_d(2), _w_r_i_t_e(2).

       The drawback of this approach is that it depends on
       _s_y_s_c_a_l_l(2) interface and prototype conflicts can occur
       while building the wrapper functions due to different
       function signatures in the vendor C header files.  But the
       advantage of this mapping variant is that the source files
       of the application where these function calls occur have
       not to include "pth.h" and that existing libraries,
       including the vendor's ssttddiioo, magically become thread-
       aware (and then block only the current thread).

IIMMPPLLEEMMEENNTTAATTIIOONN NNOOTTEESS
       PPtthh is very portable because it has only one part which
       perhaps has to be ported to new platforms (the machine
       context initialization). But it is written in a way which
       works on mostly all Unix platforms which support
       _m_a_k_e_c_o_n_t_e_x_t(2) or at least _s_i_g_s_t_a_c_k(2) or _s_i_g_a_l_t_s_t_a_c_k(2)
       [see "pth_mctx.c" for details]. Any other PPtthh code is
       POSIX and ANSI C based only.

       The context switching is done via either SUSv2
       _m_a_k_e_c_o_n_t_e_x_t(2) or POSIX make[sig]_s_e_t_j_m_p(3) and
       [sig]_l_o_n_g_j_m_p(3). Here all CPU registers, the program
       counter and the stack pointer are switched. Additionally



08-Jun-2006               GNU Pth 2.0.7                        47





pth(3)                 GNU Portable Threads                pth(3)


       the PPtthh dispatcher switches also the global Unix "errno"
       variable [see "pth_mctx.c" for details] and the signal
       mask (either implicitly via _s_i_g_s_e_t_j_m_p(3) or in an emulated
       way via explicit _s_e_t_p_r_o_c_m_a_s_k(2) calls).

       The PPtthh event manager is mainly _s_e_l_e_c_t(2) and
       _g_e_t_t_i_m_e_o_f_d_a_y(2) based, i.e., the current time is fetched
       via _g_e_t_t_i_m_e_o_f_d_a_y(2) once per context switch for time
       calculations and all I/O events are implemented via a
       single central _s_e_l_e_c_t(2) call [see "pth_sched.c" for
       details].

       The thread control block management is done via virtual
       priority queues without any additional data structure
       overhead. For this, the queue linkage attributes are part
       of the thread control blocks and the queues are actually
       implemented as rings with a selected element as the entry
       point [see "pth_tcb.h" and "pth_pqueue.c" for details].

       Most time critical code sections (especially the
       dispatcher and event manager) are speeded up by inline
       functions (implemented as ANSI C pre-processor macros).
       Additionally any debugging code is _c_o_m_p_l_e_t_e_l_y removed from
       the source when not built with "-DPTH_DEBUG" (see Autoconf
       "--enable-debug" option), i.e., not only stub functions
       remain [see "pth_debug.c" for details].

RREESSTTRRIICCTTIIOONNSS
       PPtthh (intentionally) provides no replacements for non-
       thread-safe functions (like _s_t_r_t_o_k(3) which uses a static
       internal buffer) or synchronous system functions (like
       _g_e_t_h_o_s_t_b_y_n_a_m_e(3) which doesn't provide an asynchronous
       mode where it doesn't block). When you want to use those
       functions in your server application together with
       threads, you've to either link the application against
       special third-party libraries (or for
       thread-safe/reentrant functions possibly against an
       existing "libc_r" of the platform vendor). For an
       asynchronous DNS resolver library use the GNU aaddnnss package
       from Ian Jackson ( see
       http://www.gnu.org/software/adns/adns.html ).

HHIISSTTOORRYY
       The PPtthh library was designed and implemented between
       February and July 1999 by _R_a_l_f _S_. _E_n_g_e_l_s_c_h_a_l_l after
       evaluating numerous (mostly preemptive) thread libraries
       and after intensive discussions with _P_e_t_e_r _S_i_m_o_n_s, _M_a_r_t_i_n
       _K_r_a_e_m_e_r, _L_a_r_s _E_i_l_e_b_r_e_c_h_t and _R_a_l_p_h _B_a_b_e_l related to an
       experimental (matrix based) non-preemptive C++ scheduler
       class written by _P_e_t_e_r _S_i_m_o_n_s.

       PPtthh was then implemented in order to combine the _n_o_n_-
       _p_r_e_e_m_p_t_i_v_e approach of multithreading (which provides
       better portability and performance) with an API similar to



08-Jun-2006               GNU Pth 2.0.7                        48





pth(3)                 GNU Portable Threads                pth(3)


       the popular one found in PPtthhrreeaadd libraries (which provides
       easy programming).

       So the essential idea of the non-preemptive approach was
       taken over from _P_e_t_e_r _S_i_m_o_n_s scheduler. The priority based
       scheduling algorithm was suggested by _M_a_r_t_i_n _K_r_a_e_m_e_r. Some
       code inspiration also came from an experimental threading
       library (rrsstthhrreeaaddss) written by _R_o_b_e_r_t _S_. _T_h_a_u for an
       ancient internal test version of the Apache webserver.
       The concept and API of message ports was borrowed from
       AmigaOS' EExxeecc subsystem. The concept and idea for the
       flexible event mechanism came from _P_a_u_l _V_i_x_i_e's eevveennttlliibb
       (which can be found as a part of BBIINNDD v8).

BBUUGG RREEPPOORRTTSS AANNDD SSUUPPPPOORRTT
       If you think you have found a bug in PPtthh, you should send
       a report as complete as possible to _b_u_g_-_p_t_h_@_g_n_u_._o_r_g. If
       you can, please try to fix the problem and include a
       patch, made with '"diff -u3"', in your report. Always, at
       least, include a reasonable amount of description in your
       report to allow the author to deterministically reproduce
       the bug.

       For further support you additionally can subscribe to the
       _p_t_h_-_u_s_e_r_s_@_g_n_u_._o_r_g mailing list by sending an Email to
       _p_t_h_-_u_s_e_r_s_-_r_e_q_u_e_s_t_@_g_n_u_._o_r_g with `"subscribe pth-users"' (or
       `"subscribe pth-users" _a_d_d_r_e_s_s' if you want to subscribe
       from a particular Email _a_d_d_r_e_s_s) in the body. Then you can
       discuss your issues with other PPtthh users by sending
       messages to _p_t_h_-_u_s_e_r_s_@_g_n_u_._o_r_g. Currently (as of August
       2000) you can reach about 110 Pth users on this mailing
       list. Old postings you can find at
       _h_t_t_p_:_/_/_w_w_w_._m_a_i_l_-_a_r_c_h_i_v_e_._c_o_m_/_p_t_h_-_u_s_e_r_s_@_g_n_u_._o_r_g_/.

SSEEEE AALLSSOO
       RReellaatteedd WWeebb LLooccaattiioonnss

       `comp.programming.threads Newsgroup Archive',
       http://www.deja.com/topics_if.xp?
       search=topic&group=comp.programming.threads

       `comp.programming.threads Frequently Asked Questions
       (F.A.Q.)', http://www.lambdacs.com/newsgroup/FAQ.html

       `_M_u_l_t_i_t_h_r_e_a_d_i_n_g _- _D_e_f_i_n_i_t_i_o_n_s _a_n_d _G_u_i_d_e_l_i_n_e_s', Numeric
       Quest Inc 1998;
       http://www.numeric-quest.com/lang/multi-frame.html

       `_T_h_e _S_i_n_g_l_e _U_N_I_X _S_p_e_c_i_f_i_c_a_t_i_o_n_, _V_e_r_s_i_o_n _2 _- _T_h_r_e_a_d_s', The
       Open Group 1997; http://www.opengroup.org/onlinepubs
       /007908799/xsh/threads.html

       SMI Thread Resources, Sun Microsystems Inc;
       http://www.sun.com/workshop/threads/



08-Jun-2006               GNU Pth 2.0.7                        49





pth(3)                 GNU Portable Threads                pth(3)


       Bibliography on threads and multithreading, Torsten
       Amundsen;
       http://liinwww.ira.uka.de/bibliography/Os/threads.html

       RReellaatteedd BBooookkss

       B. Nichols, D. Buttlar, J.P. Farrel: `_P_t_h_r_e_a_d_s _P_r_o_g_r_a_m_m_i_n_g
       _- _A _P_O_S_I_X _S_t_a_n_d_a_r_d _f_o_r _B_e_t_t_e_r _M_u_l_t_i_p_r_o_c_e_s_s_i_n_g', O'Reilly
       1996; ISBN 1-56592-115-1

       B. Lewis, D. J. Berg: `_M_u_l_t_i_t_h_r_e_a_d_e_d _P_r_o_g_r_a_m_m_i_n_g _w_i_t_h
       _P_t_h_r_e_a_d_s', Sun Microsystems Press, Prentice Hall 1998;
       ISBN 0-13-680729-1

       B. Lewis, D. J. Berg: `_T_h_r_e_a_d_s _P_r_i_m_e_r _- _A _G_u_i_d_e _T_o
       _M_u_l_t_i_t_h_r_e_a_d_e_d _P_r_o_g_r_a_m_m_i_n_g', Prentice Hall 1996; ISBN
       0-13-443698-9

       S. J. Norton, M. D. Dipasquale: `_T_h_r_e_a_d _T_i_m_e _- _T_h_e
       _M_u_l_t_i_t_h_r_e_a_d_e_d _P_r_o_g_r_a_m_m_i_n_g _G_u_i_d_e', Prentice Hall 1997; ISBN
       0-13-190067-6

       D. R. Butenhof: `_P_r_o_g_r_a_m_m_i_n_g _w_i_t_h _P_O_S_I_X _T_h_r_e_a_d_s', Addison
       Wesley 1997; ISBN 0-201-63392-2

       RReellaatteedd MMaannppaaggeess

       _p_t_h_-_c_o_n_f_i_g(1), _p_t_h_r_e_a_d(3).

       _g_e_t_c_o_n_t_e_x_t(2), _s_e_t_c_o_n_t_e_x_t(2), _m_a_k_e_c_o_n_t_e_x_t(2),
       _s_w_a_p_c_o_n_t_e_x_t(2), _s_i_g_s_t_a_c_k(2), _s_i_g_a_l_t_s_t_a_c_k(2), _s_i_g_a_c_t_i_o_n(2),
       _s_i_g_e_m_p_t_y_s_e_t(2), _s_i_g_a_d_d_s_e_t(2), _s_i_g_p_r_o_c_m_a_s_k(2),
       _s_i_g_s_u_s_p_e_n_d(2), _s_i_g_s_e_t_j_m_p(3), _s_i_g_l_o_n_g_j_m_p(3), _s_e_t_j_m_p(3),
       _l_o_n_g_j_m_p(3), _s_e_l_e_c_t(2), _g_e_t_t_i_m_e_o_f_d_a_y(2).

AAUUTTHHOORR
        Ralf S. Engelschall
        rse@engelschall.com
        www.engelschall.com


















08-Jun-2006               GNU Pth 2.0.7                        50


