
    TURBO PASCAL 5.5: ANSWERS TO COMMON QUESTIONS
    ---------------------------------------------

    1. Can I build programs bigger than 64K?

       The total size of a program's code is only limited by the
       memory you have available; but each unit (module) can be
       no larger than 64K, since it has to have its own code
       segment.

       The data segment is still no more than 64K, but the heap
       is unlimited just as in 3.0. In fact, we've rewritten the
       heap manager to make it much more efficient. There's no
       waste when allocating memory (in 3.0, all blocks were
       rounded up to a factor of 8), and you can install a heap
       error routine that gets called if an allocation request
       fails. All in all, 5.5's heap manager is much faster than
       version 3.0.

    2. Can Turbo Pascal run on generic MS-DOS machines?

       TPC.EXE will run on generic machines when you use the /Q
       option. The System, Overlay, Dos, and Printer standard
       units will operate correctly on MS-DOS generic machines.
       Generated .EXE's are MS-DOS compatible as long as you
       don't use the special PC units (such as Crt, Graph, and
       Graph3).

    3. Does Turbo Pascal 5.5 support large integers?

       Yes, TP 5.5 has virtually every incarnation of 8-, 16-, and
       32-bit integers: shortint, integer, longint, byte, and
       word.

    4. Will the toolboxes for 4.0 work with 5.5?

       Yes, all 4.0 versions of the toolboxes will work with
       Turbo Pascal 5.5. In a few cases, minor changes to
       compiler directives are recommended. Refer to the Turbo
       Pascal README file for more information.

    5. Does Turbo Pascal version 5.5 support conditional
       compilation?

       Yes, Turbo 5.5 includes conditional compilation support.
       You use {$DEFINE ...} and {$UNDEF ...} for symbols and
       {$IFDEF ...}. Using the {$IFOPT ...} conditional
       directive, you can even test the settings of compiler
       directives like R-, N+, and others. For the command-line
       compiler, you can define symbols with the /D directive. In
       the integrated compiler, you can also define symbols via
       the Options/Compiler/Conditional Defines menu command.

    6. How much of the 64K in the data segment is actually
       available to my program?

       The amount of data segment used by the run-time library
       depends on which standard units you use in your program.
       Here is the data segment usage (in bytes) for each unit:

             UNIT         Data Size
             ----         ---------
             System          664
             Overlay          24
             Crt              20
             Dos               6
             Printer         256
             Graph          1070
             Turbo3          256
             Graph3            0
                          =========
                            2282

       The total size of the data segment is 65,520 bytes. If you
       used only the System unit, the amount of data segment
       space left over would be

             65520 - 664 = 64856 bytes

    7. What is the largest global data structure you can
       allocate?

       The maximum size of a single variable that can be
       allocated on the heap is 65,521 bytes.

    8. How do I find out how much code and data were generated by
       the compiler for a program or unit?

       If you are using the integrated environment, build your
       program or unit and then use the Get Info command in the
       Compile menu. This will bring up a window of information
       that includes the size of code and data.

       If you are using the command-line compiler, the size of
       generated code and data is displayed on the screen at the
       end of compilation.

    9. Are the .OBJ files generated by Turbo C and Turbo
       Assembler compatible with 5.5?

       You can write Turbo C or Turbo Assembler routines and link
       the .OBJ files into your Turbo Pascal programs by using
       {$L} compiler directives. Turbo Pascal 5.5 generates .TPU
       (Turbo Pascal Unit) files, not .OBJ files. We've made that
       decision for many reasons:

         A. TP 5.5's .TPU files are smaller than .OBJ's, and they
            contain symbolic information important to the support
            of Pascal's strict type conventions (types, constants,
            etc.).

         B. .TPU files allow "smart linking" - elimination of
            unused code and data on a procedure-by-procedure
            basis.

         C. .TPU's allow built-in project management through
            version 5.5's Make and Build commands.

         D. .TPU's allow faster compilation speeds (34,000 lines
            per minute on a PS/2 Model 60).

   10. Will the $L compiler directive work for compiler object files
       other than assembler?

       That depends on the language. TURBO requires all the code
       in the .OBJ to be in *one* CODE segment, and all the data
       to be in *one* DATA segment. With assembly language that's
       easy, but it may not work with some high-level language
       compilers. You can use Turbo C to generate .OBJ files for
       use by Turbo Pascal programs. An example, CPASDEMO.PAS is
       included on the distribution disks.

   11. Does the built-in linker eliminate unused data?

       Yes. Unused code AND data are stripped when you compile to
       disk.

   12. If two units use a third unit, does the third unit get
       included twice in my program?

       No. All your units are "linked" together when you compile
       your program. Only one copy of each procedure and function
       used is generated.  There is NO duplication of run-time
       code. In fact, Turbo Pascal 5.5 has "smart linking," which
       eliminates any unused code and data from the final .EXE.

   13. What happens if you attempt to link another unit in which the
       compiler directives are set differently?

       Compiler directives are local to the unit they are
       declared in. Thus, the compiler directives in one unit, or
       in the main program, have no effect on the directives set
       in another unit.

   14. Can I create my own .TPL file?

       Yes, but Turbo Pascal will only use the TURBO.TPL library
       file. If you want to add your own units to the TURBO.TPL
       file, you can use the unit mover program (TPUMOVER.EXE).
       For example, you might want a customized version of
       TURBO.TPL for each of the programs you're developing. A
       corresponding configuration file for Turbo Pascal would
       specify a different Turbo directory and thus fetch the
       appropriate .TPL file for each of your projects.

   15. What rules should I follow when writing an interrupt
       handler?

       The following is a list of rules to keep in mind when
       writing an interrupt handler:

         A. Use GetIntVec and SetIntVec to install/uninstall
            interrupt handlers

         B. Use the interrupt directive

         C. Be careful about reentrancy. Don't use any calls to
            DOS or to Turbo Pascal's overlay or heap management
            routines in your interrupt handler

         D. Interrupt procedures and functions must use the far
            call model (use the {$F+} option)

         E. Be proficient with the BIOS and assembly language
            before attempting to write an interrupt handler

         F. Make sure your interrupt handler is not in an
            overlaid unit.

         G. Neither static nor virtual methods can be used as
            interrupt handlers.

   16. Does a procedure or function in a program have to be of a
       near or far call model?

       If you are using overlays or procedural variables, you
       should probably turn {$F+} on for all units and the main
       program (the extra overhead of always using far calls is
       usually quite small).

       Otherwise, Turbo Pascal automatically selects the correct
       call model. A routine is always a near call model unless

        1) It is declared in the interface section of a unit

        2) You override the default call model by using the {$F+}
           compiler option

        3) It is an object method. Methods are always far calls.

       You should also use the {$F+} option to override the
       default call model if you are writing interrupt handlers,
       error handlers, exit procedures, or procedures or
       functions that will be called via a procedural variable.

   17. How do I write reentrant code in Turbo Pascal?

       If a routine follows these rules, it is reentrant:

         A. All data is allocated on the stack.

         B. The routine doesn't use any global variables.

         C. The routine can be interrupted at any time without
            affecting the execution of the routine.

         D. The routine doesn't call any other routines that are
            not reentrant (e.g., DOS I/O).

   18. What is the best approach to taking advantage of the new IEEE
       floating-point types?

       The new IEEE floating-point types are available when you
       compile your program with {$N+} and you have a math
       coprocessor; they are also available if you don't have a
       coprocessor, but specify {N+,E+}. The 8087 emulator has
       greater precision, but is significantly slower than the
       fast, 6-byte, software-only reals. When developing
       programs that will be compiled and run on machines without
       the 8087 coprocessor, consider the trade-offs of speed
       (built-in reals) vs. precision (8087 hardware/emulation)
       and make the appropriate choice.

   19. What type is Comp? What is it useful for?

       The Comp type is a cross between an integer and a real
       type and is available when 8087 code is generated {$N+}.
       If no math coprocessor is available, specify {$N+,E+} and
       the emulator will support the Comp type.

       The compiler treats it as a real type without an exponent.
       Thus Comp is useful when you need to store extremely large
       numbers but don't need a decimal point. For example, you
       might use variables of type Comp to store amounts in cents
       and divide the value of the variable by 100 to determine
       what the value in dollars and cents would be.

   20. How many significant digits do the 8087 floating-point types
       provide?

       Type           Digits of precision
       --------       -------------------
       single               7-8
       double              15-16
       extended            19-20
       comp                19-20

   21. Are the intermediate results of real number expressions
       stored in the 8087 registers?

       No. The user (8086) stack is used to store intermediate
       results of real number expressions.

   22. How does rounding work with IEEE floating point?

       The 8087 math coprocessor uses a different method for
       rounding numbers than what you may be used to. In order to
       achieve a more even distribution of values, the 8087 uses
       a method sometimes called "Banker's Rounding." This method
       dictates that a number will always be rounded to the
       nearest EVEN number. Note that this is quite different
       than always rounding UP. Here are a couple of examples:

          Round(0.5) = 0
          Round(1.5) = 2

   23. How do you do I/O redirection?

       If you want to do DOS I/O redirection when running an .EXE
       file generated by Turbo Pascal, DON'T use the Crt unit. If
       you do, make sure you assign a null file name to the
       standard Output file handle:

         Assign(Output, '');   { Assign a null file name Output }
         ReWrite(Output);      { Open the file for output }

       Any Write statement that does not specify a file variable
       will be redirected to the DOS standard output file.

   24. How do you go about upgrading version 3.0 programs with
       lots of chain files?

       Chaining is not possible with .EXE files.  Control can be
       passed to another program by use of the EXEC procedure in
       the DOS unit. You can also use 5.5's overlay manager to
       build very large programs.

   25. Are overlays supported in 5.5?

       Yes! See the example program OVRDEMO.PAS and refer to the
       Turbo Pascal manual for information on overlays.

   26. Is there any support in Turbo Pascal 5.5 for file and record
       locking?

       There's a standard variable in the System unit called
       FileMode, which you can use to assign an open mode for use
       in all subsequent Resets. There are no record-locking
       routines implemented in the standard version, but they are
       easily implemented through MsDos calls.

   27. Does Turbo 5.5 support procedural parameters?

       Yes. See PROCVAR.PAS, DIRDEMO.PAS, and refer to the
       Reference Guide for a complete description.

   28. Can you use identifiers other than scalar in the case statement?

       Case statements allow the following ordinal types:

         Char, Boolean, ShortInt, Byte, Integer, Word, and
         user-defined enumeration.

   29. Is the run-time license policy the same as in version 3.0?

       YES, there are no royalties!

   30. C has static variables, is there anything similar in 5.5?

       You can declare private global variables in the
       implementation part of a unit. Such variables are only
       visible within that unit. Like other globals, they retain
       their values across calls.

       Typed constant declarations declared within a procedure or
       function also behave exactly like C's static variables.
       They are local in scope but since they are allocated in
       the data segment, they retain their values from call to
       call.

   31. What Turbo Pascal 3.0 code will cause the most problems
       converting to version 5.5?

       With our UPGRADE program (see appropriate Appendix in your
       manual), it's not very difficult to port your code to 5.5.
       It depends a lot on the type of programs you write.

       The passing of parameters on the stack is done much more
       efficiently now, so changes will have to be made to inline
       machine code and assembly language. Most of the changes
       are optional: using new types, breaking your program into
       modules to take advantage of separate compilation. (The
       UPGRADE program has a special option to help you "unitize"
       your program too. It does all the "typing" for you.)

       Some stricter type-checking is performed in version 5.5.
       For example, the Dos unit now defines the often-seen
       registers record type (AX, BX...); MsDos and Intr now take
       this type. In this case, you can type-cast or change the
       type identifier and recompile.

   32. What books can I read that will help me with Turbo Pascal
       5.5?

       The Turbo Pascal Tutor is an excellent reference to Turbo
       Pascal. Also, Osborne/McGraw Hill has a line of books
       about Borland's products.

   33. How do I use .BIN files provided by third-party vendors with
       5.5?

       We've included a utility on your distribution disk called
       BINOBJ.EXE, which converts binary files into .OBJ files
       that are linkable to your Turbo Pascal 5.5 programs. In
       general this will only work if the binary files contain
       data, not code. Contact your third-party vendor to see if
       they also provide .OBJ versions of their programs.

   34. Why does TURBO sometimes try to read from another drive
       when I run it?

       When you leave Turbo Pascal, it saves the name and path of
       the file you were last editing in a pick list. The next
       time you load Turbo, it checks this pick list and tries to
       load the file you were last editing. If the file you were
       last editing was in another drive, Turbo will try to read
       from that drive.  This also occurs if you have installed
       another drive as your Turbo Directory.

   35. Does Turbo Pascal 5.5 support EMS?

       Yes, Turbo Pascal 5.5 will use up to 64K of EMS for
       storing the edit buffer. In addition, you can instruct the
       Overlay unit to place your overlaid units in EMS. Finally,
       EMS.PAS on the distribution disk shows you how to access
       EMS memory from a Turbo Pascal program.

   36. How can I allocate my own I/O buffer for a text file?

       You can use the procedure SetTextBuf to allocate your own
       text file buffer either in the data segment or on the
       heap.

   37. Why aren't the new settings used after I install TURBO.EXE
       using the TINST.EXE program?

       You probably have a .TP file in the current or Turbo
       directory being loaded and the settings in the .TP file
       override the settings installed by TINST. Delete the .TP
       file.

   38. What is the largest string supported?

       A string can be 255 characters long. You can write your
       own routines to handle strings with lengths greater than
       255 characters.

   39. Can I still write to file 'Con' without changes?

       The 'Con' file is no longer supported, but you can still
       write to the screen with a simple Write with no file
       variable. The file system has been completely redesigned
       to allow you to write your own text file device drivers.
       With these, you can implement a Pascal-like text-file
       interface to any device, such as serial ports, windowing
       systems, memory, etc.

   40. What is constant merging?

       For example, when you use the same string constant more
       than once in a program block, the compiler only saves one
       copy of this string. In the generated program, a pointer
       is created that references the one copy of this string in
       the generated .EXE file.

   41. Have Turbo Pascal 3.0 run-time error codes changed in
       Turbo Pascal 5.5?

       Yes, error codes have changed; refer to Appendix I in the
       Reference Guide.  The Turbo3 unit contains a version 3.0
       compatible IOResult function.

